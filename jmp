


## Preliminaries
rm(list=ls())

# Change working directory to where you've stored ZTRAX
path<- "P:/Peter/Hedonics/Groundwater/"
#install.packages("dplyr", repos = "http://mran.revolutionanalytics.com")
## This function will check if a package is installed, and if not, install it
pkgTest <- function(x) {
  if (!require(x, character.only = TRUE))
  {
    install.packages(x, dep = TRUE)
    if(!require(x, character.only = TRUE)) stop("Package not found")
  }
}

## These lines load the required packages
packages <- c("readxl","Hmisc","DescTools","qgam","quantreg","sphet","mgcv","McSpatial","pastecs","rdd","Matrix","psych","xtable","splines","ck37r","data.table","matrixStats","tmle","xgboost", "MatchIt","gtools","statar","foreign","multiwayvcov","lmtest","readstata13","xlsx", "data.table","doSNOW","parallel","compare","doParallel","devtools","foreach","spdep","reshape2","sm","plyr","utils","tcltk","geosphere", "matrixcalc", "dplyr","ExPosition", "randomForest","lfe", "hdm", "rdrobust", "stargazer", "ggplot2", "outliers","rpart","e1071")
lapply(packages, pkgTest)
packages <- c("readxl","Hmisc","cobalt","WeightIt","grf","classInt","RColorBrewer","rgdal","DescTools","qgam","quantreg","sphet","mgcv","McSpatial","pastecs","rdd","Matrix","psych","xtable","splines","ck37r","data.table","matrixStats","tmle","xgboost", "MatchIt","gtools","statar","foreign","multiwayvcov","lmtest","readstata13","xlsx", "data.table","doSNOW","parallel","compare","doParallel","devtools","foreach","spdep","reshape2","sm","plyr","utils","tcltk","geosphere", "matrixcalc", "dplyr","ExPosition", "randomForest","lfe", "hdm", "rdrobust", "stargazer", "ggplot2", "outliers","rpart","e1071")
lapply(packages, pkgTest)
install_github("ngreifer/cobalt", subdir="pkg")

#,"cobalt"
if(TRUE){
  is.designmatch <- function(x) {
    dm.b.names <- c("obj_total", "obj_dist_mat", "t_id", 
                    "c_id", "group_id", "time")
    dm.n.names <- c("obj_total", "obj_dist_mat", "id_1", 
                    "id_2", "group_id", "time")
    if (length(x) >= min(length(dm.b.names), length(dm.n.names)) && 
        (all(dm.b.names %in% names(x)) || all(dm.n.names %in% names(x)))) {
      class(x) <- c("designmatch")
    }
    return(x)
  }
  
  #x2base
  match.strata2weights <- function(match.strata, treat, covs = NULL) {
    #Process match.strata into weights (similar to weight.subclass from MatchIt)
    if (is.null(covs)) names(treat) <- seq_along(treat)
    else names(treat) <- row.names(covs)
    matched <- !is.na(match.strata); unmatched <- !matched
    treat.matched <- treat[matched]
    match.strata.matched <- match.strata[matched]
    
    labels <- names(treat.matched)
    tlabels <- labels[treat.matched == 1]
    clabels <- labels[treat.matched == 0]
    
    weights.matched <- rep(0, length(treat.matched))
    names(weights.matched) <- labels
    weights.matched[tlabels] <- 1
    
    for (j in unique(match.strata.matched)){
      qn0 <- sum(treat.matched==0 & match.strata.matched==j)
      qn1 <- sum(treat.matched==1 & match.strata.matched==j)
      weights.matched[treat.matched==0 & match.strata.matched==j] <- qn1/qn0
    }
    if (all(check_if_zero(weights.matched[clabels]))) #all control weights are 0
      weights.matched[clabels] <- rep(0, length(weights.matched[clabels]))
    else {
      ## Number of C units that were matched to at least 1 T
      num.cs <- sum(!check_if_zero(weights.matched[clabels]))
      weights.matched[clabels] <- weights.matched[clabels]*num.cs/sum(weights.matched[clabels])
    }
    
    if (any(unmatched)) {
      weights.unmatched <- rep(0, sum(unmatched))
      names(weights.unmatched) <- names(treat[unmatched])
      weights <- c(weights.matched, weights.unmatched)[names(treat)]
    }
    else {
      weights <- weights.matched
    }
    
    if (all(check_if_zero(weights))) 
      stop("No units were matched", call. = FALSE)
    else if (all(check_if_zero(weights[tlabels])))
      stop("No treated units were matched", call. = FALSE)
    else if (all(check_if_zero(weights[clabels])))
      stop("No control units were matched", call. = FALSE)
    return(weights)
  }
  .use.tc.fd <- function(formula, data, treat, covs) {
    useWhich <- function(f, d, t, c) {
      #output: tc, fd, both
      good <- c(formula=0, data=0, covs=0, treat=0)
      if (length(f) > 0 & class(f)=="formula") good[1] <- 1
      if (length(d) > 0 & is.data.frame(d)) good[2] <- 1
      if (length(c) > 0 & is.data.frame(c)) good[3] <- 1
      if (length(t) > 0 & length(unique(t))==2) good[4] <- 1
      
      if (sum(good) <= 1) {
        stop("Either formula and data or treat and covs must be specified correctly.", call. = FALSE)
      }
      else if (sum(good) == 2) {
        if (sum(good[c("formula", "data")])==0) {
          use.which <- "tc"}
        else if (sum(good[c("formula", "data")])==1) {
          stop("Either formula and data or treat and covs must be specified correctly.", call. = FALSE)}
        else { #if (sum(good[c("formula", "data")])==2)
          use.which <- "fd"}
      }
      else if (sum(good) == 3) {
        bad <- names(good)[match(0, good)]
        if (any(c("formula", "data") == bad)) {
          warning(paste("Argument to", bad, "is missing; using treat and covs instead."), call. = FALSE, immediate.=TRUE)
          use.which <- "tc"}
        else {
          warning(paste("Argument to", bad, "is missing; using formula and data instead."), call. = FALSE, immediate.=TRUE)
          use.which <- "fd"}
      }
      else { #if (sum(good)==4)
        use.which <- "both"
      }
      return(use.which)
    }
    use.fd <- function(f, d){
      #outputs a list containing treat [1] and covs [2]
      out.list <- list(treat=NA, covs=data.frame(NA))
      tt <- terms(f)
      attr(tt, "intercept") <- 0
      mf<- tryCatch(model.frame(tt, d),
                    error = function(cond) stop(paste0(c("All right hand side variables of formula must be variables in data.\nVariables not in data: ",
                                                         paste(attr(tt, "term.labels")[which(attr(tt, "term.labels") %nin% names(d))], collapse=", "))), call. = FALSE))
      out.list$treat <- setNames(model.response(mf), rownames(d)) #treat
      out.list$covs <- d[attr(tt, "term.labels")] #covs
      attr(out.list, "which") <- "fd"
      return(out.list)
    }
    use.tc <- function(t, c) {
      if (length(t)!=nrow(c)) {
        stop("treat must be the same length as covs.", call. = FALSE)}
      out.list <- list(treat=setNames(t, rownames(c)), covs=c)
      attr(out.list, "which") <- "tc"
      return(out.list)
    }
    
    use.which <- useWhich(formula, data, treat, covs)
    
    if (use.which == "fd") {
      t.c <- use.fd(formula, data)}
    else if (use.which == "tc") {
      t.c <- use.tc(treat, covs)}
    else if (use.which == "both") {
      try.fd <- try({t.c <- use.fd(formula, data)})
      if (class(try.fd) == "try-error") {
        message("Formula, data, treat, and covs all supplied; ignoring formula and data.")
        t.c <- use.tc(treat, covs)}
      else {
        message("Formula, data, treat, and covs all supplied; ignoring treat and covs.")}
    }
    return(t.c)
  }
  use.tc.fd <- function(formula = NULL, data = NULL, treat = NULL, covs = NULL, needs.treat = TRUE, needs.covs = TRUE) {
    if (is_not_null(formula) && class(formula) == "formula") {
      D <- NULL
      if (is_not_null(data)) D <- data
      if (is_not_null(covs)) if (is_not_null(D)) D <- cbind(D, covs) else D <- covs
      t.c <- get.covs.and.treat.from.formula(formula, D, treat = treat)
      t.c <- list(treat = t.c[["treat"]], covs = t.c[["reported.covs"]])
      attr(t.c, "which") <- "fd"
    }
    else {
      if (is.matrix(covs)) covs <- as.data.frame(covs)
      else if (!is.data.frame(covs)) stop("covs must be a data.frame of covariates.", call. = FALSE)
      if (!is.atomic(treat)) stop("treat must be an atomic vector of treatment statuses.", call. = FALSE)
      t.c <- list(treat = treat, covs = covs)
      attr(t.c, "which") <- "tc"
    }
    
    if (needs.covs && is.null(t.c[["covs"]])) stop("No covariates were specified.", call. = FALSE)
    if (needs.treat && is.null(t.c[["treat"]])) stop("No treatment variable was specified.", call. = FALSE)
    
    return(t.c)
  }
  process.val <- function(val, i, treat, covs, ...) {
    if (is.numeric(val)) {
      val.df <- setNames(data.frame(val), i)
    }
    else if (is.character(val)) {
      data.sets <- list(...)
      data.sets <- data.sets[!sapply(data.sets, is.null)]
      if ((is_not_null(data.sets) && length(val) > max(sapply(data.sets, ncol))) || length(val) == nrow(covs) || length(val) == length(treat)){
        val.df <- setNames(data.frame(val), i)
      }
      else {
        if (is_not_null(data.sets)) {
          val <- unique(val)
          val.df <- setNames(as.data.frame(matrix(NA, ncol = length(val), nrow = max(sapply(data.sets, nrow)))),
                             val)
          not.found <- setNames(rep(FALSE, length(val)), val)
          for (v in val) {
            found <- FALSE
            k <- 1
            while (found == FALSE && k <= length(data.sets)) {
              if (v %in% names(data.sets[[k]])) {
                val.df[[v]] <- data.sets[[k]][[v]]
                found <- TRUE
              }
              else k <- k + 1
            }
            if (!found) not.found[v] <- TRUE
          }
          if (any(not.found)) {
            warning(paste("The following variable(s) named in", i, "are not in any available data sets and will be ignored: ",
                          paste(val[not.found])), call. = FALSE)
            val.df <- val.df[!not.found]
          }
        }
        else {
          val.df <- NULL
          warning(paste0("Names were provided to ", i, ", but no argument to data was provided. Ignoring ", i,"."), 
                  call. = FALSE)
        }
      }
    }
    else if (is.data.frame(val)) {
      val.df <- val
    }
    else stop(paste("The argument supplied to", i, "must be a vector, a data.frame, or the names of variables in an available data set."), call. = FALSE)
    
    return(val.df)
  }
  data.frame.process <- function(i, df, treat, covs, ...) {
    val <- df
    val.df <- NULL
    if (is_not_null(val)) {
      if (is.vector(val, mode = "list")) {
        val.list <- lapply(val, function(x) process.val(x, i, treat, covs, ...))
        val.list <- lapply(seq_along(val.list), function(x) {
          if (ncol(val.list[[x]]) == 1) names(val.list[[x]]) <- names(val.list)[x]
          val.list[[x]]})
        if (!all_the_same(sapply(val.list, nrow))) {
          stop(paste("Not all items in", i, "have the same length."), call. = FALSE)
        }
        
        val.df <- setNames(do.call("cbind", val.list),
                           c(sapply(val.list, names)))
      }
      else {
        val.df <- process.val(val, i, treat, covs, ...)
      }
      if (is_not_null(val.df)) { if (sum(is.na(val.df)) > 0) {
        stop(paste0("Missing values exist in ", i, "."), call. = FALSE)}
      }
    }
    return(val.df)
  }
  list.process <- function(i, List, ntimes, call.phrase, treat.list, covs.list, ...) {
    val.List <- List
    if (is_not_null(val.List)) {
      if (class(val.List)[1] != "list") {
        val.List <- list(val.List)
      }
      if (length(val.List) == 1) {
        val.List <- replicate(ntimes, val.List)
      }
      else if (length(val.List) == ntimes) {
        
      }
      else {
        stop(paste0("The argument to ", i, " must be a list of the same length as the number of time points in ",  call.phrase, "."), call. = FALSE)
      }
      for (ti in seq_along(val.List)) {
        val <- val.List[[ti]]
        val.df <- NULL
        if (is_not_null(val)) {
          if (is.vector(val, mode = "list")) {
            val.list <- lapply(val, function(x) process.val(x, strsplit(i, ".list")[[1]], treat.list[[ti]], covs.list[[ti]], ...))
            val.list <- lapply(seq_along(val.list), function(x) {
              if (ncol(val.list[[x]]) == 1) names(val.list[[x]]) <- names(val.list)[x]
              val.list[[x]]})
            if (!all_the_same(sapply(val.list, nrow))) {
              stop(paste("Not all items in", i, "have the same length."), call. = FALSE)
            }
            
            val.df <- setNames(do.call("cbind", val.list),
                               c(sapply(val.list, names)))
          }
          else {
            val.df <- process.val(val, strsplit(i, ".list")[[1]], treat.list[[ti]], covs.list[[ti]], ...)
          }
          if (is_not_null(val.df)) { if (sum(is.na(val.df)) > 0) {
            stop(paste0("Missing values exist in ", i, "."), call. = FALSE)}
          }
          val.List[[ti]] <- val.df
        }
        
      }
      val.df.lengths <- sapply(val.List[lengths(val.List) > 0], nrow)
      if (max(val.df.lengths) != min(val.df.lengths)) {
        stop(paste("All columns in", i, "need to have the same number of rows."), call. = FALSE)
      }
    }
    return(val.List)
  }
  null.or.error <- function(x) {is.null(x) || class(x) == "try-error"}
  get.covs.and.treat.from.formula <- function(f, data, env = .GlobalEnv, ...) {
    A <- list(...)
    
    tt <- terms(f, data = data)
    attr(tt, "intercept") <- 0
    
    #Check if data exists
    if (is_not_null(data) && is.data.frame(data)) {
      data.specified <- TRUE
    }
    else data.specified <- FALSE
    
    #Check if response exists
    if (is.formula(tt, 2)) {
      resp.vars.mentioned <- as.character(tt)[2]
      resp.vars.failed <- sapply(resp.vars.mentioned, function(v) {
        null.or.error(try(eval(parse(text = v), c(data, env)), silent = TRUE))
      })
      
      if (any(resp.vars.failed)) {
        if (is.null(A[["treat"]])) stop(paste0("The given response variable, \"", as.character(tt)[2], "\", is not a variable in ", word.list(c("data", "the global environment")[c(data.specified, TRUE)], "or"), "."), call. = FALSE)
        tt <- delete.response(tt)
      }
    }
    else resp.vars.failed <- TRUE
    
    if (any(!resp.vars.failed)) {
      treat.name <- resp.vars.mentioned[!resp.vars.failed][1]
      tt.treat <- terms(as.formula(paste0(treat.name, " ~ 1")))
      mf.treat <- quote(stats::model.frame(tt.treat, data,
                                           drop.unused.levels = TRUE,
                                           na.action = "na.pass"))
      
      tryCatch({mf.treat <- eval(mf.treat, c(data, env))},
               error = function(e) {stop(conditionMessage(e), call. = FALSE)})
      treat <- model.response(mf.treat)
    }
    else {
      treat <- A[["treat"]]
      treat.name <- NULL
    }
    
    #Check if RHS variables exist
    tt.covs <- delete.response(tt)
    rhs.vars.mentioned.lang <- attr(tt.covs, "variables")[-1]
    rhs.vars.mentioned <- sapply(rhs.vars.mentioned.lang, deparse)
    rhs.vars.failed <- sapply(rhs.vars.mentioned.lang, function(v) {
      null.or.error(try(eval(v, c(data, env)), silent = TRUE))
    })
    
    if (any(rhs.vars.failed)) {
      stop(paste0(c("All variables in formula must be variables in data or objects in the global environment.\nMissing variables: ",
                    paste(rhs.vars.mentioned[rhs.vars.failed], collapse=", "))), call. = FALSE)
      
    }
    
    rhs.term.labels <- attr(tt.covs, "term.labels")
    rhs.term.orders <- attr(tt.covs, "order")
    
    rhs.df <- sapply(rhs.vars.mentioned.lang, function(v) {
      is.data.frame(try(eval(v, c(data, env)), silent = TRUE))
    })
    
    if (any(rhs.df)) {
      if (any(rhs.vars.mentioned[rhs.df] %in% unlist(sapply(rhs.term.labels[rhs.term.orders > 1], function(x) strsplit(x, ":", fixed = TRUE))))) {
        stop("Interactions with data.frames are not allowed in the input formula.", call. = FALSE)
      }
      addl.dfs <- setNames(lapply(rhs.vars.mentioned.lang[rhs.df], function(x) {eval(x, env)}),
                           rhs.vars.mentioned[rhs.df])
      
      for (i in rhs.term.labels[rhs.term.labels %in% rhs.vars.mentioned[rhs.df]]) {
        ind <- which(rhs.term.labels == i)
        rhs.term.labels <- append(rhs.term.labels[-ind], 
                                  values = names(addl.dfs[[i]]), 
                                  after = ind - 1)
      }
      new.form <- as.formula(paste("~", paste(rhs.term.labels, collapse = " + ")))
      
      tt.covs <- terms(new.form)
      if (is_not_null(data)) data <- do.call("cbind", unname(c(addl.dfs, list(data))))
      else data <- do.call("cbind", unname(addl.dfs))
    }
    
    #Get model.frame, report error
    mf.covs <- quote(stats::model.frame(tt.covs, data,
                                        drop.unused.levels = TRUE,
                                        na.action = "na.pass"))
    tryCatch({covs <- eval(mf.covs, c(data, env))},
             error = function(e) {stop(conditionMessage(e), call. = FALSE)})
    
    if (is.null(rhs.vars.mentioned)) covs <- data.frame(Intercept = rep(1, if (is.null(treat)) 1 else length(treat)))
    
    #Get full model matrix with interactions too
    covs.matrix <- model.matrix(tt.covs, data = covs,
                                contrasts.arg = lapply(covs[sapply(covs, is.factor)], 
                                                       contrasts, contrasts=FALSE))
    
    attr(covs, "terms") <- NULL
    
    return(list(reported.covs = covs,
                model.covs = covs.matrix,
                treat = treat,
                treat.name = treat.name))
  }
  
  #get.C
  #Functions to turn input covariates into usable form
  #int.poly.f creates interactions and polynomials
  #splitfactor splits factor variable into indicators (now in utilities)
  #binarize transforms 2-value variable into binary (0,1)
  #get.C controls flow and handles redunancy
  #get.types gets variables types (contin./binary)
  
  int.poly.f <- function(mat, ex=NULL, int=FALSE, poly=1, nunder=1, ncarrot=1) {
    #Adds to data frame interactions and polynomial terms; interaction terms will be named "v1_v2" and polynomials will be named "v1_2"
    #Only to be used in base.bal.tab; for general use see int.poly()
    #mat=matrix input
    #ex=matrix of variables to exclude in interactions and polynomials; a subset of df
    #int=whether to include interactions or not; currently only 2-way are supported
    #poly=degree of polynomials to include; will also include all below poly. If 1, no polynomial will be included
    #nunder=number of underscores between variables
    
    if (is_not_null(ex)) d <- mat[, colnames(mat) %nin% colnames(ex), drop = FALSE]
    else d <- mat
    nd <- ncol(d)
    nrd <- nrow(d)
    no.poly <- apply(d, 2, is_binary)
    npol <- nd - sum(no.poly)
    new <- matrix(0, ncol = (poly-1)*npol + int*(.5*(nd)*(nd-1)), nrow = nrd)
    nc <- ncol(new)
    new.names <- character(nc)
    if (poly > 1 && npol != 0) {
      for (i in 2:poly) {
        new[, (1 + npol*(i - 2)):(npol*(i - 1))] <- apply(d[, !no.poly, drop = FALSE], 2, function(x) x^i)
        new.names[(1 + npol*(i - 2)):(npol*(i - 1))] <- paste0(colnames(d)[!no.poly], num_to_superscript(i))
      }
    }
    if (int && nd > 1) {
      new[,(nc - .5*nd*(nd-1) + 1):nc] <- matrix(t(apply(d, 1, combn, 2, prod)), nrow = nrd)
      new.names[(nc - .5*nd*(nd-1) + 1):nc] <- combn(colnames(d), 2, paste, collapse=paste0(replicate(nunder, "_"), collapse = ""))
    }
    
    single.value <- apply(new, 2, all_the_same)
    colnames(new) <- new.names
    #new <- setNames(data.frame(new), new.names)[!single.value]
    return(new[, !single.value, drop = FALSE])
  }
  binarize <- function(variable) {
    nas <- is.na(variable)
    if (!is_binary(variable[!nas])) stop(paste0("Cannot binarize ", deparse(substitute(variable)), ": more than two levels."))
    variable.numeric <- as.numeric(variable)
    if (0 %in% unique(variable.numeric)) zero <- 0
    else zero <- min(unique(variable.numeric), na.rm = TRUE)
    newvar <- setNames(ifelse(!nas & variable.numeric==zero, 0, 1), names(variable))
    newvar[nas] <- NA
    return(newvar)
  }
  get.C <- function(covs, int = FALSE, addl = NULL, distance = NULL, cluster = NULL) {
    #gets C data.frame, which contains all variables for which balance is to be assessed. Used in balance.table.
    
    C <- covs
    if (!is.null(addl)) {
      if (!is.data.frame(addl)) {
        if (is.character(addl)) stop("The argument to addl must be a data.frame containing the the values of the additional variables you want to include in the balance assessment.", call. = FALSE)
        else stop("The argument to addl must be a data.frame. Wrap data.frame() around the argument if it is a matrix or vector.", call. = FALSE)
      }
      else {
        repeat.name.indices <- sapply(names(addl), function(x) x %in% names(C))
        if (any(repeat.name.indices)) {
          warning(paste("The following variables in addl have the same name as covariates and will be ignored:\n",
                        paste(names(addl)[repeat.name.indices], collapse = " ")), call. = FALSE)
          addl <- addl[!repeat.name.indices]
        }
        C <- cbind(C, addl)
      }
    } 
    
    covs.with.inf <- unlist(sapply(C, function(x) any(!is.finite(x) & !is.na(x))))
    if (any(covs.with.inf)) {
      s <- if (sum(covs.with.inf) == 1) c("", "s") else c("s", "")
      stop(paste0("The variable", s[1], " ", word.list(names(C)[covs.with.inf], quotes = TRUE), 
                  " contain", s[2], " non-finite values, which are not allowed."), call. = FALSE)
    }
    
    vars.w.missing <- data.frame(placed.after = names(C),
                                 has.missing = FALSE, 
                                 has.Inf = FALSE,
                                 row.names = names(C),
                                 stringsAsFactors = FALSE)
    for (i in names(C)) {
      if (is.character(C[[i]])) C[[i]] <- factor(C[[i]])
      else if (is_binary(C[[i]][!is.na(C[[i]])])) {
        if (is.logical(C[[i]])) C[[i]] <- as.numeric(C[[i]])
        else if (is.numeric(C[[i]])) C[[i]] <- binarize(C[[i]])
      }
      
      if (nlevels(cluster) > 0 && qr(matrix(c(C[[i]], as.numeric(cluster)), ncol = 2))$rank == 1) {
        C <- C[names(C) != i] #Remove variable if it is the same (linear combo) as cluster variable
      }
      else {
        if (any(is.na(C[[i]]))) vars.w.missing[i, "has.missing"] <- TRUE
        if (!is.numeric(C[[i]])) {
          old.C.names <- names(C)
          C <- splitfactor(C, i, replace = TRUE, sep = "_", drop.first = FALSE, 
                           drop.singleton = FALSE)
          newly.added.names <- names(C)[names(C) %nin% old.C.names]
          vars.w.missing[i, "placed.after"] <- newly.added.names[length(newly.added.names)]
        }
      }
    }
    #Make sure categorical variable have missingness indicators done correctly
    C <- as.matrix(C)
    single.value <- apply(C, 2, all_the_same)
    C <- C[, !single.value, drop = FALSE]
    
    #Process int
    if (length(int) != 1L || !is.finite(int) || !(is.logical(int) || is.numeric(int))) {
      stop("int must be TRUE, FALSE, or a numeric value of length 1.", call. = FALSE)
    }
    int <- as.integer(round(int))
    if (int < 0) {
      stop("int must be TRUE, FALSE, or a numeric (integer) value greater than 1.", call. = FALSE)
    }
    
    if (int) {
      #Prevent duplicate var names with _'s
      nunder <- ncarrot <- 1
      repeat {
        if (all(sapply(colnames(C), function(x) x %nin% do.call(paste, c(expand.grid(colnames(C), colnames(C)), list(sep = paste0(replicate(nunder, "_"), collapse = ""))))))) break
        else nunder <- nunder + 1
      }
      #Variable names don't contain carrots
      # repeat {
      #     if (all(sapply(names(C), function(x) x %nin% paste0(names(C), paste0(replicate(nunder, "_"), collapse = ""), "2")))) break
      #     else ncarrot <- ncarrot + 1
      # }
      if (as.numeric(int) %in% c(1, 2)) poly <- 2
      else poly <- int
      C <- cbind(C, int.poly.f(C, int = TRUE, poly = poly, nunder = nunder, ncarrot = ncarrot))
      
    }
    #Remove duplicate & redundant variables
    C <- remove.perfect.col(C)    
    
    #Add missingness indicators
    vars.w.missing <- vars.w.missing[vars.w.missing$placed.after %in% colnames(C) & vars.w.missing$has.missing, , drop = FALSE]
    if (nrow(vars.w.missing) > 0) {
      original.var.order <- setNames(seq_len(ncol(C)), colnames(C))
      new.var.order <- original.var.order + cumsum(c(0,(colnames(C) %in% vars.w.missing$placed.after)[-ncol(C)]))
      missing.ind <- apply(C[,colnames(C) %in% vars.w.missing$placed.after, drop = FALSE], 2, function(x) as.numeric(is.na(x)))
      colnames(missing.ind) <- paste0(rownames(vars.w.missing), ":<NA>")
      missing.ind <- remove.perfect.col(missing.ind) 
      new.C <- matrix(NA, nrow = nrow(C), ncol = ncol(C) + ncol(missing.ind),
                      dimnames = list(rownames(C), seq_len(ncol(C) + ncol(missing.ind))))
      new.C[, new.var.order] <- C
      new.C[, -new.var.order] <- missing.ind
      colnames(new.C)[new.var.order] <- colnames(C)
      colnames(new.C)[-new.var.order] <- colnames(missing.ind)
      C <- new.C
      if (int) {
        C <- cbind(C, int.poly.f(missing.ind, int = TRUE, poly = 1, nunder = 1, ncarrot = 1))
      }
    }
    
    if (is_not_null(distance)) {
      if (any(names(distance) %in% colnames(C))) stop("distance variable(s) share the same name as a covariate. Please ensure each variable name is unique.", call. = FALSE)
      C <- cbind(distance, C, row.names = NULL)
      attr(C, "distance.names") <- names(distance)
    }
    
    return(C)
    
  }
  get.types <- function(C) {
    sapply(colnames(C), function(x) {
      if (any(attr(C, "distance.names") == x)) "Distance"
      else if (is_binary(C[,x]))  "Binary"
      else "Contin."
    })
  }
  remove.perfect.col <- function(C) {
    #If many rows, select subset to test redundancy
    if (nrow(C) > 1500) {
      repeat {
        mini.C <- C[sample(seq_len(nrow(C)), 1000),,drop=FALSE]
        single.value <- apply(mini.C, 2, all_the_same)
        if (all(!single.value)) break
      }
      suppressWarnings(C.cor <- cor(mini.C, use = "pairwise.complete.obs"))
    }
    else suppressWarnings(C.cor <- cor(C, use = "pairwise.complete.obs"))
    
    s <- !lower.tri(C.cor, diag=TRUE) & check_if_zero(1 - abs(C.cor))
    redundant.vars <- apply(s, 2, any)
    C <- C[, !redundant.vars, drop = FALSE] 
    return(C)
  }
  num_to_superscript <- function(x) {
    nums <- setNames(c("\u2070",
                       "\u00B9",
                       "\u00B2",
                       "\u00B3",
                       "\u2074",
                       "\u2075",
                       "\u2076",
                       "\u2077",
                       "\u2078",
                       "\u2079"),
                     as.character(0:9))
    x <- as.character(x)
    splitx <- strsplit(x, "")
    supx <- sapply(splitx, function(y) paste0(nums[y], collapse = ""))
    return(supx)
  }
  
  #base.bal.tab
  check_if_zero_weights <- function(weights.df, treat, unique.treat = NULL) {
    if (is.null(unique.treat)) unique.treat <- unique(treat)
    w.t.mat <- expand.grid(colnames(weights.df), unique.treat)
    problems <- apply(w.t.mat, 1, function(x) all(check_if_zero(weights.df[treat == x[2], x[1]])))
    prob.w.t.mat <- droplevels(w.t.mat[problems,])
    if (any(problems)) {
      if (ncol(weights.df) == 1) {
        error <- paste0("All weights are zero when ", word.list(paste("treat =", prob.w.t.mat[, 2]), "or"), ".")
      }
      else {
        errors <- setNames(character(nlevels(prob.w.t.mat[,1])), levels(prob.w.t.mat[,1]))
        
        for (i in levels(prob.w.t.mat[,1])) {
          errors[i] <- paste0("\"", i, "\" weights are zero when ", word.list(paste("treat =", prob.w.t.mat[prob.w.t.mat[,1] == i, 2]), "or"))
        }
        errors <- paste(c("All", rep("all", length(errors)-1)), errors)
        error <- paste0(word.list(errors, "and"), ".")
      }
      stop(error, call. = FALSE)
    }
  }
  w.m <- function(x, w = NULL, na.rm = TRUE) {
    if (is.null(w)) w <- as.numeric(!is.na(x))
    return(sum(x*w, na.rm=na.rm)/sum(w, na.rm=na.rm))
  }
  col.w.m <- function(mat, w = NULL, na.rm = TRUE) {
    if (is.null(w)) {
      w <- 1
      w.sum <- apply(mat, 2, function(x) sum(!is.na(x)))
    }
    else {
      w.sum <- apply(mat, 2, function(x) sum(w[!is.na(x)], na.rm = na.rm))
    }
    return(colSums(mat*w, na.rm = na.rm)/w.sum)
  }
  w.cov.scale <- function(w) {
    (sum(w, na.rm = TRUE)^2 - sum(w^2, na.rm = TRUE)) / sum(w, na.rm = TRUE)
  }
  w.v <- function(x, w = NULL) {
    #return(sum(w*(x-w.m(x, w))^2, na.rm=TRUE)/(sum(w, na.rm=TRUE)-1))
    return(sum(w*(x-w.m(x, w))^2, na.rm=TRUE) / w.cov.scale(w))
  }
  col.w.v <- function(mat, w = NULL, na.rm = TRUE) {
    if (is.null(w)) {
      w <- rep(1, nrow(mat))
    }
    return(colSums(t((t(mat) - col.w.m(mat, w, na.rm = na.rm))^2) * w, na.rm = na.rm) / w.cov.scale(w))
  }
  w.cov <- function(x, y , w = NULL) {
    wmx <- w.m(x, w)
    wmy <- w.m(y, w)
    #wcov <- sum(w*(x - wmx)*(y - wmy), na.rm = TRUE)/sum(w, na.rm = TRUE)
    wcov <- sum(w*(x - wmx)*(y - wmy), na.rm = TRUE) / w.cov.scale(w)
    return(wcov)
  }
  col.std.diff <- function(mat, treat, weights, subclass = NULL, which.sub = NULL, x.types, continuous, binary, s.d.denom, no.weights = FALSE, s.weights = rep(1, length(treat)), pooled.sds = NULL) {
    if (no.weights) weights <- rep(1, nrow(mat))
    w <- weights*s.weights
    sw <- s.weights
    
    no.sub <- is.null(which.sub)
    if (no.sub) ss <- sw > 0
    else {
      ss <- (!is.na(subclass) & subclass == which.sub & sw > 0)
      
      if (sum(treat==0 & ss) == 0) {
        warning(paste0("There are no control units in subclass ", which.sub, "."), call. = FALSE)
        return(rep(NA, ncol(mat)))
      }
      if (sum(treat==1 & ss) == 0) {
        warning(paste0("There are no treated units in subclass ", which.sub, "."), call. = FALSE)
        return(rep(NA, ncol(mat)))
      }
    }
    
    diffs <- col.w.m(mat[treat == 1 & ss, , drop = FALSE], w[treat == 1 & ss]) - 
      col.w.m(mat[treat == 0 & ss, , drop = FALSE], w[treat == 0 & ss])
    diffs[check_if_zero(diffs)] <- 0
    denoms <- rep(1, ncol(mat))
    denoms.to.std <- ifelse(x.types == "Binary", binary == "std", continuous == "std")
    
    if (any(denoms.to.std)) {
      if (s.d.denom == "control") {
        denoms[denoms.to.std] <- sqrt(col.w.v(mat[treat == 0 & ss, denoms.to.std, drop = FALSE], s.weights[treat == 0 & ss]))
      }
      else if (s.d.denom == "treated") {
        denoms[denoms.to.std] <- sqrt(col.w.v(mat[treat == 1 & ss, denoms.to.std, drop = FALSE], s.weights[treat == 1 & ss]))
      }
      else if (s.d.denom == "pooled") {
        if (is_not_null(pooled.sds)) {
          denoms[denoms.to.std] <- pooled.sds[denoms.to.std]
        }
        else {
          denoms[denoms.to.std] <-  sqrt(.5*(col.w.v(mat[treat == 0 & ss, denoms.to.std, drop = FALSE], s.weights[treat == 0 & ss]) +
                                               col.w.v(mat[treat == 1 & ss, denoms.to.std, drop = FALSE], s.weights[treat == 1 & ss])))
        }
      }
    }
    
    std.diffs <- diffs/denoms
    std.diffs[!is.finite(std.diffs)] <- NA
    
    return(std.diffs)
  }
  col.ks <- function(mat, treat, weights, x.types, no.weights = FALSE) {
    ks <- rep(NA_integer_, ncol(mat))
    if (no.weights) weights <- rep(1, nrow(mat))
    weights[treat == 1] <- weights[treat==1]/sum(weights[treat==1])
    weights[treat == 0] <- -weights[treat==0]/sum(weights[treat==0])
    non.binary <- x.types != "Binary"
    ks[non.binary] <- apply(mat[, non.binary, drop = FALSE], 2, function(x_) {
      x <- x_[!is.na(x_)]
      ordered.index <- order(x)
      cumv <- abs(cumsum(weights[ordered.index]))[diff(x[ordered.index]) != 0]
      return(if (is.null(cumv)) 0 else max(cumv))
    })
    return(ks)
  }
  col.var.ratio <- function(mat, treat, weights, x.types, no.weights = FALSE) {
    if (no.weights) weights <- rep(1, nrow(mat))
    ratios <- rep(NA, ncol(mat))
    non.binary <- x.types != "Binary"
    ratios[non.binary] <- col.w.v(mat[treat == 1, non.binary, drop = FALSE], w = weights[treat == 1]) / col.w.v(mat[treat == 0, non.binary, drop = FALSE], w = weights[treat == 0])
    return(pmax(ratios, 1/ratios))
  }
  baltal <- function(threshold) {
    #threshold: vector of threshold values (i.e., "Balanced"/"Not Balanced")
    threshnames <- names(table(threshold))
    balstring <- threshnames[nchar(threshnames) > 0][1]
    thresh.val <- substring(balstring, 1 + regexpr("[><]", balstring), nchar(balstring))
    b <- data.frame(count=c(sum(threshold==paste0("Balanced, <", thresh.val)), 
                            sum(threshold==paste0("Not Balanced, >", thresh.val))))
    rownames(b) <- c(paste0("Balanced, <", thresh.val), paste0("Not Balanced, >", thresh.val))
    return(b)
  }
  samplesize <- function(treat, weights = NULL, subclass = NULL, s.weights = NULL, method=c("matching", "weighting", "subclassification"), cluster = NULL, which.cluster = NULL, discarded = NULL, treat.names = c("Control", "Treated")) {
    #Computes sample size info. for unadjusted and adjusted samples.
    # method is what method the weights are to be used for. 
    # method="subclassification" is for subclass sample sizes only.
    
    if (is_not_null(cluster) && is_not_null(which.cluster)) in.cluster <- cluster == which.cluster
    else in.cluster <- rep(TRUE, length(treat))
    if (is.null(s.weights)) s.weights <- rep(1, length(treat))
    if (is.null(discarded)) discarded <- rep(0, length(treat))
    
    if (length(method) == 1 && method == "subclassification") {
      if (is.null(subclass)) stop("subclass must be a vector of subclasses.")
      qbins <- nlevels(subclass)
      
      nn <- as.data.frame(matrix(0, 3, qbins))
      
      dimnames(nn) <- list(c(treat.names[1], treat.names[2], "Total"), 
                           paste("Subclass", levels(subclass)))
      
      matched <- !is.na(subclass)
      k <- 0
      for (i in levels(subclass)) {
        qi <- subclass[matched]==i
        qt <- treat[matched][qi]
        if (sum(qt==1)<2|(sum(qt==0)<2)){
          if (sum(qt==1)<2)
            warning("Not enough treatment units in subclass ", i, call. = FALSE)
          else if (sum(qt==0)<2)
            warning("Not enough control units in subclass ", i, call. = FALSE)
        }
        k <- k + 1
        nn[, k] <- c(sum(qt==0), sum(qt==1), length(qt))
      }
      attr(nn, "tag") <- "Sample sizes by subclass"
    }
    else if (is.null(weights)) {
      
      t <- treat[in.cluster]
      sw <- s.weights[in.cluster]
      
      nn <- as.data.frame(matrix(0, ncol = 2, nrow = 1))
      nn[1, ] <- c((sum(sw[t==0])^2)/sum(sw[t==0]^2),
                   (sum(sw[t==1])^2)/sum(sw[t==1]^2))
      dimnames(nn) <- list(c("All"), 
                           c(treat.names[1], treat.names[2]))
      if (nunique.gt(s.weights, 2) || !any(s.weights==1) || !all(s.weights %in% c(0,1))) {
        attr(nn, "ss.type") <- c("ess")
        #attr(nn, "tag") <- "Effective sample sizes"
      }
      else {
        # nn <- as.data.frame(matrix(0, ncol=2, nrow=1))
        # nn[1, ] <- c(sum(in.cluster & treat==0), 
        #              sum(in.cluster & treat==1))
        # dimnames(nn) <- list(c("All"), 
        #                      c("Control", "Treated"))
        attr(nn, "ss.type") <- c("ss")
        #attr(nn, "tag") <- "Sample sizes"
      }
      
    }
    else if (ncol(weights) == 1) {
      if (method=="matching") {
        nn <- as.data.frame(matrix(0, ncol=2, nrow=5))
        # nn[1, ] <- c(sum(in.cluster & treat==0), sum(in.cluster & treat==1))
        # nn[2, ] <- c(sum(in.cluster & treat==0 & weights>0), sum(in.cluster & treat==1 & weights>0))
        # nn[3, ] <- c(sum(in.cluster & treat==0 & weights==0 & discarded==0), sum(in.cluster & treat==1 & weights==0 & discarded==0))
        # nn[4, ] <- c(sum(in.cluster & treat==0 & weights==0 & discarded==1), sum(in.cluster & treat==1 & weights==0 & discarded==1))
        nn[1, ] <- c(sum(in.cluster & treat==0), 
                     sum(in.cluster & treat==1))
        nn[2, ] <- c(sum(weights[in.cluster & treat==0, 1]), 
                     sum(weights[in.cluster & treat==1, 1]))
        nn[3, ] <- c(sum(in.cluster & treat==0 & weights[,1]>0), 
                     sum(in.cluster & treat==1 & weights[,1]>0))
        nn[4, ] <- c(sum(in.cluster & treat==0 & weights[,1]==0 & discarded==0), 
                     sum(in.cluster & treat==1 & weights[,1]==0 & discarded==0))
        nn[5, ] <- c(sum(in.cluster & treat==0 & weights[,1]==0 & discarded==1), 
                     sum(in.cluster & treat==1 & weights[,1]==0 & discarded==1))
        dimnames(nn) <- list(c("All", "Matched", "Matched (Unweighted)", "Unmatched", "Discarded"), 
                             c(treat.names[1], treat.names[2]))
        
        attr(nn, "ss.type") <- rep("ss", nrow(nn))
        #attr(nn, "tag") <- "Sample sizes"
      }
      else if (method == "weighting") {
        
        t <- treat[in.cluster]
        w <- weights[in.cluster, 1]
        sw <- s.weights[in.cluster]
        dc <- discarded[in.cluster]
        
        nn <- as.data.frame(matrix(0, ncol = 2, nrow = 3))
        nn[1, ] <- c((sum(sw[t==0])^2)/sum(sw[t==0]^2),
                     (sum(sw[t==1])^2)/sum(sw[t==1]^2))
        nn[2, ] <- c((sum(w[t==0]*sw[t==0])^2)/sum((w[t==0]*sw[t==0])^2),
                     (sum(w[t==1]*sw[t==1])^2)/sum((w[t==1]*sw[t==1])^2))
        nn[3, ] <- c(sum(t==0 & dc==1), 
                     sum(t==1 & dc==1))
        dimnames(nn) <- list(c("Unadjusted", "Adjusted", "Discarded"), 
                             c(treat.names[1], treat.names[2]))
        attr(nn, "ss.type") <- c("ss", "ess")
        
        #attr(nn, "tag") <- "Effective sample sizes"
        
      }
    }
    else {
      t <- treat[in.cluster]
      sw <- s.weights[in.cluster]
      
      nn <- as.data.frame(matrix(0, ncol=2, nrow=1+ncol(weights)))
      nn[1, ] <- c((sum(sw[t==0])^2)/sum(sw[t==0]^2), 
                   (sum(sw[t==1])^2)/sum(sw[t==1]^2))
      for (i in seq_len(ncol(weights))) {
        if (method[i] == "matching") {
          nn[1+i,] <- c(sum(weights[in.cluster & treat==0, i]), 
                        sum(weights[in.cluster & treat==1, i]))
        }
        else if (method[i] == "weighting") {
          w <- weights[in.cluster, i]
          nn[1+i,] <- c((sum(w[t==0]*sw[t==0])^2)/sum((w[t==0]*sw[t==0])^2),
                        (sum(w[t==1]*sw[t==1])^2)/sum((w[t==1]*sw[t==1])^2))
        }
        
      }
      dimnames(nn) <- list(c("All", names(weights)), 
                           c(treat.names[1], treat.names[2]))
      attr(nn, "ss.type") <- c("ss", ifelse(method == "weighting", "ess", "ss"))
      
    }
    if (length(attr(nn, "ss.type")) > 1 && all(attr(nn, "ss.type")[-1] == "ess")) {
      attr(nn, "tag") <- "Effective sample sizes"
    }
    else attr(nn, "tag") <- "Sample sizes"
    return(nn)
  }
  samplesize.across.clusters <- function(samplesize.list) {
    obs <- Reduce("+", samplesize.list)
    attr(obs, "tag") <- paste0("Total ", tolower(attr(samplesize.list[[1]], "tag")), " across clusters")
    return(obs)
  }
  max.imbal <- function(balance.table, col.name, thresh.col.name) {
    balance.table.clean <- balance.table[balance.table$Type != "Distance" & is.finite(balance.table[, col.name]),]
    maxed <- balance.table.clean[which.max(abs(balance.table.clean[, col.name])), match(c(col.name, thresh.col.name), names(balance.table.clean))]
    maxed <- data.frame(Variable = rownames(maxed), maxed)
    return(maxed)
    # return(balance.table[which.max(abs(balance.table[balance.table$Type != "Distance", col.name])), match(c(col.name, thresh.col.name), names(balance.table))])
  }
  balance.table <- function(C, weights, treat, continuous, binary, s.d.denom, m.threshold = NULL, v.threshold = NULL, ks.threshold = NULL, un = FALSE, disp.means = FALSE, disp.v.ratio = FALSE, disp.ks = FALSE, 
                            s.weights = rep(1, length(treat)), abs = FALSE, no.adj = FALSE, types = NULL, pooled.sds = NULL, quick = FALSE) {
    #C=frame of variables, including distance; distance name (if any) stores in attr(C, "distance.name")
    
    if (no.adj) weight.names <- "Adj"
    else weight.names <- names(weights)
    
    #B=Balance frame
    Bnames <- c("Type", 
                apply(expand.grid(c("M.0", "M.1", "Diff", "M.Threshold", "V.Ratio", "V.Threshold", "KS", "KS.Threshold"),
                                  c("Un", weight.names)), 1, paste, collapse = "."))
    B <- as.data.frame(matrix(nrow = ncol(C), ncol = length(Bnames)))
    colnames(B) <- Bnames
    rownames(B) <- varnames <- colnames(C)
    
    #Set var type (binary/continuous)
    if (is_not_null(types)) B[,"Type"] <- types
    else B[,"Type"] <- get.types(C)
    
    if (!((!un || !disp.means) && quick)) {
      B[,"M.0.Un"] <- col.w.m(C[treat == 0, , drop = FALSE], w = s.weights[treat==0])
      B[,"M.1.Un"] <- col.w.m(C[treat == 1, , drop = FALSE], w = s.weights[treat==1])
    }
    if (!no.adj && !(!disp.means && quick)) {
      for (i in weight.names) {
        B[[paste0("M.0.", i)]] <- col.w.m(C[treat == 0, , drop = FALSE], w = weights[[i]][treat==0]*s.weights[treat==0])
        B[[paste0("M.1.", i)]] <- col.w.m(C[treat == 1, , drop = FALSE], w = weights[[i]][treat==1]*s.weights[treat==1])
      }
    }
    
    #Mean differences
    if (abs) a0 <- base::abs
    else a0 <- base::identity
    
    if (!(!un && quick)) B[["Diff.Un"]] <- a0(col.std.diff(C, treat = treat, weights = NULL, x.types = B[["Type"]], continuous=continuous, binary=binary, s.d.denom=s.d.denom[1], no.weights = TRUE, s.weights = s.weights, pooled.sds = pooled.sds))
    if (!no.adj) {
      for (j in seq_len(ncol(weights))) {
        B[[paste0("Diff.", weight.names[j])]] <- a0(col.std.diff(C, treat = treat, weights = weights[[j]], x.types = B[["Type"]], continuous=continuous, binary=binary, s.d.denom=s.d.denom[j], no.weights = FALSE, s.weights = s.weights, pooled.sds = pooled.sds))
      }
    }
    
    #Variance ratios
    if (!(!disp.v.ratio && quick)) {
      if (!(!un && quick)) B[["V.Ratio.Un"]] <- col.var.ratio(C, treat, s.weights, B[["Type"]], no.weights = FALSE)
      if (!no.adj) {
        for (j in seq_len(ncol(weights))) {
          B[[paste0("V.Ratio.", weight.names[j])]] <- col.var.ratio(C, treat, weights[[j]]*s.weights, B[["Type"]], no.weights = FALSE)
        }
      }
    }
    if (!any(sapply(B[startsWith(names(B), "V.Ratio.")], is.finite))) {disp.v.ratio <- FALSE; v.threshold <- NULL}
    
    #KS Statistics
    if (!(!disp.ks && quick)) {
      if (!(!un && quick)) B[["KS.Un"]] <- col.ks(C, treat, s.weights, B[["Type"]], no.weights = FALSE)
      if (!no.adj) {
        for (j in seq_len(ncol(weights))) {
          B[[paste0("KS.", weight.names[j])]] <- col.ks(C, treat, weights[[j]]*s.weights, B[["Type"]], no.weights = FALSE)
        }
      }
    }
    if (!any(sapply(B[startsWith(names(B), "KS.")], is.finite))) {disp.ks <- FALSE; ks.threshold <- NULL}
    
    
    if (is_not_null(m.threshold)) {
      if (no.adj) {
        B[["M.Threshold.Un"]] <- ifelse(B[["Type"]]!="Distance" & is.finite(B[["Diff.Un"]]), paste0(ifelse(abs(B[["Diff.Un"]]) < m.threshold, "Balanced, <", "Not Balanced, >"), round(m.threshold, 3)), "")
      }
      else {
        for (i in weight.names) {
          B[[paste0("M.Threshold.", i)]] <- ifelse(B[["Type"]]!="Distance" & is.finite(B[[paste0("Diff.", i)]]), paste0(ifelse(abs(B[[paste0("Diff.", i)]]) < m.threshold, "Balanced, <", "Not Balanced, >"), round(m.threshold, 3)), "")
        }
      }
      
    }
    if (no.adj || ncol(weights) <= 1) names(B)[names(B) == "M.Threshold.Adj"] <- "M.Threshold"
    
    if (is_not_null(v.threshold)) {
      if (no.adj) {
        B[["V.Threshold.Un"]] <- ifelse(B[["Type"]]!="Distance" & is.finite(B[["V.Ratio.Un"]]), paste0(ifelse(B[["V.Ratio.Un"]] < v.threshold, "Balanced, <", "Not Balanced, >"), round(v.threshold, 3)), "")
      }
      else {
        for (i in weight.names) {
          B[[paste0("V.Threshold.", i)]] <- ifelse(B[["Type"]]!="Distance" & is.finite(B[[paste0("V.Ratio.", i)]]), paste0(ifelse(B[[paste0("V.Ratio.", i)]] < v.threshold, "Balanced, <", "Not Balanced, >"), round(v.threshold, 3)), "")
        }
      }
      
    }
    if (no.adj || ncol(weights) <= 1) names(B)[names(B) == "V.Threshold.Adj"] <- "V.Threshold"
    
    if (is_not_null(ks.threshold)) {
      if (no.adj) {
        B[["KS.Threshold.Un"]] <- ifelse(B[["Type"]]!="Distance" & is.finite(B[["KS.Un"]]), paste0(ifelse(B[["KS.Un"]] < ks.threshold, "Balanced, <", "Not Balanced, >"), round(ks.threshold, 3)), "")
      }
      else {
        for (i in weight.names) {
          B[[paste0("KS.Threshold.", i)]] <- ifelse(B[["Type"]]!="Distance" & is.finite(B[[paste0("KS.", i)]]), paste0(ifelse(B[[paste0("KS.", i)]] < ks.threshold, "Balanced, <", "Not Balanced, >"), round(ks.threshold, 3)), "")
        }
      }
      
    }
    if (no.adj || ncol(weights) <= 1) names(B)[names(B) == "KS.Threshold.Adj"] <- "KS.Threshold"
    
    attr(B, "disp") <- c(v = disp.v.ratio,
                         ks = disp.ks)
    
    
    return(B)
  }
  balance.table.subclass <- function(C, weights = NULL, treat, subclass, continuous, binary, s.d.denom, m.threshold = NULL, v.threshold = NULL, ks.threshold = NULL, disp.means = FALSE, disp.v.ratio = FALSE, disp.ks = FALSE, s.weights = rep(1, length(treat)), types = NULL, quick = FALSE) {
    #Creates list SB of balance tables for each subclass
    #C=frame of variables, including distance; distance name (if any) stores in attr(C, "distance.name")
    
    #B=Balance frame
    Bnames <- c("Type", "M.0.Adj", "M.1.Adj", "Diff.Adj", "M.Threshold", "V.Ratio.Adj", "V.Threshold", "KS.Adj", "KS.Threshold")
    B <- as.data.frame(matrix(nrow=ncol(C), ncol=length(Bnames)))
    colnames(B) <- Bnames
    rownames(B) <- varnames <- colnames(C)
    #Set var type (binary/continuous)
    if (is_not_null(types)) B[["Type"]] <- types
    else B[["Type"]] <- get.types(C)
    
    SB <- vector("list", nlevels(subclass))
    names(SB) <- levels(subclass)
    
    #-------------------------------------
    for (i in levels(subclass)) {
      
      SB[[i]] <- B
      in.subclass <- !is.na(subclass) & subclass==i
      
      if (!(!disp.means && quick)) {
        SB[[i]][["M.0.Adj"]] <- colMeans(C[treat==0 & in.subclass, , drop = FALSE])
        SB[[i]][["M.1.Adj"]] <- colMeans(C[treat==1 & in.subclass, , drop = FALSE])
      }
      
      #Mean differences
      #SB[[i]][["Diff.Adj"]] <- sapply(seq_along(rownames(SB[[i]])), function(x) diff.selector(x=C[,rownames(SB[[i]])[x]], treat=treat, weights=NULL, subclass=subclass, which.sub=i, x.type=B[["Type"]][x], continuous=continuous, binary=binary, s.d.denom=s.d.denom, no.weights = TRUE))
      SB[[i]][["Diff.Adj"]] <- col.std.diff(C, treat=treat, weights=NULL, subclass=subclass, which.sub=i, x.types=B[["Type"]], continuous=continuous, binary=binary, s.d.denom=s.d.denom, no.weights = TRUE)
      
      #Variance ratios
      if (!(!disp.v.ratio && quick)) {
        #SB[[i]][["V.Ratio.Adj"]] <- sapply(seq_along(rownames(SB[[i]])), function(x) var.ratio(C[,rownames(SB[[i]])[x]][in.subclass], treat[in.subclass], weights=NULL, var.type=B[["Type"]][x], no.weights = TRUE))
        SB[[i]][["V.Ratio.Adj"]] <- col.var.ratio(C[in.subclass, ], treat = treat[in.subclass], weights = NULL, x.types = B[["Type"]], no.weights = TRUE)
      }
      
      #KS Statistics
      if (!(!disp.ks && quick)) {
        #SB[[i]][["KS.Adj"]] <- sapply(seq_along(rownames(SB[[i]])), function(x) ks(C[,rownames(SB[[i]])[x]][in.subclass], treat[in.subclass], weights=NULL, var.type=B[["Type"]][x], no.weights = TRUE))
        SB[[i]][["KS.Adj"]] <- col.ks(C[in.subclass, ], treat = treat[in.subclass], weights = NULL, x.types = B[["Type"]], no.weights = TRUE)
      }
    }
    
    if (is_not_null(m.threshold)) {
      for (i in levels(subclass)) {
        SB[[i]][["M.Threshold"]] <- ifelse(SB[[i]][["Type"]]=="Distance", "", 
                                           paste0(ifelse(is.finite(SB[[i]][["Diff.Adj"]]) & abs(SB[[i]][["Diff.Adj"]]) < m.threshold, "Balanced, <", "Not Balanced, >"), round(m.threshold, 3)))
      }
    }
    
    if (all(sapply(SB, function(x) !any(is.finite(x[["V.Ratio.Adj"]]))))) {
      attr(SB, "dont.disp.v.ratio") <- TRUE; v.threshold <- NULL
    }
    if (is_not_null(v.threshold)) {
      for (i in levels(subclass)) {
        SB[[i]][["V.Threshold"]] <- ifelse(SB[[i]][["Type"]]!="Distance" & is.finite(SB[[i]][["V.Ratio.Adj"]]), 
                                           paste0(ifelse(SB[[i]][["V.Ratio.Adj"]] < v.threshold, "Balanced, <", "Not Balanced, >"), round(v.threshold, 3)), "")
      }
    }
    if (all(sapply(SB, function(x) !any(is.finite(x[["KS.Adj"]]))))) {
      attr(SB, "dont.disp.ks") <- TRUE
    }
    if (is_not_null(ks.threshold)) {
      for (i in levels(subclass)) {
        SB[[i]][["KS.Threshold"]] <- ifelse(SB[[i]][["Type"]]!="Distance" & is.finite(SB[[i]][["KS.Adj"]]), 
                                            paste0(ifelse(SB[[i]][["KS.Adj"]] < ks.threshold, "Balanced, <", "Not Balanced, >"), round(ks.threshold, 3)), "")
      }
    }
    
    attr(SB, "thresholds") <- c(m = m.threshold,
                                v = v.threshold,
                                ks = ks.threshold)
    
    return(SB)
  }
  balance.table.across.subclass <- function(balance.table, balance.table.subclass.list, subclass.obs, sub.by = NULL, m.threshold = NULL, v.threshold = NULL, ks.threshold = NULL, s.d.denom = NULL) {
    #Variance ratio, v.threshold, and KS not yet supported
    
    if (is_not_null(s.d.denom)){
      sub.by <- switch(s.d.denom, treated = "treat",
                       pooled = "all", control = "control")
    }
    if (sub.by=="treat") {
      wsub <- "Treated"
    } else if (sub.by=="control") {
      wsub <- "Control"
    } else if (sub.by=="all") {
      wsub <- "Total"
    }
    
    B.A <- balance.table.subclass.list[[1]][c("M.0.Adj", "M.1.Adj", "Diff.Adj")]
    
    for(i in rownames(B.A)) {
      for(j in colnames(B.A)) {
        B.A[[i, j]] <- sum(sapply(seq_along(balance.table.subclass.list),
                                  function(s) subclass.obs[[wsub, s]]/sum(subclass.obs[wsub, ]) * (balance.table.subclass.list[[s]][[i, j]])))
      }
    }
    B.A.df <- data.frame(balance.table[c("Type", "M.0.Un", "M.1.Un", "Diff.Un", "V.Ratio.Un", "KS.Un")], 
                         B.A, M.Threshold = NA)
    if (is_not_null(m.threshold)) B.A.df[["M.Threshold"]] <- ifelse(B.A.df[["Type"]]=="Distance", "", paste0(ifelse(is.finite(B.A.df[["Diff.Adj"]]) & abs(B.A.df[["Diff.Adj"]]) < m.threshold, "Balanced, <", "Not Balanced, >"), m.threshold))
    return(B.A.df)
  }
  balance.table.cluster.summary <- function(balance.table.clusters.list, weight.names = NULL, no.adj = FALSE, abs = FALSE, quick = FALSE, types = NULL) {
    
    cont.treat <- "Corr.Un" %in% unique(do.call("c", lapply(balance.table.clusters.list, names)))
    if (no.adj) weight.names <- "Adj"
    
    Brownames <- unique(do.call("c", lapply(balance.table.clusters.list, rownames)))
    #cluster.functions <- c("Min", "Mean", "Median", "Max")
    cluster.functions <- c("Min", "Mean", "Max")
    stats <- if (cont.treat) "Corr" else c("Diff", "V.Ratio", "KS")
    Bcolnames <- c("Type", apply(expand.grid(cluster.functions, stats, c("Un", weight.names)), 1, paste, collapse = "."))
    B <- as.data.frame(matrix(nrow = length(Brownames), ncol = length(Bcolnames)), row.names = Brownames)
    names(B) <- Bcolnames
    
    if (is_not_null(types)) B[["Type"]] <- types
    else B[["Type"]] <- unlist(sapply(Brownames, function(x) {u <- unique(sapply(balance.table.clusters.list, function(y) y[[x, "Type"]])); return(u[!is.na(u)])}), use.names = FALSE)
    
    abs0 <- function(x) {if (abs) abs(x) else (x)}
    funs <- structure(vector("list", length(cluster.functions)), names = cluster.functions)
    for (Fun in cluster.functions) {
      funs[[Fun]] <- function(x, ...) {
        if (!any(is.finite(x))) NA
        else get(tolower(Fun))(x, ...)
      }
      for (sample in c("Un", weight.names)) {
        if (sample == "Un" || !no.adj) { #Only fill in "stat".Adj if no.adj = FALSE
          if (cont.treat) {
            B[[paste(Fun, "Corr", sample, sep = ".")]] <- sapply(Brownames, function(x) funs[[Fun]](sapply(balance.table.clusters.list, function(y) abs0(y[[x, paste0("Corr.", sample)]])), na.rm = TRUE))
          }
          else {
            B[[paste(Fun, "Diff", sample, sep = ".")]] <- sapply(Brownames, function(x) funs[[Fun]](sapply(balance.table.clusters.list, function(y) abs0(y[[x, paste0("Diff.", sample)]])), na.rm = TRUE))
            B[[paste(Fun, "V.Ratio", sample, sep = ".")]] <- sapply(Brownames, function(x) if (B[[x, "Type"]]!="Contin.") NA else funs[[Fun]](sapply(balance.table.clusters.list, function(y) y[[x, paste0("V.Ratio.", sample)]]), na.rm = TRUE))
            B[[paste(Fun, "KS", sample, sep = ".")]] <- sapply(Brownames, function(x) if (B[[x, "Type"]]!="Contin.") NA else funs[[Fun]](sapply(balance.table.clusters.list, function(y) y[[x, paste0("KS.", sample)]]), na.rm = TRUE))
          }            
        }
      }
    }
    
    return(B)
  }
  
  #base.bal.tab.cont
  w.r <- function(x, y, w = NULL) {
    if (length(x) != length(y)) stop("x and y must the same length")
    if (is.null(w)) w <- rep(1, length(x))
    else if (length(w) != length(x)) stop("weights must be same length as x and y")
    
    r <- w.cov(x, y, w) / (sqrt(w.cov(x, x, w) * w.cov(y, y, w)))
    return(r)
  }
  samplesize.cont <- function(treat, weights = NULL, subclass = NULL, s.weights = NULL, method=c("matching", "weighting", "subclassification"), cluster = NULL, which.cluster = NULL, discarded = NULL) {
    #Computes sample size info. for unadjusted and adjusted samples.
    # method is what method the weights are to be used for. 
    # method="subclassification" is for subclass sample sizes only.
    #method <- match.arg(method)
    if (nlevels(cluster) > 0 && is_not_null(which.cluster)) in.cluster <- cluster == which.cluster
    else in.cluster <- rep(TRUE, length(treat))
    if (is.null(discarded)) discarded <- rep(0, length(treat))
    
    if (length(method) == 1 && method == "subclassification") {
      #stop("Subclassification is not yet surpported with continuous treatments.", call. = FALSE)
      if (is.null(subclass)) stop("subclass must be a vector of subclasses.")
      qbins <- nlevels(subclass)
      
      nn <- as.data.frame(matrix(0, nrow = 1, ncol = qbins))
      
      dimnames(nn) <- list(c("Total"), 
                           paste("Subclass", levels(subclass)))
      
      matched <- !is.na(subclass)
      k <- 0
      for (i in levels(subclass)) {
        qi <- subclass[matched]==i
        qt <- treat[matched][qi]
        if (length(qt)<2){
          if (sum(qt==1)<2)
            warning("Not enough units in subclass ", i, call. = FALSE)
        }
        k <- k + 1
        nn[, k] <- c(length(qt))
      }
      attr(nn, "tag") <- "Sample sizes by subclass"
    }
    else if (is.null(weights)) {
      nn <- as.data.frame(matrix(0, ncol = 1, nrow = 1))
      if (nunique.gt(s.weights, 2) || !any(s.weights==1) || !all(s.weights %in% c(0,1))) {
        sw <- s.weights[in.cluster]
        
        nn[1, ] <- (sum(sw)^2)/sum(sw^2)
      }
      else {
        nn[1, ] <- sum(in.cluster)
        
      }
      dimnames(nn) <- list(c("All"), 
                           c("Total"))
      attr(nn, "ss.type") <- c("ss", ifelse(method == "weighting", "ess", "ss"))
    }
    else if (length(weights) == 1) {
      if (method=="matching") {
        
        nn <- as.data.frame(matrix(0, ncol = 1, nrow = 3))
        nn[1, ] <- c(length(treat[in.cluster]))
        nn[2, ] <- c(sum(in.cluster & weights[,1] > 0))
        nn[3, ] <- c(sum(in.cluster & weights[,1] == 0))
        dimnames(nn) <- list(c("All", "Matched", "Unmatched"), 
                             c("Total"))
        attr(nn, "ss.type") <- c("ss", ifelse(method == "weighting", "ess", "ss"))
        
        #attr(nn, "tag") <- "Sample sizes"
      }
      else if (method == "weighting") {
        w <- weights[in.cluster, 1]
        sw <- s.weights[in.cluster]
        
        nn <- as.data.frame(matrix(0, ncol = 1, nrow = 2))
        nn[1, ] <- (sum(sw)^2)/sum(sw^2)
        nn[2, ] <- (sum(w*sw)^2)/sum((w*sw)^2)
        dimnames(nn) <- list(c("Unadjusted", "Adjusted"), 
                             c("Total"))
        attr(nn, "ss.type") <- c("ss", ifelse(method == "weighting", "ess", "ss"))
        #attr(nn, "tag") <- "Effective sample sizes"
      }
    }
    else {
      #t <- treat[in.cluster]
      sw <- s.weights[in.cluster]
      nn <- as.data.frame(matrix(0, ncol=1, nrow=1+ncol(weights)))
      nn[1, ] <- (sum(sw)^2)/sum(sw^2)
      for (i in seq_len(ncol(weights))) {
        if (method[i] == "matching") {
          nn[1+i,] <- c(sum(in.cluster & weights[,i] > 0))
        }
        else if (method[i] == "weighting") {
          w <- weights[in.cluster, i]
          nn[1+i,] <- (sum(w*sw)^2)/sum((w*sw)^2)
        }
        
      }
      dimnames(nn) <- list(c("Unadjusted", names(weights)), 
                           c("Total"))
      attr(nn, "ss.type") <- c("ss", ifelse(method == "weighting", "ess", "ss"))
      # if (all(obs$ss.type == "ess")) attr(obs, "tag") <- "Effective sample sizes"
      # else attr(obs, "tag") <- "Sample sizes"
      
    }
    if (length(attr(nn, "ss.type")) > 1 && all(attr(nn, "ss.type")[-1] == "ess")) {
      attr(nn, "tag") <- "Effective sample sizes"
    }
    else attr(nn, "tag") <- "Sample sizes"
    
    return(nn)
  }
  balance.table.cont <- function(C, weights, treat, r.threshold = NULL, un = FALSE, s.weights = rep(1, length(treat)), abs = FALSE, no.adj = FALSE, types = NULL, quick = FALSE) {
    #C=frame of variables, including distance; distance name (if any) stores in attr(C, "distance.name")
    
    if (no.adj) weight.names <- "Adj"
    else weight.names <- names(weights)
    
    #B=Balance frame
    Bnames <- c("Type", 
                "Corr.Un", 
                apply(expand.grid(c("Corr", "R.Threshold"),
                                  weight.names), 1, paste, collapse = "."))
    B <- as.data.frame(matrix(nrow=ncol(C), ncol=length(Bnames)))
    colnames(B) <- Bnames
    rownames(B) <- varnames <- colnames(C)
    
    #Set var type (binary/continuous)
    if (is_not_null(types)) B[["Type"]] <- types
    else B[["Type"]] <- get.types(C)
    
    #Correlations
    if (abs) a0 <- base::abs
    else a0 <- base::identity
    if (!(!un && quick)) B[["Corr.Un"]] <- a0(apply(C, 2, w.r, y = treat, w = s.weights))
    if (!no.adj) {
      for (i in weight.names) {
        B[[paste0("Corr.", i)]] <- a0(apply(C, 2, w.r, y = treat, w = weights[[i]]*s.weights))
      }
    }
    
    if (is_not_null(r.threshold)) {
      if (no.adj) {
        #Call Adj, but really Un. Needs to be this way.
        B[["R.Threshold.Adj"]] <- ifelse(B[["Type"]]=="Distance" | !is.finite(B[["Corr.Un"]]), "", paste0(ifelse(abs(B[["Corr.Un"]]) < r.threshold, "Balanced, <", "Not Balanced, >"), r.threshold))
      }
      else {
        for (i in weight.names) {
          B[[paste0("R.Threshold.", i)]] <- ifelse(B[["Type"]]=="Distance" | !is.finite(B[[paste0("Corr.", i)]]), "", paste0(ifelse(abs(B[[paste0("Corr.", i)]]) < r.threshold, "Balanced, <", "Not Balanced, >"), r.threshold))
        }
      }
      
    }
    
    if (no.adj || ncol(weights) <= 1) names(B)[grepl("R.Threshold", names(B), fixed = TRUE)] <- "R.Threshold"
    
    attr(B, "thresholds") <- c(r = r.threshold)
    return(B)
  }
  balance.table.subclass.cont <- function(C, weights = NULL, treat, subclass, r.threshold = NULL, s.weights = rep(1, length(treat)), types = NULL, quick = FALSE) {
    #Creates list SB of balance tables for each subclass
    #C=frame of variables, including distance; distance name (if any) stores in attr(C, "distance.name")
    
    #B=Balance frame
    Bnames <- c("Type", "Corr.Adj", "R.Threshold")
    B <- as.data.frame(matrix(nrow=ncol(C), ncol=length(Bnames)))
    colnames(B) <- Bnames
    rownames(B) <- varnames <- colnames(C)
    #Set var type (binary/continuous)
    if (is_not_null(types)) B[["Type"]] <- types
    else B[["Type"]] <- get.types(C)
    
    SB <- vector("list", nlevels(subclass))
    names(SB) <- levels(subclass)
    
    #-------------------------------------
    for (i in levels(subclass)) {
      
      SB[[i]] <- B
      in.subclass <- !is.na(subclass) & subclass==i
      
      #Correlations
      SB[[i]][["Corr.Adj"]] <- apply(C, 2, function(x) w.r(x[in.subclass], y = treat[in.subclass]))
      
    }
    
    if (is_not_null(r.threshold)) {
      for (i in levels(subclass)) {
        SB[[i]][["R.Threshold"]] <- ifelse(SB[[i]][["Type"]]=="Distance", "", 
                                           paste0(ifelse(is.finite(SB[[i]][["Corr.Adj"]]) & abs(SB[[i]][["Corr.Adj"]]) < r.threshold, "Balanced, <", "Not Balanced, >"), r.threshold))
      }
    }
    
    attr(SB, "thresholds") <- c(r = r.threshold)
    
    return(SB)
  }
  balance.table.across.subclass.cont <- function(balance.table, balance.table.subclass.list, subclass.obs, sub.by = NULL, r.threshold = NULL) {
    #Not specified
  }
  
  #base.bal.tab.imp
  balance.table.imp.summary <- function(bal.tab.imp.list, weight.names = NULL, no.adj = FALSE, abs = FALSE, quick = FALSE, types = NULL) {
    if ("bal.tab" %in% unique(do.call("c", lapply(bal.tab.imp.list, class)))) {
      bal.tab.imp.list <- lapply(bal.tab.imp.list, function(x) x[["Balance"]])}
    cont.treat <- "Corr.Un" %in% unique(do.call("c", lapply(bal.tab.imp.list, names)))
    if (length(weight.names) <= 1) weight.names <- "Adj"
    
    Brownames <- unique(do.call("c", lapply(bal.tab.imp.list, rownames)))
    #imp.functions <- c("Min", "Mean", "Median", "Max")
    imp.functions <- c("Min", "Mean", "Max")
    stats <- if (cont.treat) "Corr" else c("Diff", "V.Ratio", "KS")
    Bcolnames <- c("Type", apply(expand.grid(imp.functions, stats, c("Un", weight.names)), 1, paste, collapse = "."))
    B <- as.data.frame(matrix(nrow = length(Brownames), ncol = length(Bcolnames)), row.names = Brownames)
    names(B) <- Bcolnames
    
    if (is_not_null(types)) B[["Type"]] <- types
    else B[["Type"]] <- unlist(sapply(Brownames, function(x) {u <- unique(sapply(bal.tab.imp.list, function(y) y[[x, "Type"]])); return(u[!is.na(u)])}), use.names = FALSE)
    
    abs0 <- function(x) {if (abs) abs(x) else (x)}
    funs <- structure(vector("list", length(imp.functions)), names = imp.functions)
    for (Fun in imp.functions) {
      funs[[Fun]] <- function(x, ...) {
        if (!any(is.finite(x))) NA
        else get(tolower(Fun))(x, ...)
      }
      for (sample in c("Un", weight.names)) {
        if (sample == "Un" || !no.adj) { #Only fill in "stat".Adj if no.adj = FALSE
          if (cont.treat) {
            B[[paste(Fun, "Corr", sample, sep = ".")]] <- sapply(Brownames, function(x) funs[[Fun]](sapply(bal.tab.imp.list, function(y) abs0(y[x, paste0("Corr.", sample)])), na.rm = TRUE))
          }
          else {
            B[[paste(Fun, "Diff", sample, sep = ".")]] <- sapply(Brownames, function(x) funs[[Fun]](sapply(bal.tab.imp.list, function(y) abs0(y[[x, paste0("Diff.", sample)]])), na.rm = TRUE))
            B[[paste(Fun, "V.Ratio", sample, sep = ".")]] <- sapply(Brownames, function(x) if (B[[x, "Type"]]!="Contin.") NA else funs[[Fun]](sapply(bal.tab.imp.list, function(y) y[[x, paste0("V.Ratio.", sample)]]), na.rm = TRUE))
            B[[paste(Fun, "KS", sample, sep = ".")]] <- sapply(Brownames, function(x) if (B[[x, "Type"]]!="Contin.") NA else funs[[Fun]](sapply(bal.tab.imp.list, function(y) y[[x, paste0("KS.", sample)]]), na.rm = TRUE))
          }
        }
      }
    }
    return(B)
  }
  balance.table.clust.imp.summary <- function(summary.tables, weight.names = NULL, no.adj = FALSE, abs = FALSE, quick = FALSE, types = NULL) {
    #cont.treat <- !is.na(match("bal.tab.cont", unique(do.call("c", lapply(bal.tab.imp.list, class)))))
    #clusters <- unique(do.call("c", lapply(bal.tab.imp.list, function(x) names(x[["Cluster.Balance"]]))))
    #cluster.tables <- lapply(clusters, function(x) lapply(bal.tab.imp.list, function(y) y[["Cluster.Balance"]][[x]]))
    #cluster.balance.across.imps <- lapply(cluster.tables, balance.table.imp.summary, no.adj, quick, types)
    #names(cluster.balance.across.imps) <- clusters
    
    if (!all(sapply(summary.tables, is.null))) {
      Brownames <- unique(do.call("c", lapply(summary.tables, rownames)))
      Bcolnames <- unique(do.call("c", lapply(summary.tables, colnames)))
      cont.treat <- !is.na(charmatch("Mean.Corr.Un", Bcolnames))
      if (length(weight.names) <= 1) weight.names <- "Adj"
      #imp.functions <- c("Min", "Mean", "Median", "Max")
      imp.functions <- c("Min", "Mean", "Max")
      stats <- if (cont.treat) "Corr" else c("Diff", "V.Ratio", "KS")
      
      B <- as.data.frame(matrix(nrow = length(Brownames), ncol = length(Bcolnames)))
      dimnames(B) <- list(Brownames, Bcolnames)
      
      if (is_not_null(types)) B[["Type"]] <- types
      else B[["Type"]] <- unlist(sapply(Brownames, function(x) {u <- unique(sapply(summary.tables, function(y) y[[x, "Type"]])); return(u[!is.na(u)])}), use.names = FALSE)
      
      abs0 <- function(x) {if (abs) abs(x) else (x)}
      funs <- structure(vector("list", length(imp.functions)), names = imp.functions)
      for (Fun in imp.functions) {
        funs[[Fun]] <- function(x, ...) {
          if (!any(is.finite(x))) NA
          else get(tolower(Fun))(x, ...)
        }
        for (sample in c("Un", weight.names)) {
          if (sample == "Un" || !no.adj) { #Only fill in "stat".Adj if no.adj = FALSE
            if (cont.treat) {
              B[[paste(Fun, "Corr", sample, sep = ".")]] <- sapply(Brownames, function(x) funs[[Fun]](sapply(summary.tables, function(y) abs0(y[[x, paste(Fun, "Corr", sample, sep = ".")]])), na.rm = TRUE))
            }
            else {
              B[[paste(Fun, "Diff", sample, sep = ".")]] <- sapply(Brownames, function(x) funs[[Fun]](sapply(summary.tables, function(y) abs0(y[[x, paste(Fun, "Diff", sample, sep = ".")]])), na.rm = TRUE))
              B[[paste(Fun, "V.Ratio", sample, sep = ".")]] <- sapply(Brownames, function(x) if (B[[x, "Type"]]!="Contin.") NA else funs[[Fun]](sapply(summary.tables, function(y) y[[x, paste(Fun, "V.Ratio", sample, sep = ".")]]), na.rm = TRUE))
              B[[paste(Fun, "KS", sample, sep = ".")]] <- sapply(Brownames, function(x) if (B[[x, "Type"]]!="Contin.") NA else funs[[Fun]](sapply(summary.tables, function(y) y[[x, paste(Fun, "KS", sample, sep = ".")]]), na.rm = TRUE))
            }
          }
        }
      }
    }
    else B <- NULL
    
    return(B)
  }
  samplesize.across.imps <- function(obs.list) {
    #obs.list <- lapply(bal.tab.imp.list, function(x) x[["Observations"]])
    
    obs <- Reduce("+", obs.list)/length(obs.list)
    attr(obs, "tag") <- paste0("Average ", tolower(attr(obs.list[[1]], "tag")), " across imputations")
    return(obs)
  }
  
  #base.bal.tab.multi
  balance.table.multi.summary <- function(bal.tab.multi.list, weight.names = NULL, no.adj = FALSE, m.threshold = NULL, v.threshold = NULL, ks.threshold = NULL, quick = FALSE, types = NULL) {
    if ("bal.tab" %in% unique(do.call("c", lapply(bal.tab.multi.list, class)))) {
      bal.tab.multi.list <- lapply(bal.tab.multi.list, function(x) x[["Balance"]])}
    if (length(weight.names) <= 1) weight.names <- "Adj"
    
    Brownames <- unique(do.call("c", lapply(bal.tab.multi.list, rownames)))
    stats <- c("Diff", "V.Ratio", "KS")
    Bcolnames <- c("Type", expand.grid_string(c("Max.Diff", "M.Threshold", "Max.V.Ratio", "V.Threshold", "Max.KS", "KS.Threshold"), 
                                              c("Un", weight.names), collapse = "."))
    B <- as.data.frame(matrix(nrow = length(Brownames), ncol = length(Bcolnames)), row.names = Brownames)
    names(B) <- Bcolnames
    
    if (is_not_null(types)) B[["Type"]] <- types
    else B[["Type"]] <- unlist(sapply(Brownames, function(x) {u <- unique(sapply(bal.tab.multi.list, function(y) y[[x, "Type"]])); return(u[!is.na(u)])}), use.names = FALSE)
    
    max_ <- function(x, na.rm = TRUE) {
      if (!any(is.finite(x))) NA
      else max(x, na.rm = na.rm)
    }
    for (sample in c("Un", weight.names)) {
      if (sample == "Un" || !no.adj) { #Only fill in "stat".Adj if no.adj = FALSE
        B[[paste("Max", "Diff", sample, sep = ".")]] <- sapply(Brownames, function(x) max_(sapply(bal.tab.multi.list, function(y) abs(y[[x, paste0("Diff.", sample)]])), na.rm = TRUE))
        B[[paste("Max", "V.Ratio", sample, sep = ".")]] <- sapply(Brownames, function(x) if (B[[x, "Type"]]!="Contin.") NA else max_(sapply(bal.tab.multi.list, function(y) y[[x, paste0("V.Ratio.", sample)]]), na.rm = TRUE))
        B[[paste("Max", "KS", sample, sep = ".")]] <- sapply(Brownames, function(x) if (B[[x, "Type"]]!="Contin.") NA else max_(sapply(bal.tab.multi.list, function(y) y[[x, paste0("KS.", sample)]]), na.rm = TRUE))
      }
    }
    
    if (is_not_null(m.threshold)) {
      if (no.adj) {
        B[["M.Threshold.Un"]] <- ifelse(B[["Type"]]!="Distance" & is.finite(B[["Max.Diff.Un"]]), paste0(ifelse(abs(B[["Max.Diff.Un"]]) < m.threshold, "Balanced, <", "Not Balanced, >"), m.threshold), "")
      }
      else {
        for (i in weight.names) {
          B[[paste0("M.Threshold.", i)]] <- ifelse(B[["Type"]]!="Distance" & is.finite(B[[paste0("Max.Diff.", i)]]), paste0(ifelse(abs(B[[paste0("Max.Diff.", i)]]) < m.threshold, "Balanced, <", "Not Balanced, >"), m.threshold), "")
        }
      }
    }
    if (no.adj || length(weight.names) <= 1) names(B)[names(B) == "M.Threshold.Adj"] <- "M.Threshold"
    
    if (is_not_null(v.threshold)) {
      if (no.adj) {
        B[["V.Threshold.Un"]] <- ifelse(B[["Type"]]!="Distance" & is.finite(B[["Max.V.Ratio.Un"]]), paste0(ifelse(B[, "Max.V.Ratio.Un"] < v.threshold, "Balanced, <", "Not Balanced, >"), v.threshold), "")
      }
      else {
        for (i in weight.names) {
          B[[paste0("V.Threshold.", i)]] <- ifelse(B[["Type"]]!="Distance" & is.finite(B[[paste0("Max.V.Ratio.", i)]]), paste0(ifelse(B[[paste0("Max.V.Ratio.", i)]] < v.threshold, "Balanced, <", "Not Balanced, >"), v.threshold), "")
        }
      }
    }
    if (no.adj || length(weight.names) <= 1) names(B)[names(B) == "V.Threshold.Adj"] <- "V.Threshold"
    
    if (is_not_null(ks.threshold)) {
      if (no.adj) {
        B[["KS.Threshold.Un"]] <- ifelse(B[["Type"]]!="Distance" & is.finite(B[["Max.KS.Un"]]), paste0(ifelse(B[["Max.KS.Un"]] < ks.threshold, "Balanced, <", "Not Balanced, >"), ks.threshold), "")
      }
      else {
        for (i in weight.names) {
          B[[paste0("KS.Threshold.", i)]] <- ifelse(B[["Type"]]!="Distance" & is.finite(B[[paste0("Max.KS.", i)]]), paste0(ifelse(B[[paste0("Max.KS.", i)]] < ks.threshold, "Balanced, <", "Not Balanced, >"), ks.threshold), "")
        }
      }
    }
    if (no.adj || length(weight.names) <= 1) names(B)[names(B) == "KS.Threshold.Adj"] <- "KS.Threshold"
    
    return(B)
  }
  samplesize.multi <- function(bal.tab.multi.list, treat.names, focal) {
    if (is_not_null(focal)) which <- c(treat.names[treat.names != focal], focal)
    else which <- treat.names
    obs <- do.call("cbind", unname(lapply(bal.tab.multi.list, function(x) x[["Observations"]])))[, which]
    attr(obs, "tag") <- attr(bal.tab.multi.list[[1]][["Observations"]], "tag")
    attr(obs, "ss.type") <- attr(bal.tab.multi.list[[1]][["Observations"]], "ss.type")
    return(obs)
  }
  
  #base.bal.tab.msm
  balance.table.msm.summary <- function(bal.tab.msm.list, weight.names = NULL, no.adj = FALSE, m.threshold = NULL, v.threshold = NULL, ks.threshold = NULL, r.threshold = NULL, quick = FALSE, types = NULL) {
    if ("bal.tab" %in% unique(do.call("c", lapply(bal.tab.msm.list, class)))) {
      bal.tab.msm.list <- lapply(bal.tab.msm.list, function(x) x[["Balance"]])}
    cont.treat <- "Corr.Un" %in% unique(do.call("c", lapply(bal.tab.msm.list, names)))
    if (length(weight.names) <= 1) weight.names <- "Adj"
    
    Brownames <- unique(do.call("c", lapply(bal.tab.msm.list, rownames)))
    Brownames.appear <- sapply(Brownames, function(x) paste(seq_along(bal.tab.msm.list)[sapply(bal.tab.msm.list, function(y) x %in% rownames(y))], collapse = ", "))
    if (cont.treat) {
      Bcolnames <- c("Type", expand.grid_string(c("Max.Corr", "R.Threshold"), 
                                                c("Un", weight.names), collapse = "."))
    }
    else {
      Bcolnames <- c("Type", expand.grid_string(c("Max.Diff", "M.Threshold", "Max.V.Ratio", "V.Threshold", "Max.KS", "KS.Threshold"), 
                                                c("Un", weight.names), collapse = "."))
    }
    
    B <- as.data.frame(matrix(NA, nrow = length(Brownames), ncol = 1 + length(Bcolnames)), row.names = Brownames)
    names(B) <- c("Times", Bcolnames)
    
    if (is_not_null(types)) B[["Type"]] <- types
    else B[["Type"]] <- unlist(sapply(Brownames, function(x) {u <- unique(sapply(bal.tab.msm.list, function(y) if (x %in% rownames(y)) y[[x, "Type"]] else NA)); return(u[!is.na(u)])}), use.names = FALSE)
    
    B[["Times"]] <- Brownames.appear[Brownames]
    
    max_ <- function(x, na.rm = TRUE) {
      if (!any(is.finite(x))) NA
      else max(x, na.rm = na.rm)
    }
    for (sample in c("Un", weight.names)) {
      if (sample == "Un" || !no.adj) { #Only fill in "stat".Adj if no.adj = FALSE
        if (cont.treat) {
          B[[paste("Max", "Corr", sample, sep = ".")]] <- sapply(Brownames, function(x) max_(sapply(bal.tab.msm.list, function(y) if (x %in% rownames(y)) abs(y[[x, paste0("Corr.", sample)]]) else NA), na.rm = TRUE))
        }
        else {
          B[[paste("Max", "Diff", sample, sep = ".")]] <- sapply(Brownames, function(x) max_(sapply(bal.tab.msm.list, function(y) if (x %in% rownames(y)) abs(y[[x, paste0("Diff.", sample)]]) else NA), na.rm = TRUE))
          B[[paste("Max", "V.Ratio", sample, sep = ".")]] <- sapply(Brownames, function(x) if (B[[x, "Type"]]!="Contin.") NA else max_(sapply(bal.tab.msm.list, function(y) if (x %in% rownames(y)) y[[x, paste0("V.Ratio.", sample)]] else NA), na.rm = TRUE))
          B[[paste("Max", "KS", sample, sep = ".")]] <- sapply(Brownames, function(x) if (B[[x, "Type"]]!="Contin.") NA else max_(sapply(bal.tab.msm.list, function(y) if (x %in% rownames(y)) y[[x, paste0("KS.", sample)]] else NA), na.rm = TRUE))
        }
      }
    }
    
    if (is_not_null(m.threshold)) {
      if (no.adj) {
        B[["M.Threshold.Un"]] <- ifelse(B[["Type"]]!="Distance" & is.finite(B[["Max.Diff.Un"]]), paste0(ifelse(abs(B[["Max.Diff.Un"]]) < m.threshold, "Balanced, <", "Not Balanced, >"), m.threshold), "")
      }
      else {
        for (i in weight.names) {
          B[[paste0("M.Threshold.", i)]] <- ifelse(B[["Type"]]!="Distance" & is.finite(B[[paste0("Max.Diff.", i)]]), paste0(ifelse(abs(B[[paste0("Max.Diff.", i)]]) < m.threshold, "Balanced, <", "Not Balanced, >"), m.threshold), "")
        }
      }
    }
    if (no.adj || length(weight.names) <= 1) names(B)[names(B) == "M.Threshold.Adj"] <- "M.Threshold"
    
    if (is_not_null(v.threshold)) {
      if (no.adj) {
        B[["V.Threshold.Un"]] <- ifelse(B[["Type"]]!="Distance" & is.finite(B[["Max.V.Ratio.Un"]]), paste0(ifelse(B[, "Max.V.Ratio.Un"] < v.threshold, "Balanced, <", "Not Balanced, >"), v.threshold), "")
      }
      else {
        for (i in weight.names) {
          B[[paste0("V.Threshold.", i)]] <- ifelse(B[["Type"]]!="Distance" & is.finite(B[[paste0("Max.V.Ratio.", i)]]), paste0(ifelse(B[[paste0("Max.V.Ratio.", i)]] < v.threshold, "Balanced, <", "Not Balanced, >"), v.threshold), "")
        }
      }
    }
    if (no.adj || length(weight.names) <= 1) names(B)[names(B) == "V.Threshold.Adj"] <- "V.Threshold"
    
    if (is_not_null(ks.threshold)) {
      if (no.adj) {
        B[["KS.Threshold.Un"]] <- ifelse(B[["Type"]]!="Distance" & is.finite(B[["Max.KS.Un"]]), paste0(ifelse(B[["Max.KS.Un"]] < ks.threshold, "Balanced, <", "Not Balanced, >"), ks.threshold), "")
      }
      else {
        for (i in weight.names) {
          B[[paste0("KS.Threshold.", i)]] <- ifelse(B[["Type"]]!="Distance" & is.finite(B[[paste0("Max.KS.", i)]]), paste0(ifelse(B[[paste0("Max.KS.", i)]] < ks.threshold, "Balanced, <", "Not Balanced, >"), ks.threshold), "")
        }
      }
    }
    if (no.adj || length(weight.names) <= 1) names(B)[names(B) == "KS.Threshold.Adj"] <- "KS.Threshold"
    
    if (is_not_null(r.threshold)) {
      if (no.adj) {
        B[["R.Threshold.Un"]] <- ifelse(B[["Type"]]!="Distance" & is.finite(B[["Max.Corr.Un"]]), paste0(ifelse(B[["Max.Corr.Un"]] < r.threshold, "Balanced, <", "Not Balanced, >"), r.threshold), "")
      }
      else {
        for (i in weight.names) {
          B[[paste0("R.Threshold.", i)]] <- ifelse(B[["Type"]]!="Distance" & is.finite(B[[paste0("Max.Corr.", i)]]), paste0(ifelse(B[[paste0("Max.KCorr.", i)]] < r.threshold, "Balanced, <", "Not Balanced, >"), r.threshold), "")
        }
      }
    }
    if (no.adj || length(weight.names) <= 1) names(B)[names(B) == "R.Threshold.Adj"] <- "R.Threshold"
    
    
    return(B)
  }
  samplesize.msm <- function(bal.tab.msm.list) {
    obs <- do.call("cbind", lapply(bal.tab.msm.list, function(x) x[["Observations"]]))
    attr(obs, "tag") <- attr(bal.tab.msm.list[[1]][["Observations"]], "tag")
    attr(obs, "ss.type") <- attr(bal.tab.msm.list[[1]][["Observations"]], "ss.type")
    return(obs)
  }
  
  #love.plot
  isColor <- function(x) {
    tryCatch(is.matrix(col2rgb(x)), 
             error = function(e) FALSE)
  }
  f.recode <- function(f, ...) {
    #Simplified version of forcats::fct_recode
    f <- factor(f)
    new_levels <- unlist(list(...), use.names = TRUE)
    old_levels <- levels(f)
    idx <- match(new_levels, old_levels)
    
    old_levels[idx] <- names(new_levels)
    
    levels(f) <- old_levels
    return(f)
  }
  seq_int_cycle <- function(begin, end, max) {
    seq(begin, end, by = 1) - max*(seq(begin-1, end-1, by = 1) %/% max)
  }
  assign.shapes <- function(colors, default.shape = 21) {
    if (nunique(colors) < length(colors)) {
      shapes <- seq_int_cycle(21, 21 + length(colors), max = 25)
    }
    else shapes <- rep(default.shape, length(colors))
    return(shapes)
  }
  shapes.ok <- function(shapes, nshapes) {
    return((length(shapes) == 1 || length(shapes) == nshapes) && is.numeric(shapes) && all(shapes %in% 1:25))
  }
  gg_color_hue <- function(n) {
    hues = seq(15, 375, length = n + 1)
    hcl(h = hues, l = 65, c = 100)[1:n]
  }
  
  #bal.plot
  get.var.from.list.with.time <- function(var.name, covs.list) {
    var.name.in.covs <- sapply(covs.list, function(x) var.name %in% names(x))
    n.times.appeared <- sum(var.name.in.covs)
    var <- unlist(lapply(covs.list[var.name.in.covs], function(x) x[[var.name]]))
    times <- rep(var.name.in.covs, each = ncol(covs.list[[1]]))
    return(list(var = var, times = times))
  }
  
  #print.bal.tab
  round_df_char <- function(df, digits, pad = "0", na_vals = "") {
    nas <- is.na(df)
    if (!is.data.frame(df)) df <- as.data.frame.matrix(df, stringsAsFactors = FALSE)
    rn <- rownames(df)
    cn <- colnames(df)
    df <- as.data.frame(lapply(df, function(col) {
      if (suppressWarnings(all(!is.na(as.numeric(as.character(col)))))) {
        as.numeric(as.character(col))
      } else {
        col
      }
    }), stringsAsFactors = FALSE)
    nums <- vapply(df, is.numeric, FUN.VALUE = logical(1))
    o.negs <- sapply(1:ncol(df), function(x) if (nums[x]) df[[x]] < 0 else rep(FALSE, length(df[[x]])))
    df[nums] <- round(df[nums], digits = digits)
    df[nas] <- ""
    
    df <- as.data.frame(lapply(df, format, scientific = FALSE, justify = "none"), stringsAsFactors = FALSE)
    
    for (i in which(nums)) {
      if (any(grepl(".", df[[i]], fixed = TRUE))) {
        s <- strsplit(df[[i]], ".", fixed = TRUE)
        lengths <- lengths(s)
        digits.r.of.. <- sapply(seq_along(s), function(x) {
          if (lengths[x] > 1) nchar(s[[x]][lengths[x]])
          else 0 })
        df[[i]] <- sapply(seq_along(df[[i]]), function(x) {
          if (df[[i]][x] == "") ""
          else if (lengths[x] <= 1) {
            paste0(c(df[[i]][x], rep(".", pad == 0), rep(pad, max(digits.r.of..) - digits.r.of..[x] + as.numeric(pad != 0))),
                   collapse = "")
          }
          else paste0(c(df[[i]][x], rep(pad, max(digits.r.of..) - digits.r.of..[x])),
                      collapse = "")
        })
      }
    }
    
    df[o.negs & df == 0] <- paste0("-", df[o.negs & df == 0])
    
    # Insert NA placeholders
    df[nas] <- na_vals
    
    if (length(rn) > 0) rownames(df) <- rn
    if (length(cn) > 0) names(df) <- cn
    
    return(df)
  }
  
  #To pass CRAN checks:
  utils::globalVariables(c("distance", "addl", "addl.list", "distance.list",
                           "quick", "treat", "Sample", "min.stat",
                           "max.stat", "mean.stat"))
  bal.tab <- function(...) {
    A <- list(...)
    if (is.null(A)) stop("No arguments were supplied.", call. = FALSE)
    A[[1]] <- is.designmatch(A[[1]])
    UseMethod("bal.tab", A[[1]])
  }
  base.bal.tab <- function(weights, treat, distance = NULL, subclass = NULL, covs, call = NULL, int = FALSE, addl = NULL, continuous, binary, s.d.denom, m.threshold = NULL, v.threshold = NULL, ks.threshold = NULL, imbalanced.only = FALSE, un = FALSE, disp.means = FALSE, disp.v.ratio = FALSE, disp.ks = FALSE, disp.subclass = FALSE, disp.bal.tab = TRUE, method, cluster = NULL, which.cluster = NULL, cluster.summary = TRUE, s.weights = NULL, discarded = NULL, abs = FALSE, quick = FALSE, pooled.sds = NULL, ...) {
    
    #Preparations
    args <- list(...)
    if (nunique(treat) != 2) {
      stop("Treatment indicator must be a binary (0, 1) variable---i.e., treatment (1) or control (0)", call. = FALSE)
    }
    else if (is.factor(treat) || is.character(treat)) {
      if (is.factor(treat)) treat.names <- unique.treat <- levels(treat)
      else treat.names <- unique.treat <- unique(treat, nmax = 2)
    }
    else {
      treat.names <- c("Control", "Treated")
      unique.treat <- unique(treat, nmax = 2)
    }
    
    check_if_zero_weights(weights, treat, unique.treat)
    
    treat <- binarize(treat)
    if (is_not_null(m.threshold)) m.threshold <- abs(m.threshold)
    if (is_not_null(v.threshold)) {
      v.threshold <- max(v.threshold, 1/v.threshold)
      disp.v.ratio <- TRUE
    }
    if (is.null(ks.threshold) && is.null(args$k.threshold)) {
      ks.threshold <- args$k.threshold
    }
    if (is_not_null(ks.threshold)) {
      if (ks.threshold > 1) {
        warning("ks.threshold must be between 0 and 1; ignoring ks.threshold.", call. = FALSE)
        ks.threshold <- NULL
      }
      else disp.ks <- TRUE
    }
    if (is.null(weights) && is.null(subclass)) {
      un <- TRUE
      no.adj <- TRUE
    }
    else {
      no.adj <- FALSE
      if (is_not_null(weights) && ncol(weights) == 1) names(weights) <- "Adj"
    }
    if (is.null(s.weights)) {
      s.weights <- rep(1, length(treat))
    }
    
    #Actions
    if (nunique.gt(cluster, 1)) {
      out.names <- c("Cluster.Balance", 
                     "Cluster.Balance.Across.Subclass", 
                     "Cluster.Summary", "Observations",
                     "call", "print.options")
      out <- vector("list", length(out.names))
      names(out) <- out.names
      
      C <- get.C(covs = covs, int = int, addl = addl, distance = distance, cluster = cluster)
      C.list <- setNames(lapply(levels(cluster), function(x) C[cluster == x, , drop = FALSE]), 
                         levels(cluster))
      types <- get.types(C)
      
      if (length(method) == 1 && method == "subclassification") {
        stop("Subclassification with clusters is not yet supported.", call. = FALSE)
        #class(out) <- c("bal.tab.cluster", "bal.tab.subclass", "bal.tab")
      }
      else {
        out[["Cluster.Balance"]] <- setNames(lapply(levels(cluster), function(c) setNames(list(balance.table(C = C.list[[c]], weights = weights[cluster == c, , drop = FALSE], treat = treat[cluster == c], continuous = continuous, binary = binary, s.d.denom = s.d.denom, m.threshold = m.threshold, v.threshold = v.threshold, ks.threshold = ks.threshold, un = un, disp.means = disp.means, disp.v.ratio = disp.v.ratio, disp.ks = disp.ks, s.weights = s.weights[cluster == c], abs = abs, no.adj = no.adj, types = types, quick = quick),
                                                                                               samplesize(treat = treat, weights = weights, subclass = subclass, s.weights = s.weights, method = method, cluster = cluster, which.cluster = c, discarded = discarded)), 
                                                                                          c("Balance", "Observations"))),
                                             levels(cluster))
        balance.tables <- lapply(levels(cluster), function(c) out[["Cluster.Balance"]][[c]][["Balance"]])
        observations <- lapply(levels(cluster), function(c) out[["Cluster.Balance"]][[c]][["Observations"]])
        
        if (cluster.summary || !quick) out[["Cluster.Summary"]] <- balance.table.cluster.summary(balance.tables,
                                                                                                 weight.names = names(weights),
                                                                                                 no.adj = no.adj,
                                                                                                 abs = abs,
                                                                                                 quick = quick,
                                                                                                 types = types)
        if (all(sapply(balance.tables, function(x) !attr(x, "disp")["v"]))) {disp.v.ratio <- FALSE; v.threshold <- NULL}
        if (all(sapply(balance.tables, function(x) !attr(x, "disp")["ks"]))) {disp.ks.ratio <- FALSE; ks.threshold <- NULL}
        out <- out[names(out) %nin% "Cluster.Balance.Across.Subclass"]
        out[["Observations"]] <- samplesize.across.clusters(observations)
        out[["call"]] <- call
        out[["print.options"]] <- list(m.threshold=m.threshold, 
                                       v.threshold=v.threshold,
                                       ks.threshold=ks.threshold,
                                       imbalanced.only = imbalanced.only,
                                       un=un, 
                                       disp.means=disp.means, 
                                       disp.v.ratio=disp.v.ratio, 
                                       disp.ks=disp.ks, 
                                       disp.adj=!no.adj, 
                                       disp.subclass=disp.subclass,
                                       disp.bal.tab = disp.bal.tab, 
                                       which.cluster=which.cluster,
                                       cluster.summary=cluster.summary,
                                       abs = abs,
                                       quick = quick,
                                       nweights = ifelse(no.adj, 0, ncol(weights)),
                                       weight.names = names(weights),
                                       treat.names = treat.names)
        class(out) <- c("bal.tab.cluster", "bal.tab")
      }
      
    }
    else {
      if (length(method) == 1 && method == "subclassification") {
        if (is_not_null(subclass)) {
          out.names <- c("Subclass.Balance", "Balance.Across.Subclass", 
                         "Balanced.Means.Subclass", "Max.Imbalance.Means.Subclass", 
                         "Balanced.Variances.Subclass", "Max.Imbalance.Variances.Subclass", 
                         "Balanced.KS.Subclass", "Max.Imbalance.KS.Subclass", 
                         "Subclass.Observations", "call", "print.options")
          out <- vector("list", length(out.names))
          names(out) <- out.names
          
          C <- get.C(covs = covs, int = int, addl = addl, distance = distance)
          
          if (is_not_null(list(...)$sub.by)) sub.by <- list(...)$sub.by
          else sub.by <- call$sub.by
          out[["Subclass.Balance"]] <- balance.table.subclass(C, weights=weights[[1]], treat=treat, subclass=subclass, continuous=continuous, binary=binary, s.d.denom=s.d.denom[1], m.threshold=m.threshold, v.threshold=v.threshold, ks.threshold = ks.threshold, disp.means = disp.means, disp.v.ratio = disp.v.ratio, disp.ks = disp.ks, quick = quick)
          out[["Subclass.Observations"]] <- samplesize(treat = treat, weights = weights, subclass = subclass, s.weights = s.weights, method = method, discarded = discarded)
          out[["Balance.Across.Subclass"]] <- balance.table.across.subclass(balance.table = balance.table(C, weights[[1]], treat, continuous, binary, s.d.denom[1], m.threshold, v.threshold, un = un, disp.means = disp.means, disp.v.ratio = disp.v.ratio, abs = FALSE, no.adj = TRUE, quick = quick), 
                                                                            balance.table.subclass.list=out[["Subclass.Balance"]], 
                                                                            subclass.obs=out[["Subclass.Observations"]], 
                                                                            sub.by=sub.by, 
                                                                            m.threshold=m.threshold, 
                                                                            v.threshold=v.threshold, 
                                                                            ks.threshold=ks.threshold,
                                                                            s.d.denom = s.d.denom[1])
          if (is_not_null(m.threshold)) {
            out[["Balanced.Means.Subclass"]] <- as.data.frame(lapply(levels(subclass), function(x) baltal(out[["Subclass.Balance"]][[x]][,"M.Threshold"])))
            names(out[["Balanced.Means.Subclass"]]) <- paste("Subclass", levels(subclass))
            mims.list <- lapply(levels(subclass), function(x) {
              return(max.imbal(out[["Subclass.Balance"]][[x]][out[["Subclass.Balance"]][[x]][,"Type"]!="Distance", ], "Diff.Adj", "M.Threshold"))
            } )
            mims <- do.call("rbind", mims.list)
            out[["Max.Imbalance.Means.Subclass"]] <- data.frame(mims, row.names = paste("Subclass", levels(subclass)))
          }
          
          if (is_not_null(attr(out[["Subclass.Balance"]], "dont.disp.v.ratio"))) {disp.v.ratio <- FALSE; v.threshold <- NULL}
          if (is_not_null(v.threshold)) {
            out[["Balanced.Variances.Subclass"]] <- as.data.frame(lapply(levels(subclass), function(x) baltal(out[["Subclass.Balance"]][[x]][,"V.Threshold"])))
            names(out[["Balanced.Variances.Subclass"]]) <- paste("Subclass", levels(subclass))
            mivs.list <- lapply(levels(subclass), function(x) {
              return(max.imbal(out[["Subclass.Balance"]][[x]][out[["Subclass.Balance"]][[x]][,"Type"]!="Distance", ], "V.Ratio.Adj", "V.Threshold"))
            } )      
            mivs <- do.call("rbind", mivs.list)
            
            out[["Max.Imbalance.Variances.Subclass"]] <- data.frame(mivs, row.names = paste("Subclass", levels(subclass)))
          }
          
          if (is_not_null(attr(out[["Subclass.Balance"]], "dont.disp.ks"))) {disp.ks <- FALSE; ks.threshold <- NULL}
          if (is_not_null(ks.threshold)) {
            out[["Balanced.KS.Subclass"]] <- as.data.frame(lapply(levels(subclass), function(x) baltal(out[["Subclass.Balance"]][[x]][["KS.Threshold"]])))
            names(out[["Balanced.KS.Subclass"]]) <- paste("Subclass", levels(subclass))
            miks.list <- lapply(levels(subclass), function(x) {
              return(max.imbal(out[["Subclass.Balance"]][[x]][out[["Subclass.Balance"]][[x]][["Type"]]!="Distance", ], "KS.Adj", "KS.Threshold"))
            } )      
            miks <- do.call("rbind", miks.list)
            
            out[["Max.Imbalance.KS.Subclass"]] <- data.frame(miks, row.names = paste("Subclass", levels(subclass)))
          }
          
          out[["call"]] <- call
          out[["print.options"]] <- list(m.threshold=m.threshold, 
                                         v.threshold=v.threshold, 
                                         ks.threshold=ks.threshold, 
                                         imbalanced.only = imbalanced.only,
                                         un=un, 
                                         disp.means=disp.means, 
                                         disp.v.ratio=disp.v.ratio, 
                                         disp.ks=disp.ks, 
                                         disp.adj=!no.adj, 
                                         disp.subclass=disp.subclass,
                                         disp.bal.tab = disp.bal.tab, 
                                         abs = abs,
                                         quick = quick,
                                         treat.names = treat.names)
          class(out) <- c("bal.tab.subclass", "bal.tab")
        }
        else stop("Method specified as subclassification, but no subclasses were specified.", call. = FALSE)
      }
      else {
        out.names <- c("Balance", "Balanced.Means", 
                       "Max.Imbalance.Means", "Balanced.Variances", 
                       "Max.Imbalance.Variances", "Balanced.KS", 
                       "Max.Imbalance.KS", "Observations", 
                       "call", "print.options")
        out <- vector("list", length(out.names))
        names(out) <- out.names
        
        C <- get.C(covs = covs, int = int, addl = addl, distance = distance)
        
        out[["Balance"]] <- balance.table(C, weights, treat, continuous, binary, s.d.denom = s.d.denom, m.threshold = m.threshold, v.threshold = v.threshold, ks.threshold = ks.threshold, un = un, disp.means = disp.means, disp.v.ratio = disp.v.ratio, disp.ks = disp.ks, s.weights = s.weights, abs = abs, no.adj = no.adj, quick = quick, pooled.sds = pooled.sds)
        
        #Ensure comaptible with multiple weights
        if (is_not_null(m.threshold)) {
          if (no.adj) {
            out[["Balanced.Means"]] <- baltal(out[["Balance"]][,"M.Threshold.Un"])
            out[["Max.Imbalance.Means"]] <- max.imbal(out[["Balance"]][out[["Balance"]][["Type"]]!="Distance", ], "Diff.Un", "M.Threshold.Un")
          }
          else if (ncol(weights) == 1) {
            out[["Balanced.Means"]] <- baltal(out[["Balance"]][,"M.Threshold"])
            out[["Max.Imbalance.Means"]] <- max.imbal(out[["Balance"]][out[["Balance"]][["Type"]]!="Distance", ], "Diff.Adj", "M.Threshold")
          }
          else if (ncol(weights) > 1) {
            out[["Balanced.Means"]] <- setNames(do.call("cbind", lapply(names(weights), function(x) baltal(out[["Balance"]][[paste0("M.Threshold.", x)]]))),
                                                names(weights))
            out[["Max.Imbalance.Means"]] <- cbind(Weights = names(weights),
                                                  do.call("rbind", lapply(names(weights), function(x) setNames(max.imbal(out[["Balance"]][out[["Balance"]][["Type"]]!="Distance", ], paste0("Diff.", x), paste0("M.Threshold.", x)),
                                                                                                               c("Variable", "Diff", "M.Threshold")))),
                                                  stringsAsFactors = FALSE)
          }
        }
        if (!attr(out[["Balance"]], "disp")["v"]) {disp.v.ratio <- FALSE; v.threshold <- NULL}
        if (is_not_null(v.threshold)) {
          if (no.adj) {
            out[["Balanced.Variances"]] <- baltal(out[["Balance"]][["V.Threshold.Un"]])
            out[["Max.Imbalance.Variances"]] <- max.imbal(out[["Balance"]][out[["Balance"]][["Type"]]!="Distance", , drop = FALSE], "V.Ratio.Un", "V.Threshold.Un")
            
          }
          else if (ncol(weights) == 1) {
            out[["Balanced.Variances"]] <- baltal(out[["Balance"]][["V.Threshold"]])
            out[["Max.Imbalance.Variances"]] <- max.imbal(out[["Balance"]][out[["Balance"]][["Type"]]!="Distance", , drop = FALSE], "V.Ratio.Adj", "V.Threshold")
          }
          else {
            out[["Balanced.Variances"]] <- setNames(do.call("cbind", lapply(names(weights), function(x) baltal(out[["Balance"]][[paste0("V.Threshold.", x)]]))),
                                                    names(weights))
            out[["Max.Imbalance.Variances"]] <- cbind(Weights = names(weights),
                                                      do.call("rbind", lapply(names(weights), function(x) setNames(max.imbal(out[["Balance"]][out[["Balance"]][["Type"]]!="Distance", , drop = FALSE], paste0("V.Ratio.", x), paste0("V.Threshold.", x)),
                                                                                                                   c("Variable", "V.Ratio", "V.Threshold")))),
                                                      stringsAsFactors = FALSE)
          }
        }
        if (!attr(out[["Balance"]], "disp")["ks"]) {disp.ks <- FALSE; ks.threshold <- NULL}
        if (is_not_null(ks.threshold)) {
          if (no.adj) {
            out[["Balanced.KS"]] <- baltal(out[["Balance"]][["KS.Threshold.Un"]])
            out[["Max.Imbalance.KS"]] <- max.imbal(out[["Balance"]][out[["Balance"]][["Type"]]!="Distance", , drop = FALSE], "KS.Un", "KS.Threshold.Un")
            
          }
          else if (ncol(weights) == 1) {
            out[["Balanced.KS"]] <- baltal(out[["Balance"]][,"KS.Threshold"])
            out[["Max.Imbalance.KS"]] <- max.imbal(out[["Balance"]][out[["Balance"]][["Type"]]!="Distance", , drop = FALSE], "KS.Adj", "KS.Threshold")
          }
          else {
            out[["Balanced.KS"]] <- setNames(do.call("cbind", lapply(names(weights), function(x) baltal(out[["Balance"]][[paste0("KS.Threshold.", x)]]))),
                                             names(weights))
            out[["Max.Imbalance.KS"]] <- cbind(Weights = names(weights),
                                               do.call("rbind", lapply(names(weights), function(x) setNames(max.imbal(out[["Balance"]][out[["Balance"]][["Type"]]!="Distance", , drop = FALSE], paste0("KS.", x), paste0("KS.Threshold.", x)),
                                                                                                            c("Variable", "KS", "KS.Threshold")))),
                                               stringsAsFactors = FALSE)
          }
        }
        
        out[["Observations"]] <- samplesize(treat = treat, weights = weights, subclass = subclass, s.weights = s.weights, method = method, discarded = discarded, treat.names = treat.names)
        out[["call"]] <- call
        out[["print.options"]] <- list(m.threshold=m.threshold, 
                                       v.threshold=v.threshold, 
                                       ks.threshold=ks.threshold, 
                                       imbalanced.only = imbalanced.only,
                                       un=un, 
                                       disp.means=disp.means, 
                                       disp.v.ratio=disp.v.ratio, 
                                       disp.ks=disp.ks, 
                                       disp.adj=!no.adj,
                                       disp.bal.tab = disp.bal.tab, 
                                       abs = abs,
                                       quick = quick,
                                       nweights = ifelse(no.adj, 0, ncol(weights)),
                                       weight.names = names(weights),
                                       treat.names = treat.names)
        class(out) <- "bal.tab"
      }
    }
    
    #attr(out, "int") <- int
    return(out)
  }
  base.bal.tab.cont <- function(weights, treat, distance = NULL, subclass = NULL, covs, call = NULL, int = FALSE, addl = NULL, r.threshold = NULL, imbalanced.only = FALSE, un = FALSE, disp.subclass = FALSE, disp.bal.tab = TRUE, method, cluster = NULL, which.cluster = NULL, cluster.summary = TRUE, s.weights = NULL, discarded = NULL, abs = FALSE, quick = FALSE, ...) {
    
    #Preparations
    if (is_not_null(r.threshold)) {
      r.threshold <- abs(r.threshold)
      if (r.threshold > 1) {
        warning("r.threshold must be between 0 and 1; ignoring r.threshold.", call. = FALSE)
        r.threshold <- NULL
      }
    }
    if (is.null(weights) && is.null(subclass)) {
      un <- TRUE
      no.adj <- TRUE
    }
    else {
      no.adj <- FALSE
      if (is_not_null(weights) && ncol(weights) == 1) names(weights) <- "Adj"
    }
    if (is.null(s.weights)) {
      s.weights <- rep(1, length(treat))
    }    
    #Actions
    if (nlevels(cluster) > 0) {
      out.names <- c("Cluster.Balance", 
                     "Cluster.Balance.Across.Subclass", 
                     "Cluster.Summary", "Observations",
                     "call", "print.options")
      out <- vector("list", length(out.names))
      names(out) <- out.names
      
      out[["Cluster.Balance"]] <- vector("list", length(levels(cluster)))
      names(out[["Cluster.Balance"]]) <- levels(cluster)
      
      C <- get.C(covs = covs, int = int, addl = addl, distance = distance, cluster = cluster)
      C.list <- structure(lapply(levels(cluster), function(x) C[cluster == x, , drop = FALSE]), names = levels(cluster))
      types <- get.types(C)
      
      if (length(method) == 1 && method == "subclassification") {
        stop("Subclassification with clusters is not yet supported.", call. = FALSE)
        #class(out) <- c("bal.tab.cluster", "bal.tab.subclass", "bal.tab") #add more for subclasses
      }
      else {
        out[["Cluster.Balance"]] <- lapply(levels(cluster), function(c) setNames(list(balance.table.cont(C = C.list[[c]], weights = weights[cluster == c, , drop = FALSE], treat = treat[cluster == c], r.threshold = r.threshold, un = un, s.weights = s.weights[cluster == c], abs = abs, no.adj = no.adj, types = types, quick = quick),
                                                                                      samplesize.cont(treat = treat, weights = weights, subclass = subclass, s.weights = s.weights, method = method, cluster = cluster, which.cluster = c, discarded = discarded)), 
                                                                                 c("Balance", "Observations")))
        names(out[["Cluster.Balance"]]) <- levels(cluster)
        
        balance.tables <- lapply(levels(cluster), function(c) out[["Cluster.Balance"]][[c]][["Balance"]])
        observations <- lapply(levels(cluster), function(c) out[["Cluster.Balance"]][[c]][["Observations"]])
        
        if (!(!cluster.summary && quick)) out[["Cluster.Summary"]] <- balance.table.cluster.summary(balance.tables,
                                                                                                    weight.names = names(weights),
                                                                                                    no.adj = no.adj,
                                                                                                    abs = abs,
                                                                                                    quick = quick,
                                                                                                    types = types)
        out <- out[names(out) %nin% "Cluster.Balance.Across.Subclass"]
        out[["Observations"]] <- samplesize.across.clusters(observations)
        
        out[["call"]] <- call
        out[["print.options"]] <- list(r.threshold=r.threshold, 
                                       imbalanced.only = imbalanced.only,
                                       un=un, 
                                       disp.adj=!no.adj, 
                                       disp.bal.tab = disp.bal.tab,
                                       which.cluster=which.cluster,
                                       cluster.summary=cluster.summary,
                                       abs = abs,
                                       quick = quick,
                                       nweights = ifelse(no.adj, 0, ncol(weights)),
                                       weight.names = names(weights))
        class(out) <- c("bal.tab.cont.cluster", "bal.tab.cluster", "bal.tab.cont", "bal.tab")
      }
      
    }
    else {
      if (length(method) == 1 && method == "subclassification") {
        #stop("Subclassification not yet supported with continuous treatments.", call. = FALSE)
        if (is_not_null(subclass)) {
          out.names <- c("Subclass.Balance", 
                         "Balanced.Corr.Subclass", "Max.Imbalance.Corr.Subclass", 
                         "Subclass.Observations", "call", "print.options")
          out <- vector("list", length(out.names))
          names(out) <- out.names
          
          C <- get.C(covs = covs, int = int, addl = addl, distance = distance)
          
          # if (length(list(...)$sub.by > 0)) sub.by <- list(...)$sub.by
          # else sub.by <- call$sub.by
          
          out[["Subclass.Balance"]] <- balance.table.subclass.cont(C, weights=weights[[1]], treat=treat, subclass=subclass, r.threshold=r.threshold, quick = quick)
          out[["Subclass.Observations"]] <- samplesize.cont(treat = treat, weights = weights, subclass = subclass, s.weights = s.weights, method = method, discarded = discarded)
          #out[["Balance.Across.Subclass"]]
          if (is_not_null(r.threshold)) {
            out[["Balanced.Corr.Subclass"]] <- as.data.frame(lapply(levels(subclass), function(x) baltal(out[["Subclass.Balance"]][[x]][,"R.Threshold"])))
            names(out[["Balanced.Corr.Subclass"]]) <- paste("Subclass", levels(subclass))
            mirs.list <- lapply(levels(subclass), function(x) {
              mi <- max.imbal(out[["Subclass.Balance"]][[x]][out[["Subclass.Balance"]][[x]][,"Type"]!="Distance", ], "Corr.Adj", "R.Threshold")
              return(data.frame(Variable = row.names(mi), mi))
            } )
            mirs <- do.call("rbind", mirs.list)
            out[["Max.Imbalance.Corr.Subclass"]] <- data.frame(mirs, row.names = paste("Subclass", levels(subclass)))
          }
          
          out[["call"]] <- call
          out[["print.options"]] <- list(r.threshold=r.threshold, 
                                         imbalanced.only = imbalanced.only,
                                         un=un,
                                         disp.adj=!no.adj, 
                                         disp.subclass=disp.subclass,
                                         disp.bal.tab = disp.bal.tab,
                                         abs = abs,
                                         quick = quick)
          class(out) <- c("bal.tab.subclass.cont", "bal.tab.subclass", "bal.tab.cont", "bal.tab")
        }
        else stop("Method specified as subclassification, but no subclasses were specified.", call. = FALSE)
        
      }
      else {
        out.names <- c("Balance", "Balanced.Corr", 
                       "Max.Imbalance.Corr", 
                       "Observations", 
                       "call", "print.options")
        out <- vector("list", length(out.names))
        names(out) <- out.names
        
        C <- get.C(covs = covs, int = int, addl = addl, distance = distance, cluster = cluster)
        
        out[["Balance"]] <- balance.table.cont(C, weights, treat, r.threshold, un = un, s.weights = s.weights, abs = abs, no.adj = no.adj, quick = quick)
        if (is_not_null(r.threshold)) {
          if (no.adj) {
            out[["Balanced.Corr"]] <- baltal(out[["Balance"]][["R.Threshold"]])
            out[["Max.Imbalance.Corr"]] <- max.imbal(out[["Balance"]][out[["Balance"]][["Type"]]!="Distance", ], "Corr.Un", "R.Threshold")
          }
          else if (ncol(weights) == 1) {
            out[["Balanced.Corr"]] <- baltal(out[["Balance"]][["R.Threshold"]])
            out[["Max.Imbalance.Corr"]] <- max.imbal(out[["Balance"]][out[["Balance"]][["Type"]]!="Distance", ], "Corr.Adj", "R.Threshold")
          }
          else if (ncol(weights) > 1) {
            out[["Balanced.Corr"]] <- setNames(do.call("cbind", lapply(names(weights), function(x) baltal(out[["Balance"]][[paste0("R.Threshold.", x)]]))),
                                               names(weights))
            out[["Max.Imbalance.Corr"]] <- cbind(Weights = names(weights),
                                                 do.call("rbind", lapply(names(weights), function(x) setNames(max.imbal(out[["Balance"]][out[["Balance"]][["Type"]]!="Distance", ], paste0("Corr.", x), paste0("R.Threshold.", x)),
                                                                                                              c("Variable", "Corr", "R.Threshold")))),
                                                 stringsAsFactors = FALSE)
          }
        }
        if (!any(is.finite(out[["Balance"]][["Corr.Un"]]))) {r.threshold <- NULL}
        out[["Observations"]] <- samplesize.cont(treat = treat, weights = weights, subclass = subclass, s.weights = s.weights, method = method, discarded = discarded)
        out[["call"]] <- call
        out[["print.options"]] <- list(r.threshold=r.threshold, 
                                       imbalanced.only = imbalanced.only,
                                       un=un, 
                                       disp.adj=!no.adj,
                                       disp.bal.tab = disp.bal.tab,
                                       abs = abs,
                                       quick = quick,
                                       nweights = ifelse(no.adj, 0, ncol(weights)),
                                       weight.names = names(weights))
        class(out) <- c("bal.tab.cont", "bal.tab")
      }
    }
    
    attr(out, "int") <- int
    return(out)
  }
  base.bal.tab.imp <- function(weights, treat, distance = NULL, subclass = NULL, covs, call = NULL, int = FALSE, addl = NULL, continuous, binary, s.d.denom, m.threshold = NULL, v.threshold = NULL, ks.threshold = NULL, r.threshold = NULL, imbalanced.only = FALSE, un = FALSE, disp.means = FALSE, disp.v.ratio = FALSE, disp.ks = FALSE, disp.subclass = FALSE, disp.bal.tab = TRUE, method, cluster = NULL, which.cluster = NULL, cluster.summary = TRUE, imp = NULL, which.imp = NA, imp.summary = TRUE, s.weights = NULL, discarded = NULL, abs = FALSE, quick = FALSE, ...) {
    
    #Preparations
    if (is_not_null(m.threshold)) m.threshold <- abs(m.threshold)
    if (is_not_null(v.threshold)) {
      v.threshold <- max(v.threshold, 1/v.threshold)
      disp.v.ratio <- TRUE
    }
    if (is_not_null(ks.threshold)) {
      if (ks.threshold > 1) {
        warning("ks.threshold must be between 0 and 1; ignoring ks.threshold.", call. = FALSE)
        ks.threshold <- NULL
      }
      else disp.ks <- TRUE
    }
    if (is_not_null(r.threshold)) {
      r.threshold <- abs(r.threshold)
      if (r.threshold > 1) {
        warning("r.threshold must be between 0 and 1; ignoring r.threshold.", call. = FALSE)
        r.threshold <- NULL
      }
    }
    if (is.null(weights)) {
      un <- TRUE
      no.adj <- TRUE
    }
    else {
      no.adj <- FALSE
      if (ncol(weights) == 1) names(weights) <- "Adj"
    }
    if (is.null(s.weights)) {
      s.weights <- rep(1, length(treat))
    }    
    #Setup output object
    out.names <- c("Imputation.Balance", 
                   "Cluster.Balance.Across.Imputations",
                   "Balance.Across.Imputations", 
                   "Observations", 
                   "call", "print.options")
    out <- vector("list", length(out.names))
    names(out) <- out.names
    
    #Get list of bal.tabs for each imputation
    if (isTRUE(attr(treat, "treat.type") == "continuous") || (is.numeric(treat) && !is_binary(treat))) {#if continuous treatment
      out[["Imputation.Balance"]] <- lapply(levels(imp), function(i) base.bal.tab.cont(weights = weights[imp==i, , drop  = FALSE], treat = treat[imp==i], distance = distance[imp==i, , drop = FALSE], subclass = subclass[imp==i], covs = covs[imp == i, , drop = FALSE], call = call, int = int, addl = addl[imp = i, , drop = FALSE], r.threshold = r.threshold, imbalanced.only = imbalanced.only, un = un, disp.bal.tab = disp.bal.tab, method = method, cluster = cluster[imp==i], which.cluster = which.cluster, cluster.summary = cluster.summary, s.weights = s.weights[imp==i], discarded = discarded[imp==i], quick = quick, ...))
    }
    else if (isTRUE(attr(treat, "treat.type") == "multinomial") || ((is.factor(treat) || is.character(treat)) && !is_binary(treat))) {
      stop("Multinomial treaments are not yet supported with multiply imputed data.", call. = FALSE)
    }
    else {#if binary treatment
      out[["Imputation.Balance"]] <- lapply(levels(imp), function(i) base.bal.tab(weights = weights[imp==i, , drop = FALSE], treat = treat[imp==i], distance = distance[imp==i, , drop = FALSE], subclass = subclass[imp==i], covs = covs[imp==i, , drop = FALSE], call = call, int = int, addl = addl[imp==i, , drop = FALSE], continuous = continuous, binary = binary, s.d.denom = s.d.denom, m.threshold = m.threshold, v.threshold = v.threshold, ks.threshold = ks.threshold, imbalanced.only = imbalanced.only, un = un, disp.means = disp.means, disp.v.ratio = disp.v.ratio, disp.ks = disp.ks, disp.subclass = disp.subclass, disp.bal.tab = disp.bal.tab, method = method, cluster = cluster[imp==i], which.cluster = which.cluster, cluster.summary = cluster.summary, s.weights = s.weights[imp==i], discarded = discarded[imp==i], quick = quick, ...))
    }
    
    names(out[["Imputation.Balance"]]) <- levels(imp)
    
    #Create summary of lists
    
    if ("bal.tab.cluster" %in% class(out[["Imputation.Balance"]][[1]])) {
      if (imp.summary || !quick) {
        out[["Cluster.Balance.Across.Imputations"]] <- lapply(levels(cluster), 
                                                              function(c) setNames(list(balance.table.imp.summary(lapply(out[["Imputation.Balance"]], function(i) i[["Cluster.Balance"]][[c]][["Balance"]]), 
                                                                                                                  weight.names = names(weights),
                                                                                                                  no.adj = no.adj,
                                                                                                                  abs = abs, quick = quick),
                                                                                        samplesize.across.imps(lapply(out[["Imputation.Balance"]], function(i) i[["Cluster.Balance"]][[c]][["Observations"]]))), 
                                                                                   c("Cluster.Balance", "Cluster.Observations")))
        names(out[["Cluster.Balance.Across.Imputations"]]) <- levels(cluster)
        balance.tables <- lapply(out[["Cluster.Balance.Across.Imputations"]], function(c) c[["Cluster.Balance"]])
        observations <- lapply(out[["Cluster.Balance.Across.Imputations"]], function(c) c[["Cluster.Observations"]])
        
        out[["Balance.Across.Imputations"]] <- balance.table.clust.imp.summary(balance.tables,
                                                                               weight.names = names(weights),
                                                                               no.adj = no.adj,
                                                                               abs = abs,
                                                                               quick = quick,
                                                                               types = NULL)
        out[["Observations"]] <- samplesize.across.clusters(observations)
      }
      
      classes <- c("bal.tab.imp.cluster", "bal.tab.imp")
    }
    else {
      if ("bal.tab.subclass" %in% class(out[["Imputation.Balance"]][[1]])) {
        #Put something here
        stop("Subclassification cannot be used with multiply imputed data.", call. = FALSE)
      }
      else {
        if (imp.summary || !quick) out[["Balance.Across.Imputations"]] <- balance.table.imp.summary(bal.tab.imp.list = out[["Imputation.Balance"]], 
                                                                                                    weight.names = names(weights),
                                                                                                    no.adj = no.adj,
                                                                                                    abs = abs,
                                                                                                    quick = quick,
                                                                                                    types = NULL)
        observations <- lapply(out[["Imputation.Balance"]], function(x) x[["Observations"]])
        
        out[["Observations"]] <- samplesize.across.imps(observations)
        classes <- "bal.tab.imp"
      }
    }
    
    out[["call"]] <- call
    out[["print.options"]] <- list(m.threshold=m.threshold,
                                   v.threshold=v.threshold,
                                   ks.threshold=ks.threshold,
                                   r.threshold=r.threshold,
                                   imbalanced.only = imbalanced.only,
                                   un=un, 
                                   disp.adj=!no.adj, 
                                   which.cluster=which.cluster,
                                   cluster.summary=cluster.summary,
                                   which.imp=which.imp,
                                   imp.summary=imp.summary,
                                   abs = abs,
                                   quick = quick,
                                   disp.means=disp.means, 
                                   disp.v.ratio=disp.v.ratio, 
                                   disp.ks=disp.ks,
                                   disp.bal.tab = disp.bal.tab,
                                   nweights = ifelse(no.adj, 0, ncol(weights)),
                                   weight.names = names(weights))
    class(out) <- unique(c(classes, sapply(out[["Imputation.Balance"]], class)))
    
    return(out)
  }
  base.bal.tab.multi <- function(weights, treat, distance = NULL, subclass = NULL, covs, call = NULL, int = FALSE, addl = NULL, continuous, binary, s.d.denom, m.threshold = NULL, v.threshold = NULL, ks.threshold = NULL, imbalanced.only = FALSE, un = FALSE, disp.means = FALSE, disp.v.ratio = FALSE, disp.ks = FALSE, disp.subclass = FALSE, disp.bal.tab = TRUE, method, cluster = NULL, which.cluster = NULL, cluster.summary = TRUE, pairwise = TRUE, focal = NULL, which.treat = NA, multi.summary = TRUE, s.weights = NULL, discarded = NULL, abs = FALSE, quick = FALSE, ...) {
    #Preparations
    
    if (is_not_null(m.threshold)) m.threshold <- abs(m.threshold)
    if (is_not_null(v.threshold)) {
      v.threshold <- max(v.threshold, 1/v.threshold)
      disp.v.ratio <- TRUE
    }
    if (is_not_null(ks.threshold)) {
      if (ks.threshold > 1) {
        warning("ks.threshold must be between 0 and 1; ignoring ks.threshold.", call. = FALSE)
        ks.threshold <- NULL
      }
      else disp.ks <- TRUE
    }
    if (is.null(weights) && is.null(subclass)) {
      un <- TRUE
      no.adj <- TRUE
    }
    else {
      no.adj <- FALSE
      if (is_not_null(weights) && ncol(weights) == 1) names(weights) <- "Adj"
    }
    if (is.null(s.weights)) {
      s.weights <- rep(1, length(treat))
    }
    
    #Treat is a factor variable of 3+ levels
    if (is.null(focal)) {
      if (pairwise) treat.combinations <- combn(levels(treat), 2, list)
      else treat.combinations <- lapply(levels(treat), function(x) c(x, "Others"))
    }
    else if (length(focal) == 1) {
      if (is.numeric(focal)) {
        focal <- levels(treat)[focal]
      }
      if (is.character(focal)) {
        treat <- relevel(treat, focal)
      }
      else {
        stop("focal must be the name or index of the focal treatment group.", call. = FALSE)
      }
      treat.combinations <- lapply(levels(treat)[levels(treat) != focal], function(x) rev(c(focal, x)))
      pairwise <- TRUE
    }
    else stop("focal must be a vector of length 1 containing the name or index of the focal treatment group.", call. = FALSE)
    treat.names <- levels(treat)
    
    if (is_not_null(cluster)) {
      stop("Clusters are not yet supported with multiple categorical treatments.", call. = FALSE)
    }
    else {
      #Setup output object
      out.names <- c("Pair.Balance", 
                     "Balance.Across.Pairs", 
                     "Observations", 
                     "call", "print.options")
      out <- vector("list", length(out.names))
      names(out) <- out.names
      
      if (any(s.d.denom == "pooled")) {
        C <- get.C(covs = covs, int = int, addl = addl, distance = distance)
        pooled.sds <- rowMeans(do.call("cbind", lapply(levels(treat), function(t) sqrt(col.w.v(C[treat == t, , drop = FALSE], 
                                                                                               s.weights[treat == t])))))
        #pooled.sds <- sqrt(col.w.v(C, s.weights)) #How twang does it
      }
      else pooled.sds <- NULL
      
      if (pairwise || is_not_null(focal)) {
        balance.tables <- lapply(treat.combinations, function(t) base.bal.tab(weights = weights[treat %in% t, , drop = FALSE], treat = factor(treat[treat %in% t], t), distance = distance[treat %in% t, , drop = FALSE], subclass = subclass[treat %in% t], covs = covs[treat %in% t, , drop = FALSE], call = NULL, int = int, addl = addl[treat %in% t, , drop = FALSE], continuous = continuous, binary = binary, s.d.denom = s.d.denom, m.threshold = m.threshold, v.threshold = v.threshold, ks.threshold = ks.threshold, imbalanced.only = imbalanced.only, un = un, disp.means = disp.means, disp.v.ratio = disp.v.ratio, disp.ks = disp.ks, disp.subclass = disp.subclass, disp.bal.tab = disp.bal.tab, method = method, cluster = cluster[treat %in% t], which.cluster = which.cluster, cluster.summary = cluster.summary, s.weights = s.weights[treat %in% t], discarded = discarded[treat %in% t], quick = quick, pooled.sds = pooled.sds, ...))
      }
      else {
        if (any(treat.names == "Others")) stop ("\"Others\" cannot be the name of a treatment level. Please rename your treatments.", call. = FALSE)
        balance.tables <- lapply(treat.combinations, function(t) {
          treat_ <- factor(treat, levels = c(levels(treat), "Others"))
          treat_[treat_ != t[1]] <- "Others"
          treat_ <- factor(treat_, rev(t))
          base.bal.tab(weights = weights, treat = treat_, distance = distance, subclass = subclass, covs = covs, call = NULL, int = int, addl = addl, continuous = continuous, binary = binary, s.d.denom = s.d.denom, m.threshold = m.threshold, v.threshold = v.threshold, ks.threshold = ks.threshold, imbalanced.only = imbalanced.only, un = un, disp.means = disp.means, disp.v.ratio = disp.v.ratio, disp.ks = disp.ks, disp.subclass = disp.subclass, disp.bal.tab = disp.bal.tab, method = method, cluster = cluster, which.cluster = which.cluster, cluster.summary = cluster.summary, s.weights = s.weights, discarded = discarded, quick = quick, pooled.sds = pooled.sds, ...)
        })
      }
      for (i in seq_along(balance.tables)) {
        names(balance.tables)[i] <- paste(rev(treat.combinations[[i]]), collapse = " vs. ")
      }
      
      out[["Pair.Balance"]] <- balance.tables
      
      out[["Observations"]] <- samplesize.multi(balance.tables, treat.names, focal)
      
      out[["Balance.Across.Pairs"]] <- balance.table.multi.summary(balance.tables, 
                                                                   weight.names = names(weights),
                                                                   m.threshold = m.threshold,
                                                                   v.threshold = v.threshold,
                                                                   ks.threshold = ks.threshold,
                                                                   no.adj = no.adj,
                                                                   quick = quick,
                                                                   types = NULL)
      
      out[["call"]] <- call
      
      out[["print.options"]] <- list(m.threshold=m.threshold,
                                     v.threshold=v.threshold,
                                     ks.threshold=ks.threshold,
                                     imbalanced.only = imbalanced.only,
                                     un=un, 
                                     disp.adj=!no.adj, 
                                     which.cluster=which.cluster,
                                     cluster.summary=cluster.summary,
                                     abs = abs,
                                     quick = quick,
                                     disp.means=disp.means, 
                                     disp.v.ratio=disp.v.ratio, 
                                     disp.ks=disp.ks,
                                     disp.bal.tab = disp.bal.tab,
                                     nweights = ifelse(no.adj, 0, ncol(weights)),
                                     weight.names = names(weights),
                                     treat.names = treat.names,
                                     which.treat = which.treat,
                                     multi.summary = multi.summary,
                                     pairwise = pairwise)
      
      class(out) <- c("bal.tab.multi", "bal.tab")
    }
    return(out)
    
  }
  base.bal.tab.msm <- function(weights, treat.list, distance.list = NULL, subclass = NULL, covs.list, call = NULL, int = FALSE, addl.list = NULL, continuous, binary, s.d.denom, m.threshold = NULL, v.threshold = NULL, ks.threshold = NULL, r.threshold = NULL, imbalanced.only = FALSE, un = FALSE, disp.means = FALSE, disp.v.ratio = FALSE, disp.ks = FALSE, disp.bal.tab = TRUE, method, cluster = NULL, which.cluster = NULL, cluster.summary = TRUE, pairwise = TRUE, focal = NULL, which.treat = NA, multi.summary = TRUE, which.time = NULL, msm.summary = TRUE, s.weights = NULL, discarded = NULL, abs = FALSE, quick = FALSE, ...) {
    #One vector of weights
    #treat.list should be a df/list of treatment vectors, one for each time period
    #cov.list should be a list of covariate data.frames, one for each time period; 
    #   should include all covs from previous time points, but no treatment statuses
    
    #Preparations
    args <- list(...)
    
    if (is_not_null(m.threshold)) m.threshold <- abs(m.threshold)
    if (is_not_null(v.threshold)) {
      v.threshold <- max(v.threshold, 1/v.threshold)
      disp.v.ratio <- TRUE
    }
    if (is_not_null(ks.threshold) && is_not_null(args$k.threshold)) {
      ks.threshold <- args$k.threshold
    }
    if (is_not_null(ks.threshold)) {
      if (ks.threshold > 1) {
        warning("ks.threshold must be between 0 and 1; ignoring ks.threshold.", call. = FALSE)
        ks.threshold <- NULL
      }
      else disp.ks <- TRUE
    }
    if (is_not_null(r.threshold)) {
      r.threshold <- abs(r.threshold)
      if (r.threshold > 1) {
        warning("r.threshold must be between 0 and 1; ignoring r.threshold.", call. = FALSE)
        r.threshold <- NULL
      }
    }
    if (is.null(weights) && is.null(subclass)) {
      un <- TRUE
      no.adj <- TRUE
    }
    else {
      no.adj <- FALSE
      if (is_not_null(weights) && ncol(weights) == 1) names(weights) <- "Adj"
    }
    if (is.null(s.weights)) {
      s.weights <- rep(1, length(treat.list[[1]]))
    }
    
    if (nunique.gt(cluster, 1)) {
      stop("Clusters are not yet supported with longitudinal treatments.", call. = FALSE)
    }
    else {
      #Setup output object
      out.names <- c("Time.Balance", 
                     "Balance.Across.Times", 
                     "Observations", 
                     "call", "print.options")
      out <- vector("list", length(out.names))
      names(out) <- out.names
      
      out[["Time.Balance"]] <- vector("list", length(covs.list))
      
      treat.type <- sapply(treat.list, function(x) {
        if (isTRUE(attr(x, "treat.type") %in% c("binary", "multinomial", "continuous"))) {
          attr(x, "treat.type")
        }
        else if (!is_binary(x)) {
          if (is.numeric(x)) "continuous"
          else if (is.factor(x) || is.character(x)) "multinomial"
        }
        else if (nunique.gt(x, 1)) {
          "binary"
        }
        else {
          stop("All treatments must have at least 2 unique values.", call. = FALSE)
        }
      })
      
      #Get list of bal.tabs for each time period
      out[["Time.Balance"]] <- lapply(seq_along(treat.list), function(ti) {
        if (treat.type[ti] == "continuous") {
          out_ <- base.bal.tab.cont(weights = weights, treat = treat.list[[ti]], distance = distance.list[[ti]], subclass = NULL, covs = covs.list[[ti]], call = NULL, int = int, addl = addl.list[[ti]], r.threshold = r.threshold, imbalanced.only = imbalanced.only, un = un, disp.bal.tab = disp.bal.tab, method = method, cluster = cluster, which.cluster = which.cluster, cluster.summary = cluster.summary, s.weights = s.weights, discarded = discarded, quick = quick, ...)
        }
        else if (treat.type[ti] == "multinomial") {
          out_ <- base.bal.tab.multi(weights = weights, treat = treat.list[[ti]], distance=distance.list[[ti]], 
                                     covs=covs.list[[ti]], call=NULL, int=int, addl=addl.list[[ti]], 
                                     continuous=continuous, binary=binary, s.d.denom=s.d.denom, 
                                     m.threshold=m.threshold, v.threshold=v.threshold, 
                                     ks.threshold=ks.threshold, 
                                     imbalanced.only = imbalanced.only,
                                     un=un, 
                                     disp.bal.tab = disp.bal.tab, 
                                     disp.means=disp.means,
                                     disp.v.ratio=disp.v.ratio, 
                                     disp.ks=disp.ks, 
                                     method=method, 
                                     cluster = cluster, which.cluster = which.cluster, 
                                     cluster.summary = cluster.summary, pairwise = pairwise, focal = NULL,
                                     which.treat = which.treat, multi.summary = multi.summary,
                                     s.weights = s.weights, quick = quick)
        }
        else if (treat.type[ti] == "binary") {
          out_ <- base.bal.tab(weights = weights, treat = treat.list[[ti]], distance = distance.list[[ti]], subclass = NULL, covs = covs.list[[ti]], call = NULL, int = int, addl = addl.list[[ti]], continuous = continuous, binary = binary, s.d.denom = s.d.denom, m.threshold = m.threshold, v.threshold = v.threshold, ks.threshold = ks.threshold, imbalanced.only = imbalanced.only, un = un, disp.means = disp.means, disp.v.ratio = disp.v.ratio, disp.ks = disp.ks, disp.subclass = FALSE, disp.bal.tab = disp.bal.tab, method = method, cluster = cluster, which.cluster = which.cluster, cluster.summary = cluster.summary, s.weights = s.weights, discarded = discarded, quick = quick, ...)
        }
        else stop("Each treatment must be binary, multinomial, or continuous.", call. = FALSE)
        
        return(out_)
      })
      
      if (length(names(treat.list)) == length(treat.list)) {
        names(out[["Time.Balance"]]) <- names(treat.list)
      }
      else names(out[["Time.Balance"]]) <- seq_along(treat.list)
      
      out[["Observations"]] <- lapply(out[["Time.Balance"]], function(x) x$Observations)
      
      if (!(quick && !msm.summary) && all_the_same(treat.type) && !any(treat.type == "multinomial")) {
        out[["Balance.Across.Times"]] <- balance.table.msm.summary(out[["Time.Balance"]],
                                                                   weight.names = names(weights),
                                                                   no.adj = no.adj,
                                                                   m.threshold = m.threshold, 
                                                                   v.threshold = v.threshold, 
                                                                   ks.threshold = ks.threshold, 
                                                                   r.threshold = r.threshold, 
                                                                   quick = quick, 
                                                                   types = NULL)
      }
      
      out[["call"]] <- call
      
      out[["print.options"]] <- list(m.threshold=m.threshold, 
                                     v.threshold=v.threshold,
                                     ks.threshold=ks.threshold,
                                     r.threshold = r.threshold,
                                     imbalanced.only = imbalanced.only,
                                     un=un, 
                                     disp.means=disp.means, 
                                     disp.v.ratio=disp.v.ratio, 
                                     disp.ks=disp.ks, 
                                     disp.adj=!no.adj, 
                                     disp.bal.tab = disp.bal.tab, 
                                     which.cluster=which.cluster,
                                     cluster.summary=cluster.summary,
                                     abs = abs,
                                     quick = quick,
                                     nweights = ifelse(no.adj, 0, ncol(weights)),
                                     weight.names = names(weights),
                                     which.time = which.time,
                                     msm.summary = msm.summary)
      
      class(out) <- c("bal.tab.msm", "bal.tab")
    }
    
    return(out)
  }
  
  #Point treatments
  bal.tab.matchit <- function(m, int = FALSE, distance = NULL, addl = NULL, data = NULL,  continuous = c("std", "raw"), binary = c("raw", "std"), s.d.denom = c("treated", "control", "pooled"), m.threshold = NULL, v.threshold = NULL, ks.threshold = NULL, imbalanced.only = FALSE, un = FALSE, disp.bal.tab = TRUE, disp.means = FALSE, disp.v.ratio = FALSE, disp.ks = FALSE, disp.subclass = FALSE, cluster = NULL, which.cluster = NULL, cluster.summary = TRUE, abs = FALSE, subset = NULL, quick = FALSE, ...) {
    
    args <- c(as.list(environment()), list(...))[-1]
    
    #Adjustments to arguments
    args.with.choices <- names(formals()[-1])[sapply(formals()[-c(1, length(formals()))], function(x) length(x)>1)]
    for (i in seq_along(args.with.choices)) assign(args.with.choices[i], eval(parse(text=paste0("match.arg(", args.with.choices[i], ")"))))
    
    blank.args <- sapply(formals()[-c(1, length(formals()))], function(x) identical(x, quote(expr =)))
    if (any(blank.args)) {
      for (arg.name in names(blank.args)[blank.args]) {
        if (identical(args[[arg.name]], quote(expr = ))) {
          assign(arg.name, NULL)
        }
      }
    }
    
    #Initializing variables
    X <- x2base.matchit(m, data = data, distance = distance, addl = addl, cluster = cluster,
                        subset = subset)
    
    out <- base.bal.tab(weights=X$weights, 
                        treat=X$treat, 
                        distance=X$distance, 
                        subclass=X$subclass, 
                        covs=X$covs, 
                        call=X$call, 
                        int=int, 
                        addl=X$addl, 
                        continuous=continuous, 
                        binary=binary, 
                        s.d.denom=s.d.denom, 
                        m.threshold=m.threshold, 
                        v.threshold=v.threshold, 
                        ks.threshold=ks.threshold, 
                        imbalanced.only = imbalanced.only,
                        un=un, 
                        disp.means=disp.means, 
                        disp.v.ratio=disp.v.ratio, 
                        disp.ks=disp.ks, 
                        disp.subclass=disp.subclass,                                 
                        disp.bal.tab = disp.bal.tab,
                        method=X$method, 
                        cluster = X$cluster, 
                        which.cluster = which.cluster, 
                        cluster.summary = cluster.summary, 
                        abs = abs,
                        discarded = X$discarded, 
                        quick = quick)
    return(out)
  }
  bal.tab.ps <- function(ps, stop.method, int = FALSE, distance = NULL, addl = NULL, data = NULL, continuous = c("std", "raw"), binary = c("raw", "std"), s.d.denom, m.threshold = NULL, v.threshold = NULL, ks.threshold = NULL, imbalanced.only = FALSE, un = FALSE, disp.bal.tab = TRUE, disp.means = FALSE, disp.v.ratio = FALSE, disp.ks = FALSE, cluster = NULL, which.cluster = NULL, cluster.summary = TRUE, abs = FALSE, subset = NULL, quick = FALSE, ...) {
    args <- as.list(environment())[-1]
    #Adjustments to arguments
    args.with.choices <- names(formals()[-1])[sapply(formals()[-c(1, length(formals()))], function(x) length(x)>1)]
    for (i in seq_along(args.with.choices)) assign(args.with.choices[i], eval(parse(text=paste0("match.arg(", args.with.choices[i], ")"))))
    
    blank.args <- sapply(formals()[-c(1, length(formals()))], function(x) identical(x, quote(expr =)))
    if (any(blank.args)) {
      for (arg.name in names(blank.args)[blank.args]) {
        if (identical(args[[arg.name]], quote(expr = ))) {
          assign(arg.name, NULL)
        }
      }
    }
    
    #Initializing variables
    X <- x2base.ps(ps, 
                   stop.method = stop.method, 
                   s.d.denom = s.d.denom, 
                   distance = distance,
                   addl = addl,
                   cluster = cluster,
                   subset = subset,
                   ...)
    
    out <- base.bal.tab(weights=X$weights, 
                        treat=X$treat, 
                        distance=X$distance, 
                        covs=X$covs, 
                        call=X$call, 
                        int=int, 
                        addl=X$addl, 
                        continuous=continuous, 
                        binary=binary, 
                        s.d.denom=X$s.d.denom, 
                        m.threshold=m.threshold, 
                        v.threshold=v.threshold, 
                        ks.threshold=ks.threshold, 
                        imbalanced.only = imbalanced.only,
                        un=un, 
                        disp.means=disp.means, 
                        disp.v.ratio=disp.v.ratio, 
                        disp.ks=disp.ks, 
                        disp.bal.tab = disp.bal.tab,
                        method=X$method, 
                        cluster = X$cluster, 
                        which.cluster = which.cluster, 
                        cluster.summary = cluster.summary, 
                        s.weights = X$s.weights, 
                        abs = abs, 
                        quick = quick)
    return(out)
  }
  bal.tab.mnps <- function(mnps, stop.method, int = FALSE, distance = NULL, addl = NULL, data = NULL, continuous = c("std", "raw"), binary = c("raw", "std"), s.d.denom, m.threshold = NULL, v.threshold = NULL, ks.threshold = NULL, imbalanced.only = FALSE, un = FALSE, disp.bal.tab = TRUE, disp.means = FALSE, disp.v.ratio = FALSE, disp.ks = FALSE, cluster = NULL, which.cluster = NULL, cluster.summary = TRUE, pairwise = TRUE, focal = NULL, which.treat = NA, multi.summary = TRUE, abs = FALSE, subset = NULL, quick = FALSE, ...) {
    args <- as.list(environment())[-1]
    #Adjustments to arguments
    args.with.choices <- names(formals()[-1])[sapply(formals()[-c(1, length(formals()))], function(x) length(x)>1)]
    for (i in seq_along(args.with.choices)) assign(args.with.choices[i], eval(parse(text=paste0("match.arg(", args.with.choices[i], ")"))))
    
    blank.args <- sapply(formals()[-c(1, length(formals()))], function(x) identical(x, quote(expr =)))
    if (any(blank.args)) {
      for (arg.name in names(blank.args)[blank.args]) {
        if (identical(args[[arg.name]], quote(expr = ))) {
          assign(arg.name, NULL)
        }
      }
    }
    
    #Initializing variables
    X <- x2base.mnps(mnps,
                     stop.method = stop.method,
                     s.d.denom = s.d.denom,
                     distance = distance,
                     addl = addl,
                     cluster = cluster,
                     subset = subset,
                     ...)
    
    #stop("bal.tab is not yet compatible with mnps objects.", call. = FALSE)
    out <- base.bal.tab.multi(weights=X$weights, 
                              treat=X$treat, 
                              distance=X$distance, 
                              covs=X$covs, 
                              call=X$call, 
                              int=int, 
                              addl=X$addl, 
                              continuous=continuous, 
                              binary=binary, 
                              s.d.denom=X$s.d.denom, 
                              m.threshold=m.threshold, 
                              v.threshold=v.threshold, 
                              ks.threshold=ks.threshold, 
                              imbalanced.only = imbalanced.only,
                              un=un, 
                              disp.means=disp.means, 
                              disp.v.ratio=disp.v.ratio, 
                              disp.ks=disp.ks, 
                              disp.bal.tab = disp.bal.tab,
                              method="weighting", 
                              cluster = X$cluster, 
                              which.cluster = which.cluster, 
                              cluster.summary = cluster.summary, 
                              pairwise = pairwise, focal = X$focal,
                              which.treat = which.treat,
                              multi.summary = multi.summary,
                              s.weights = X$s.weights, 
                              abs = abs, 
                              quick = quick)
    return(out)
  }
  bal.tab.ps.cont <- function(ps.cont, stop.method, int = FALSE, distance = NULL, addl = NULL, data = NULL, r.threshold = NULL, imbalanced.only = FALSE, un = FALSE, disp.bal.tab = TRUE, cluster = NULL, which.cluster = NULL, cluster.summary = TRUE, abs = FALSE, subset = NULL, quick = FALSE, ...) {
    args <- as.list(environment())[-1]
    #Adjustments to arguments
    args.with.choices <- names(formals()[-1])[sapply(formals()[-c(1, length(formals()))], function(x) length(x)>1)]
    for (i in seq_along(args.with.choices)) assign(args.with.choices[i], eval(parse(text=paste0("match.arg(", args.with.choices[i], ")"))))
    
    blank.args <- sapply(formals()[-c(1, length(formals()))], function(x) identical(x, quote(expr =)))
    if (any(blank.args)) {
      for (arg.name in names(blank.args)[blank.args]) {
        if (identical(args[[arg.name]], quote(expr = ))) {
          assign(arg.name, NULL)
        }
      }
    }
    
    #Initializing variables
    X <- x2base.ps.cont(ps.cont, 
                        stop.method = stop.method, 
                        distance = distance,
                        addl = addl,
                        cluster = cluster,
                        subset = subset,
                        ...)
    
    out <- base.bal.tab.cont(weights=X$weights, 
                             treat = X$treat, 
                             distance = X$distance, 
                             covs=X$covs, 
                             call=X$call, 
                             int=int, 
                             addl = X$addl, 
                             r.threshold = r.threshold, 
                             un = un, 
                             disp.bal.tab = disp.bal.tab,
                             method = X$method, 
                             cluster = X$cluster, 
                             which.cluster = which.cluster, 
                             cluster.summary = cluster.summary, 
                             s.weights = X$s.weights, 
                             abs = abs,
                             quick = quick)
    return(out)
  }
  bal.tab.Match <- function(M, formula = NULL, data = NULL, treat = NULL, covs = NULL, int = FALSE, distance = NULL, addl = NULL, continuous = c("std", "raw"), binary = c("raw", "std"), s.d.denom, m.threshold = NULL, v.threshold = NULL, ks.threshold = NULL, imbalanced.only = FALSE, un = FALSE, disp.bal.tab = TRUE, disp.means = FALSE, disp.v.ratio = FALSE, disp.ks = FALSE, cluster = NULL, which.cluster = NULL, cluster.summary = TRUE, abs = FALSE, subset = NULL, quick = FALSE, ...) {
    
    args <- c(as.list(environment()), list(...))[-1]
    
    #Adjustments to arguments
    args.with.choices <- names(formals()[-1])[sapply(formals()[-c(1, length(formals()))], function(x) length(x)>1)]
    for (i in seq_along(args.with.choices)) assign(args.with.choices[i], eval(parse(text=paste0("match.arg(", args.with.choices[i], ")"))))
    
    blank.args <- sapply(formals()[-c(1, length(formals()))], function(x) identical(x, quote(expr =)))
    if (any(blank.args)) {
      for (arg.name in names(blank.args)[blank.args]) {
        if (identical(args[[arg.name]], quote(expr = ))) {
          assign(arg.name, NULL)
        }
      }
    }
    
    #Initializing variables
    X <- x2base.Match(M, 
                      formula = formula,
                      data = data, 
                      treat = treat,
                      covs = covs,
                      addl = addl,
                      distance = distance,
                      s.d.denom = s.d.denom,
                      cluster = cluster,
                      subset = subset)
    
    out <- base.bal.tab(weights=X$weights, 
                        treat=X$treat, 
                        distance=X$distance, 
                        covs=X$covs, 
                        call=X$call, 
                        int=int, 
                        addl=X$addl, 
                        continuous=continuous, 
                        binary=binary, 
                        s.d.denom=X$s.d.denom, 
                        m.threshold=m.threshold, 
                        v.threshold=v.threshold, 
                        ks.threshold=ks.threshold, 
                        imbalanced.only = imbalanced.only,
                        un=un, 
                        disp.means=disp.means, 
                        disp.v.ratio=disp.v.ratio, 
                        disp.ks=disp.ks, 
                        disp.bal.tab = disp.bal.tab,
                        method=X$method, 
                        cluster = X$cluster, 
                        which.cluster = which.cluster, 
                        cluster.summary = cluster.summary, 
                        abs = abs, 
                        discarded = X$discarded, 
                        quick = quick)
    return(out)
  }
  bal.tab.formula <- function(formula, data = NULL, ...) {
    
    args <- c(as.list(environment()), list(...))[-1]
    args[["covs"]] <- NULL
    args[["treat"]] <- NULL
    
    #Adjustments to arguments
    args.with.choices <- names(formals()[-1])[sapply(formals()[-c(1, length(formals()))], function(x) length(x)>1)]
    for (i in seq_along(args.with.choices)) assign(args.with.choices[i], eval(parse(text=paste0("match.arg(", args.with.choices[i], ")"))))
    
    blank.args <- sapply(formals()[-c(1, length(formals()))], function(x) identical(x, quote(expr =)))
    if (any(blank.args)) {
      for (arg.name in names(blank.args)[blank.args]) {
        if (identical(args[[arg.name]], quote(expr = ))) {
          assign(arg.name, NULL)
        }
      }
    }
    
    #Initializing variables
    t.c <- get.covs.and.treat.from.formula(formula, data)
    covs <- t.c[["reported.covs"]]
    treat <- t.c[["treat"]]
    
    out <- do.call("bal.tab.data.frame", c(list(covs = covs, treat = treat), args))
    
    return(out)
  }
  bal.tab.data.frame <- function(covs, treat, data = NULL, weights = NULL, distance = NULL, subclass = NULL, match.strata = NULL, method, int = FALSE, addl = NULL, continuous = c("std", "raw"), binary = c("raw", "std"), s.d.denom, m.threshold = NULL, v.threshold = NULL, ks.threshold = NULL, r.threshold = NULL, imbalanced.only = FALSE, un = FALSE, disp.bal.tab = TRUE, disp.means = FALSE, disp.v.ratio = FALSE, disp.ks = FALSE, disp.subclass = FALSE, cluster = NULL, which.cluster = NULL, cluster.summary = TRUE, imp = NULL, which.imp = NA, imp.summary = TRUE, pairwise = TRUE, focal = NULL, which.treat = NA, multi.summary = TRUE, s.weights = NULL, estimand = NULL, abs = FALSE, subset = NULL, quick = FALSE, ...) {
    
    args <- c(as.list(environment()), list(...))[-1]
    
    #Adjustments to arguments
    if (is.null(subclass)) disp.subclass <- FALSE
    
    args.with.choices <- names(formals()[-1])[sapply(formals()[-c(1, length(formals()))], function(x) length(x)>1)]
    for (i in seq_along(args.with.choices)) assign(args.with.choices[i], eval(parse(text=paste0("match.arg(", args.with.choices[i], ")"))))
    
    blank.args <- sapply(formals()[-c(1, length(formals()))], function(x) identical(x, quote(expr =)))
    if (any(blank.args)) {
      for (arg.name in names(blank.args)[blank.args]) {
        if (identical(args[[arg.name]], quote(expr = ))) {
          assign(arg.name, NULL)
        }
      }
    }
    
    X <- x2base.data.frame(covs,
                           treat = treat,
                           data = data,
                           weights = weights,
                           distance = distance,
                           subclass = subclass,
                           match.strata = match.strata,
                           addl = addl,
                           s.d.denom = s.d.denom,
                           method = method,
                           cluster = cluster,
                           estimand = estimand,
                           imp = imp,
                           s.weights = s.weights,
                           focal = focal,
                           subset = subset)
    
    if (is_not_null(X$imp)) {
      out <- base.bal.tab.imp(weights=X$weights, 
                              treat=X$treat, 
                              distance=X$distance, 
                              subclass=X$subclass, 
                              covs=X$covs, 
                              call=X$call, 
                              int=int, 
                              addl=X$addl, 
                              continuous=continuous, 
                              binary=binary, 
                              s.d.denom=X$s.d.denom, 
                              m.threshold=m.threshold, 
                              v.threshold=v.threshold, ks.threshold=ks.threshold, 
                              r.threshold=r.threshold,
                              imbalanced.only = imbalanced.only,
                              un=un, 
                              disp.means=disp.means, 
                              disp.v.ratio=disp.v.ratio, disp.ks=disp.ks, 
                              disp.subclass=disp.subclass, 
                              disp.bal.tab = disp.bal.tab,
                              method=X$method, 
                              cluster = X$cluster, 
                              which.cluster = which.cluster, 
                              cluster.summary = cluster.summary, 
                              imp = X$imp,
                              which.imp = which.imp,
                              imp.summary = imp.summary,
                              s.weights = X$s.weights, 
                              abs = abs,
                              quick = quick,
                              ...)
    }
    else if (!is_binary(X$treat) && is.numeric(X$treat)) {
      out <- base.bal.tab.cont(weights=X$weights, 
                               treat = X$treat, 
                               distance = X$distance, 
                               subclass = X$subclass,
                               covs=X$covs, 
                               call=X$call, 
                               int=int, 
                               addl = X$addl, 
                               r.threshold = r.threshold, 
                               imbalanced.only = imbalanced.only,
                               un = un, 
                               disp.subclass=disp.subclass, 
                               disp.bal.tab = disp.bal.tab,
                               method=X$method, 
                               cluster = X$cluster, 
                               which.cluster = which.cluster, 
                               cluster.summary = cluster.summary, 
                               s.weights = X$s.weights, 
                               abs = abs, 
                               quick = quick,
                               ...)
    }
    else if (!is_binary(X$treat) && (is.factor(X$treat) || is.character(X$treat))) {
      out <- base.bal.tab.multi(weights=X$weights, 
                                treat=X$treat, 
                                distance=X$distance, 
                                subclass=X$subclass, 
                                covs=X$covs, 
                                call=X$call, 
                                int=int, 
                                addl=X$addl, 
                                continuous=continuous, 
                                binary=binary, 
                                s.d.denom=X$s.d.denom, 
                                m.threshold=m.threshold, 
                                v.threshold=v.threshold, 
                                ks.threshold=ks.threshold, 
                                imbalanced.only = imbalanced.only,
                                un=un, 
                                disp.means=disp.means, 
                                disp.v.ratio=disp.v.ratio, 
                                disp.ks=disp.ks, 
                                disp.subclass=disp.subclass, 
                                disp.bal.tab = disp.bal.tab,
                                method=X$method, 
                                cluster = X$cluster, 
                                which.cluster = which.cluster, 
                                cluster.summary = cluster.summary, 
                                pairwise = pairwise, focal = focal,
                                which.treat = which.treat,
                                multi.summary = multi.summary,
                                s.weights = X$s.weights, 
                                abs = abs,
                                quick = quick,
                                ...)
    }
    else {
      out <- base.bal.tab(weights=X$weights, 
                          treat=X$treat, 
                          distance=X$distance, 
                          subclass=X$subclass, 
                          covs=X$covs, 
                          call=X$call, 
                          int=int, 
                          addl=X$addl, 
                          continuous=continuous, 
                          binary=binary, 
                          s.d.denom=X$s.d.denom, 
                          m.threshold=m.threshold, 
                          v.threshold=v.threshold, 
                          ks.threshold=ks.threshold, 
                          imbalanced.only = imbalanced.only,
                          un=un, 
                          disp.means=disp.means, 
                          disp.v.ratio=disp.v.ratio, 
                          disp.ks=disp.ks, 
                          disp.subclass=disp.subclass, 
                          disp.bal.tab = disp.bal.tab,
                          method=X$method, 
                          cluster = X$cluster, 
                          which.cluster = which.cluster, 
                          cluster.summary = cluster.summary, 
                          s.weights = X$s.weights, 
                          abs = abs,
                          quick = quick,
                          ...)
    }
    return(out)
  }
  bal.tab.CBPS <- function(cbps, int = FALSE, distance = NULL, addl = NULL, data = NULL, continuous = c("std", "raw"), binary = c("raw", "std"), s.d.denom, m.threshold = NULL, v.threshold = NULL, ks.threshold = NULL, r.threshold = NULL, imbalanced.only = FALSE, un = FALSE, disp.bal.tab = TRUE, disp.means = FALSE, disp.v.ratio = FALSE, disp.ks = FALSE, cluster = NULL, which.cluster = NULL, cluster.summary = TRUE, pairwise = TRUE, focal = NULL, which.treat = NA, multi.summary = TRUE, which.time = NULL, msm.summary = TRUE, s.weights = NULL, abs = FALSE, subset = NULL, quick = FALSE, ...) {
    args <- c(as.list(environment()), list(...))[-1]
    
    #Adjustments to arguments
    args.with.choices <- names(formals()[-1])[sapply(formals()[-c(1, length(formals()))], function(x) length(x)>1)]
    for (i in seq_along(args.with.choices)) assign(args.with.choices[i], eval(parse(text=paste0("match.arg(", args.with.choices[i], ")"))))
    
    blank.args <- sapply(formals()[-c(1, length(formals()))], function(x) identical(x, quote(expr =)))
    if (any(blank.args)) {
      for (arg.name in names(blank.args)[blank.args]) {
        if (identical(args[[arg.name]], quote(expr = ))) {
          assign(arg.name, NULL)
        }
      }
    }
    
    if (any(class(cbps) == "CBMSM")) {
      if (is_not_null(cluster)) stop("Clusters are not yet supported with longitudinal treatments.", call. = FALSE)
      
      #Initializing variables
      X <- x2base.CBMSM(cbps, 
                        s.d.denom = s.d.denom, 
                        distance.list = distance,
                        addl.list = addl,
                        cluster = cluster,
                        s.weights = s.weights,
                        subset = subset,
                        ...)
      
      out <- base.bal.tab.msm(weights=X$weights, 
                              treat.list=X$treat.list, 
                              distance.list=X$distance.list, 
                              covs.list=X$covs.list, 
                              call=X$call, 
                              int=int, 
                              addl.list=X$addl.list, 
                              continuous=continuous, 
                              binary=binary, 
                              s.d.denom=X$s.d.denom, 
                              m.threshold=m.threshold, 
                              v.threshold=v.threshold, 
                              ks.threshold=ks.threshold, 
                              r.threshold = r.threshold,
                              imbalanced.only = imbalanced.only,
                              un=un, 
                              disp.means=disp.means, 
                              disp.v.ratio=disp.v.ratio, 
                              disp.ks=disp.ks, 
                              disp.bal.tab = disp.bal.tab,
                              method=X$method, 
                              pairwise = pairwise, 
                              which.treat = which.treat, 
                              multi.summary = multi.summary, 
                              s.weights = X$s.weights, 
                              which.time = which.time, 
                              msm.summary = msm.summary, 
                              abs = abs,
                              quick = quick, 
                              ...)
    }
    else {
      #Initializing variables
      X <- x2base.CBPS(cbps, 
                       s.d.denom = s.d.denom,
                       distance = distance,
                       addl = addl,
                       cluster = cluster, 
                       use.weights = args$use.weights,
                       s.weights = s.weights,
                       subset = subset)
      
      if (any(class(cbps) == "CBPSContinuous")) {
        out <- base.bal.tab.cont(weights=X$weights, 
                                 treat = X$treat, 
                                 distance = X$distance, 
                                 covs=X$covs, 
                                 call=X$call, 
                                 int=int, 
                                 addl = X$addl, 
                                 r.threshold = r.threshold, 
                                 un = un, 
                                 disp.bal.tab = disp.bal.tab,
                                 method = "weighting", 
                                 cluster = X$cluster, 
                                 which.cluster = which.cluster, 
                                 cluster.summary = cluster.summary, 
                                 s.weights = X$s.weights, 
                                 abs = abs,
                                 quick = quick)
      }
      else if (!is_binary(X$treat)) {
        out <- base.bal.tab.multi(weights=X$weights, 
                                  treat=X$treat, 
                                  distance=X$distance, 
                                  covs=X$covs, 
                                  call=X$call, 
                                  int=int, 
                                  addl=X$addl, 
                                  continuous=continuous, 
                                  binary=binary, 
                                  s.d.denom=X$s.d.denom, 
                                  m.threshold=m.threshold, 
                                  v.threshold=v.threshold, 
                                  ks.threshold=ks.threshold, 
                                  imbalanced.only = imbalanced.only,
                                  un=un, 
                                  disp.means=disp.means, 
                                  disp.v.ratio=disp.v.ratio, 
                                  disp.ks=disp.ks, 
                                  disp.bal.tab = disp.bal.tab,
                                  method="weighting", 
                                  cluster = X$cluster, 
                                  which.cluster = which.cluster, 
                                  cluster.summary = cluster.summary, 
                                  pairwise = pairwise, 
                                  focal = X$focal, #NULL
                                  which.treat = which.treat,
                                  multi.summary = multi.summary,
                                  s.weights = X$s.weights, 
                                  abs = abs,
                                  quick = quick)
      }
      else out <- base.bal.tab(weights=X$weights, 
                               treat=X$treat, 
                               distance=X$distance, 
                               covs=X$covs, 
                               call=X$call, 
                               int=int, 
                               addl=X$addl, 
                               continuous=continuous, 
                               binary=binary, 
                               s.d.denom=X$s.d.denom, 
                               m.threshold=m.threshold, 
                               v.threshold=v.threshold, 
                               ks.threshold=ks.threshold, 
                               imbalanced.only = imbalanced.only,
                               un=un, 
                               disp.means=disp.means, 
                               disp.v.ratio=disp.v.ratio, 
                               disp.ks=disp.ks, 
                               disp.bal.tab = disp.bal.tab,
                               method="weighting", 
                               cluster = X$cluster, 
                               which.cluster = which.cluster, 
                               cluster.summary = cluster.summary,
                               s.weights = s.weights, 
                               abs = abs, 
                               quick = quick)
    }
    return(out)
  }
  bal.tab.ebalance <- function(ebal, formula = NULL, data = NULL, treat = NULL, covs = NULL, int = FALSE, distance = NULL, addl = NULL, continuous = c("std", "raw"), binary = c("raw", "std"), s.d.denom = c("treated", "control", "pooled"), m.threshold = NULL, v.threshold = NULL, ks.threshold = NULL, imbalanced.only = FALSE, un = FALSE, disp.bal.tab = TRUE, disp.means = FALSE, disp.v.ratio = FALSE, disp.ks = FALSE, cluster = NULL, which.cluster = NULL, cluster.summary = TRUE, abs = FALSE, subset = NULL, quick = FALSE, ...) {
    
    args <- c(as.list(environment()), list(...))[-1]
    
    #Adjustments to arguments
    args.with.choices <- names(formals()[-1])[sapply(formals()[-c(1, length(formals()))], function(x) length(x)>1)]
    for (i in seq_along(args.with.choices)) assign(args.with.choices[i], eval(parse(text=paste0("match.arg(", args.with.choices[i], ")"))))
    
    blank.args <- sapply(formals()[-c(1, length(formals()))], function(x) identical(x, quote(expr =)))
    if (any(blank.args)) {
      for (arg.name in names(blank.args)[blank.args]) {
        if (identical(args[[arg.name]], quote(expr = ))) {
          assign(arg.name, NULL)
        }
      }
    }
    
    #Initializing variables
    X <- x2base(ebal, 
                formula = formula,
                data = data, 
                treat = treat,
                covs = covs,
                distance = distance,
                addl = addl,
                cluster = cluster,
                subset = subset)
    
    out <- base.bal.tab(weights=X$weights, 
                        treat=X$treat, 
                        distance=X$distance, 
                        covs=X$covs, 
                        call=X$call, 
                        int=int, 
                        addl=X$addl, 
                        continuous=continuous, 
                        binary=binary, 
                        s.d.denom=s.d.denom, 
                        m.threshold=m.threshold, 
                        v.threshold=v.threshold, 
                        ks.threshold=ks.threshold, 
                        imbalanced.only = imbalanced.only,
                        un=un, 
                        disp.means=disp.means, 
                        disp.v.ratio=disp.v.ratio, 
                        disp.ks=disp.ks, 
                        disp.bal.tab = disp.bal.tab,
                        method=X$method, 
                        cluster = X$cluster, 
                        which.cluster = which.cluster, 
                        cluster.summary = cluster.summary, 
                        abs = abs, 
                        quick = quick)
    return(out)
  }
  bal.tab.ebalance.trim <- bal.tab.ebalance
  bal.tab.optmatch <- function(optmatch, formula = NULL, data = NULL, treat = NULL, covs = NULL, int = FALSE, distance = NULL, addl = NULL, continuous = c("std", "raw"), binary = c("raw", "std"), s.d.denom = c("treated", "control", "pooled"), m.threshold = NULL, v.threshold = NULL, ks.threshold = NULL, imbalanced.only = FALSE, un = FALSE, disp.bal.tab = TRUE, disp.means = FALSE, disp.v.ratio = FALSE, disp.ks = FALSE, cluster = NULL, which.cluster = NULL, cluster.summary = TRUE, abs = FALSE, subset = NULL, quick = FALSE, ...) {
    
    args <- c(as.list(environment()), list(...))[-1]
    
    #Adjustments to arguments
    args.with.choices <- names(formals()[-1])[sapply(formals()[-c(1, length(formals()))], function(x) length(x)>1)]
    for (i in seq_along(args.with.choices)) assign(args.with.choices[i], eval(parse(text=paste0("match.arg(", args.with.choices[i], ")"))))
    
    blank.args <- sapply(formals()[-c(1, length(formals()))], function(x) identical(x, quote(expr =)))
    if (any(blank.args)) {
      for (arg.name in names(blank.args)[blank.args]) {
        if (identical(args[[arg.name]], quote(expr = ))) {
          assign(arg.name, NULL)
        }
      }
    }
    
    #Initializing variables
    X <- x2base.optmatch(optmatch, 
                         formula = formula,
                         data = data, 
                         treat = treat,
                         covs = covs,
                         distance = distance,
                         addl = addl,
                         cluster = cluster,
                         subset = subset)
    
    out <- base.bal.tab(weights=X$weights, 
                        treat=X$treat, 
                        distance=X$distance, 
                        covs=X$covs, 
                        call=X$call, 
                        int=int, 
                        addl=X$addl, 
                        continuous=continuous, 
                        binary=binary, 
                        s.d.denom=s.d.denom, 
                        m.threshold=m.threshold, 
                        v.threshold=v.threshold, ks.threshold=ks.threshold, 
                        imbalanced.only = imbalanced.only,
                        un=un, 
                        disp.means=disp.means, 
                        disp.v.ratio=disp.v.ratio, 
                        disp.ks=disp.ks, 
                        disp.bal.tab = disp.bal.tab,
                        method=X$method, 
                        cluster = X$cluster, 
                        which.cluster = which.cluster, 
                        cluster.summary = cluster.summary, 
                        abs = abs, 
                        quick = quick)
    return(out)
  }
  bal.tab.weightit <- function(weightit, int = FALSE, distance = NULL, addl = NULL, data = NULL,  continuous = c("std", "raw"), binary = c("raw", "std"), s.d.denom, m.threshold = NULL, v.threshold = NULL, ks.threshold = NULL, r.threshold = NULL, imbalanced.only = FALSE, un = FALSE, disp.bal.tab = TRUE, disp.means = FALSE, disp.v.ratio = FALSE, disp.ks = FALSE, cluster = NULL, which.cluster = NULL, cluster.summary = TRUE, imp = NULL, which.imp = NA, imp.summary = TRUE, which.treat = NA, pairwise = TRUE, focal = NULL, multi.summary = TRUE, which.time = NULL, msm.summary = TRUE, abs = FALSE, subset = NULL, quick = FALSE, ... ) {
    args <- c(as.list(environment()), list(...))[-1]
    
    #Adjustments to arguments
    args.with.choices <- names(formals()[-1])[sapply(formals()[-c(1, length(formals()))], function(x) length(x)>1)]
    for (i in seq_along(args.with.choices)) assign(args.with.choices[i], eval(parse(text=paste0("match.arg(", args.with.choices[i], ")"))))
    
    blank.args <- sapply(formals()[-c(1, length(formals()))], function(x) identical(x, quote(expr =)))
    if (any(blank.args)) {
      for (arg.name in names(blank.args)[blank.args]) {
        if (identical(args[[arg.name]], quote(expr = ))) {
          assign(arg.name, NULL)
        }
      }
    }
    
    if (any(class(weightit) == "weightitMSM")) {
      if (is_not_null(cluster)) stop("Clusters are not yet supported with longitudinal treatments.", call. = FALSE)
      if (is_not_null(imp)) stop("Multiply imputed data is not yet supported with longitudinal treatments.", call. = FALSE)
      if (is_not_null(args$addl.list)) addl <- args$addl.list
      
      #Initializing variables
      X <- x2base.weightitMSM(weightit, 
                              s.d.denom = s.d.denom, 
                              distance.list = distance,
                              addl.list = addl,
                              cluster = cluster,
                              data = data,
                              subset = subset,
                              ...)
      
      out <- base.bal.tab.msm(weights=X$weights, 
                              treat.list=X$treat.list, 
                              distance.list=X$distance.list, 
                              covs.list=X$covs.list, 
                              call=X$call, 
                              int=int, 
                              addl.list=X$addl.list, 
                              continuous=continuous, 
                              binary=binary, 
                              s.d.denom=X$s.d.denom, 
                              m.threshold=m.threshold, 
                              v.threshold=v.threshold, 
                              ks.threshold=ks.threshold, 
                              r.threshold=r.threshold,
                              imbalanced.only = imbalanced.only,
                              un=un, 
                              disp.means=disp.means, 
                              disp.v.ratio=disp.v.ratio, 
                              disp.ks=disp.ks, 
                              disp.bal.tab = disp.bal.tab,
                              method=X$method, 
                              cluster = X$cluster, 
                              which.cluster = which.cluster, 
                              cluster.summary = cluster.summary, 
                              pairwise = pairwise, 
                              focal = focal, 
                              which.treat = which.treat, 
                              multi.summary = multi.summary, 
                              s.weights = X$s.weights, 
                              which.time = which.time, 
                              msm.summary = msm.summary, 
                              abs = abs,
                              quick = quick, 
                              ...)
    }
    else {
      #Initializing variables
      X <- x2base.weightit(weightit, 
                           data = data, 
                           s.d.denom = s.d.denom,
                           distance = distance, 
                           addl = addl, 
                           cluster = cluster, 
                           imp = imp,
                           subset = subset)
      
      if (is_not_null(X$imp)) {
        out <- base.bal.tab.imp(weights=X$weights, 
                                treat=X$treat, 
                                distance=X$distance, 
                                subclass=NULL, 
                                covs=X$covs, 
                                call=X$call, 
                                int=int, 
                                addl=X$addl, 
                                continuous=continuous, 
                                binary=binary, 
                                s.d.denom=X$s.d.denom, 
                                m.threshold=m.threshold, 
                                v.threshold=v.threshold, 
                                ks.threshold=ks.threshold, 
                                r.threshold=r.threshold,
                                imbalanced.only = imbalanced.only,
                                un=un, 
                                disp.means=disp.means, 
                                disp.v.ratio=disp.v.ratio, 
                                disp.ks=disp.ks, 
                                disp.subclass=FALSE, 
                                disp.bal.tab = disp.bal.tab,
                                method=X$method, 
                                cluster = X$cluster, 
                                which.cluster = which.cluster, 
                                cluster.summary = cluster.summary, 
                                imp = X$imp,
                                which.imp = which.imp,
                                imp.summary = imp.summary,
                                s.weights = X$s.weights, 
                                abs = abs,
                                discarded = X$discarded, 
                                quick = quick,
                                ...)
      }
      else if (isTRUE(weightit$treat.type == "binary") || isTRUE(attr(weightit$treat, "treat.type") == "binary")) {
        out <- base.bal.tab(weights=X$weights, 
                            treat=X$treat, 
                            distance=X$distance, 
                            subclass=NULL, 
                            covs=X$covs, 
                            call=X$call, 
                            int=int, 
                            addl=X$addl, 
                            continuous=continuous, 
                            binary=binary, 
                            s.d.denom=X$s.d.denom, 
                            m.threshold=m.threshold, 
                            v.threshold=v.threshold, 
                            ks.threshold=ks.threshold, 
                            imbalanced.only = imbalanced.only,
                            un=un, 
                            disp.means=disp.means, 
                            disp.v.ratio=disp.v.ratio, 
                            disp.ks=disp.ks, 
                            disp.subclass=FALSE, 
                            disp.bal.tab = disp.bal.tab,
                            method = X$method, 
                            cluster = X$cluster, 
                            which.cluster = which.cluster, 
                            cluster.summary = cluster.summary, 
                            s.weights = X$s.weights, 
                            abs = abs, 
                            discarded = X$discarded, 
                            quick = quick)
      }
      else if (isTRUE(weightit$treat.type == "multinomial") || isTRUE(attr(weightit$treat, "treat.type") == "multinomial")) {
        out <- base.bal.tab.multi(weights=X$weights, treat=X$treat, distance=X$distance, 
                                  covs=X$covs, call=X$call, int=int, addl=X$addl, 
                                  continuous=continuous, binary=binary, s.d.denom=X$s.d.denom, 
                                  m.threshold=m.threshold, v.threshold=v.threshold, 
                                  ks.threshold=ks.threshold, 
                                  imbalanced.only = imbalanced.only,
                                  un=un, 
                                  disp.bal.tab = disp.bal.tab, 
                                  disp.means=disp.means,
                                  disp.v.ratio=disp.v.ratio, 
                                  disp.ks=disp.ks, 
                                  method=X$method, 
                                  cluster = X$cluster, which.cluster = which.cluster, 
                                  cluster.summary = cluster.summary, pairwise = pairwise, focal = X$focal,
                                  which.treat = which.treat, multi.summary = multi.summary,
                                  s.weights = X$s.weights, 
                                  abs = abs, 
                                  quick = quick)
      }
      else if (isTRUE(weightit$treat.type == "continuous") || isTRUE(attr(weightit$treat, "treat.type") == "continuous")) {
        out <- base.bal.tab.cont(weights=X$weights, treat = X$treat, distance = X$distance, 
                                 covs=X$covs, call=X$call, int=int, addl = X$addl, 
                                 r.threshold = r.threshold, 
                                 imbalanced.only = imbalanced.only,
                                 un=un, 
                                 disp.bal.tab = disp.bal.tab,
                                 method = X$method, 
                                 cluster = X$cluster, 
                                 which.cluster = which.cluster, 
                                 cluster.summary = cluster.summary, 
                                 s.weights = X$s.weights, 
                                 abs = abs, 
                                 quick = quick)
      }
      else stop("Something went wrong. Contact the maintainer.", call. = FALSE)
    }
    
    return(out)
  }
  bal.tab.designmatch <- function(dm, formula = NULL, data = NULL, treat = NULL, covs = NULL, int = FALSE, distance = NULL, addl = NULL, continuous = c("std", "raw"), binary = c("raw", "std"), s.d.denom = c("treated", "control", "pooled"), m.threshold = NULL, v.threshold = NULL, ks.threshold = NULL, imbalanced.only = FALSE, un = FALSE, disp.bal.tab = TRUE, disp.means = FALSE, disp.v.ratio = FALSE, disp.ks = FALSE, cluster = NULL, which.cluster = NULL, cluster.summary = TRUE, abs = FALSE, subset = NULL, quick = FALSE, ...) {
    
    args <- c(as.list(environment()), list(...))[-1]
    
    #Adjustments to arguments
    args.with.choices <- names(formals()[-1])[sapply(formals()[-c(1, length(formals()))], function(x) length(x)>1)]
    for (i in seq_along(args.with.choices)) assign(args.with.choices[i], eval(parse(text=paste0("match.arg(", args.with.choices[i], ")"))))
    
    blank.args <- sapply(formals()[-c(1, length(formals()))], function(x) identical(x, quote(expr =)))
    if (any(blank.args)) {
      for (arg.name in names(blank.args)[blank.args]) {
        if (identical(args[[arg.name]], quote(expr = ))) {
          assign(arg.name, NULL)
        }
      }
    }
    
    #Initializing variables
    X <- x2base.designmatch(dm, 
                            formula = formula,
                            data = data, 
                            treat = treat,
                            covs = covs,
                            distance = distance,
                            addl = addl,
                            cluster = cluster,
                            subset = subset)
    
    out <- base.bal.tab(weights=X$weights, 
                        treat=X$treat, 
                        distance=X$distance, 
                        covs=X$covs, 
                        call=X$call, 
                        int=int, 
                        addl=X$addl, 
                        continuous=continuous, 
                        binary=binary, 
                        s.d.denom=s.d.denom, 
                        m.threshold=m.threshold, 
                        v.threshold=v.threshold, ks.threshold=ks.threshold, 
                        imbalanced.only = imbalanced.only,
                        un=un, 
                        disp.means=disp.means, 
                        disp.v.ratio=disp.v.ratio, 
                        disp.ks=disp.ks, 
                        disp.bal.tab = disp.bal.tab,
                        method=X$method, 
                        cluster = X$cluster, 
                        which.cluster = which.cluster, 
                        cluster.summary = cluster.summary, 
                        abs = abs, 
                        quick = quick)
    return(out)
  }
  
  #MSMs wth multiple time points
  bal.tab.list <- function(list_, data, treat.list = NULL, weights = NULL, int = FALSE, distance.list = NULL, addl.list = NULL, method, continuous = c("std", "raw"), binary = c("raw", "std"), s.d.denom, m.threshold = NULL, v.threshold = NULL, ks.threshold = NULL, r.threshold = NULL, imbalanced.only = FALSE, un = FALSE, disp.bal.tab = TRUE, disp.means = FALSE, disp.v.ratio = FALSE, disp.ks = FALSE, pairwise = TRUE, which.treat = NA, multi.summary = TRUE, which.time = NULL, msm.summary = TRUE, s.weights = NULL, estimand = "ATE", abs = FALSE, subset = NULL, quick = FALSE, ...) {
    args <- c(as.list(environment()), list(...))[-1]
    
    #Adjustments to arguments
    args.with.choices <- names(formals()[-1])[sapply(formals()[-c(1, length(formals()))], function(x) length(x)>1)]
    for (i in seq_along(args.with.choices)) assign(args.with.choices[i], eval(parse(text=paste0("match.arg(", args.with.choices[i], ")"))))
    
    blank.args <- sapply(formals()[-c(1, length(formals()))], function(x) identical(x, quote(expr =)))
    if (any(blank.args)) {
      for (arg.name in names(blank.args)[blank.args]) {
        if (identical(args[[arg.name]], quote(expr = ))) {
          assign(arg.name, NULL)
        }
      }
    }
    
    if (is_not_null(args$cluster)) stop("Clusters are not yet supported with longitudinal treatments.", call. = FALSE)
    if (is_not_null(args$imp)) stop("Multiply imputed data is not yet supported with longitudinal treatments.", call. = FALSE)
    
    if (all(sapply(list_, is.formula))) {
      X <- x2base.formula.list(formula.list = list_, 
                               data = data,
                               weights = weights,
                               distance.list = distance.list,
                               addl.list = addl.list,
                               method = method,
                               s.d.denom = s.d.denom,
                               s.weights = s.weights,
                               estimand = estimand,
                               subset = subset)
    }
    else if (all(sapply(list_, is.data.frame))) {
      X <- x2base.data.frame.list(covs.list = list_, 
                                  treat.list = treat.list,
                                  data = data,
                                  weights = weights,
                                  distance.list = distance.list,
                                  addl.list = addl.list,
                                  method = method,
                                  s.d.denom = s.d.denom,
                                  s.weights = s.weights,
                                  estimand = estimand)
    }
    else {
      stop("If the first argument is a list, it must be a list of formulas specifying the treatment/covariate relationships at each time point or a list of data frames containing covariates to be assessed at each time point.", call. = FALSE)
    }
    
    out <- base.bal.tab.msm(weights=X$weights, 
                            treat.list=X$treat.list, 
                            distance.list=X$distance.list, 
                            covs.list=X$covs.list, 
                            call=X$call, 
                            int=int, 
                            addl.list=X$addl.list, 
                            continuous=continuous, 
                            binary=binary, 
                            s.d.denom=X$s.d.denom, 
                            m.threshold=m.threshold, 
                            v.threshold=v.threshold, 
                            ks.threshold=ks.threshold, 
                            r.threshold = r.threshold,
                            imbalanced.only = imbalanced.only,
                            un=un, 
                            disp.means=disp.means, 
                            disp.v.ratio=disp.v.ratio, 
                            disp.ks=disp.ks, 
                            disp.bal.tab = disp.bal.tab,
                            method=X$method, 
                            cluster = NULL, 
                            which.cluster = NULL, 
                            cluster.summary = FALSE, 
                            pairwise = pairwise, 
                            focal = NULL, 
                            which.treat = which.treat, 
                            multi.summary = multi.summary, 
                            s.weights = X$s.weights, 
                            which.time = which.time, 
                            msm.summary = msm.summary, 
                            abs = abs,
                            quick = quick, 
                            ...)
    return(out)
  }
  bal.tab.iptw <- function(iptw, stop.method, int = FALSE, distance.list = NULL, addl.list = NULL, data = NULL, continuous = c("std", "raw"), binary = c("raw", "std"), s.d.denom, m.threshold = NULL, v.threshold = NULL, ks.threshold = NULL, imbalanced.only = FALSE, un = FALSE, disp.bal.tab = TRUE, disp.means = FALSE, disp.v.ratio = FALSE, disp.ks = FALSE, pairwise = TRUE, which.treat = NA, multi.summary = TRUE, which.time = NULL, msm.summary = TRUE, abs = FALSE, subset = NULL, quick = FALSE, ...) {
    args <- as.list(environment())[-1]
    
    #Adjustments to arguments
    args.with.choices <- names(formals()[-1])[sapply(formals()[-c(1, length(formals()))], function(x) length(x)>1)]
    for (i in seq_along(args.with.choices)) assign(args.with.choices[i], eval(parse(text=paste0("match.arg(", args.with.choices[i], ")"))))
    
    blank.args <- sapply(formals()[-c(1, length(formals()))], function(x) identical(x, quote(expr =)))
    if (any(blank.args)) {
      for (arg.name in names(blank.args)[blank.args]) {
        if (identical(args[[arg.name]], quote(expr = ))) {
          assign(arg.name, NULL)
        }
      }
    }
    
    if (is_not_null(args$cluster)) stop("Clusters are not yet supported with longitudinal treatments.", call. = FALSE)
    
    #Initializing variables
    X <- x2base.iptw(iptw, 
                     stop.method = stop.method, 
                     s.d.denom = s.d.denom, 
                     distance.list = distance.list,
                     addl.list = addl.list,
                     subset = subset,
                     ...)
    
    out <- base.bal.tab.msm(weights=X$weights, 
                            treat.list=X$treat.list, 
                            distance.list=X$distance.list, 
                            covs.list=X$covs.list, 
                            call=X$call, 
                            int=int, 
                            addl.list=X$addl.list, 
                            continuous=continuous, 
                            binary=binary, 
                            s.d.denom=X$s.d.denom, 
                            m.threshold=m.threshold, 
                            v.threshold=v.threshold, 
                            ks.threshold=ks.threshold, 
                            imbalanced.only = imbalanced.only,
                            un=un, 
                            disp.means=disp.means, 
                            disp.v.ratio=disp.v.ratio, 
                            disp.ks=disp.ks, 
                            disp.bal.tab = disp.bal.tab,
                            method=X$method, 
                            pairwise = pairwise, 
                            #focal = focal, 
                            which.treat = which.treat, 
                            multi.summary = multi.summary, 
                            s.weights = X$s.weights, 
                            which.time = which.time, 
                            msm.summary = msm.summary, 
                            abs = abs,
                            quick = quick, 
                            ...)
    return(out)
  }
  bal.tab.CBMSM <- bal.tab.CBPS
  love.plot <- function(x, stat = c("mean.diffs", "variance.ratios", "ks.statistics"), threshold = NULL, 
                        abs = TRUE, var.order = NULL, no.missing = TRUE, var.names = NULL, 
                        drop.distance = FALSE, agg.fun = c("mean", "median", "max", "range"), 
                        colors = NULL, shapes = NULL, line = FALSE, ...) {
    b <- x; rm(x)
    if ("bal.tab" %nin% class(b)) stop("The first argument must be a bal.tab object, the output of a call to bal.tab().")
    if (any(class(b) == "bal.tab.cont")) stat <- "correlation"
    else stat <- match.arg(stat)
    
    args <- list(...)
    #size
    #shape (deprecated)
    #un.color (deprecated)
    #adj.color (deprecated)
    #title
    #subtitle
    #sample.names
    #limits
    #cluster.fun (deprecated)
    
    p.ops <- c("which.cluster", "which.imp", "which.treat", "which.time", "disp.subclass")
    for (i in p.ops) {
      if (i %in% names(args)) b$print.options[[i]] <- args[[i]]
    }
    
    null.threshold <- is.null(threshold)
    if (!null.threshold) {
      if (!is.numeric(threshold) || length(threshold) > 1) stop("threshold must be a single number.", call. = FALSE)
    }
    
    if (is_not_null(args$cluster.fun)) agg.fun <- args$cluster.fun
    which.stat <- switch(stat, mean.diffs = "Diff", variance.ratios = "V.Ratio", ks.statistics = "KS", correlation = "Corr")
    which.stat2 <- switch(stat, mean.diffs = "Mean Difference", variance.ratios = "Variance Ratio", ks.statistics = "Kolmogorov-Smirnov Statistic", correlation = "Correlation")
    Agg.Fun <- NULL
    subtitle <- NULL
    title <- "Covariate Balance"
    
    facet <- NULL
    
    cluster.names.good <- NULL
    imp.numbers.good <- NULL
    treat.names.good <- NULL; disp.treat.pairs <- NULL
    time.names.good <- NULL
    subclass.names <- NULL
    
    #NA = aggregate, NULL = individual
    null.cluster <- is.null(b$print.options$which.cluster)
    na.cluster <- !null.cluster && is.na(b$print.options$which.cluster)
    null.imp <- is.null(b$print.options$which.imp)
    na.imp <- !null.imp && is.na(b$print.options$which.imp)
    null.treat <- is.null(b$print.options$which.treat)
    na.treat <- !null.treat && is.na(b$print.options$which.treat)
    null.time <- is.null(b$print.options$which.time)
    na.time <- !null.time && is.na(b$print.options$which.time)
    
    config <- "agg.none"
    
    if (any(class(b) == "bal.tab.msm")) {
      #Get time.names.good
      time.names <- names(b[["Time.Balance"]])
      if (na.time) {
        config <- "agg.time"
        time.names.good <- NULL
      }
      else if (null.time) {
        config <- "agg.none"
        time.names.good <- setNames(rep(TRUE, length(time.names)), time.names)
      }
      else if (is.character(b$print.options$which.time)) {
        time.names.good <- sapply(time.names, function(x) any(sapply(b$print.options$which.time, function(y) identical(x, y))))
        if (any(time.names.good)) {
          config <- "agg.none"
        }
        else {
          stop("Make sure the arguments to which.time are valid treatment names or time point indices.", call. = FALSE)
        }
      }
      else if (is.numeric(b$print.options$which.time)) {
        time.names.good <- setNames(seq_along(b$Time.Balance) %in% b$print.options$which.time, time.names)
        if (any(time.names.good)) {
          config <- "agg.none"
        }
        else {
          stop("Make sure the arguments to which.time are valid treatment names or time point indices.", call. = FALSE)
        }
      }
      else stop("The argument to which.time must be NULL, NA, or the names of treatments or indices of time points.", call. = FALSE)
      
      
      #Get B from b
      if (config == "agg.none") {
        B <- do.call("rbind", lapply(names(b[["Time.Balance"]])[time.names.good], 
                                     function(x) cbind(b[["Time.Balance"]][[x]][["Balance"]],
                                                       time = x,
                                                       var.names = rownames(b[["Time.Balance"]][[x]][["Balance"]]))))
        facet <- "time"
      }
      else if (config == "agg.time") {
        if (is.null(b[["Balance.Across.Times"]])) {
          stop("Cannot aggregate across time periods without a balance summary across time periods.\nThis may be because multinomial treatments were used, multiple treatment types were used,\n or quick was set to TRUE and msm.summary set to FALSE in the original bal.tab() call.", call. = FALSE)
        }
        #Agg.Fun <- switch(match.arg(agg.fun), mean = "Mean", median = "Median", max = "Max", range = "Range")
        Agg.Fun <- "Max"
        if (Agg.Fun == "Range") {
          subtitle <- paste0(which.stat2, " Range Across Time Points")
        }
        else {
          subtitle <- paste(ifelse(Agg.Fun == "Mean", "Average", Agg.Fun), which.stat2, "Across Time Points")
        }
        B <- cbind(b[["Balance.Across.Times"]],
                   var.names = rownames(b[["Balance.Across.Times"]]))
      }
    }
    else if (any(class(b) == "bal.tab.imp.cluster")) {
      #Get imp.numbers.good
      imp.numbers <- seq_along(b[["Imputation.Balance"]])
      if (na.imp) {
        imp.numbers.good <- NULL
      }
      else if (null.imp) {
        imp.numbers.good <- setNames(rep(TRUE, length(imp.numbers)), imp.numbers)
      }
      else if (is.numeric(b$print.options$which.imp)) {
        imp.numbers.good <- setNames(imp.numbers %in% b$print.options$which.imp, imp.numbers)
      }
      else stop("The argument to which.imp must be NULL, NA, or the indices of imputations.", call. = FALSE)
      
      #Get cluster.names.good
      cluster.names <- names(b[["Cluster.Balance.Across.Imputations"]])
      if (na.cluster) {
        cluster.names.good <- NULL
      }
      else if (null.cluster) {
        cluster.names.good <- setNames(rep(TRUE, length(cluster.names)), cluster.names)
      }
      else if (is.character(b$print.options$which.cluster)) {
        cluster.names.good <- sapply(cluster.names, function(x) any(sapply(b$print.options$which.cluster, function(y) identical(x, y))))
      }
      else if (is.numeric(b$print.options$which.cluster)) {
        cluster.names.good <- setNames(seq_along(b$Cluster.Balance) %in% b$print.options$which.cluster, cluster.names)
      }
      else stop("The argument to which.cluster must be NULL, NA, or the names or indices of clusters.", call. = FALSE)
      
      #Set configuration type of B using which.imp and which.cluster
      if (na.imp) { #aggregate over all imps
        if (na.cluster) {
          config <- "agg.all"
        }
        else { #1, #6
          if (any(cluster.names.good)) {
            config <- "agg.imp"
          }
          else {
            stop("Make sure the arguments to which.cluster are valid names or indices of clusters.", call. = FALSE)
          }
          
        }
      }
      else if (sum(imp.numbers.good) == 1) {
        if (na.cluster) {
          config <- "agg.cluster"
        }
        else { 
          if (any(cluster.names.good)) {
            config <- "agg.none"
          }
          else {
            stop("Make sure the arguments to which.cluster are valid names or indices of clusters.", call. = FALSE)
          }
        }
      }
      else if (sum(imp.numbers.good) > 1) {
        if (na.cluster) {
          config <- "agg.cluster"
        }
        else if (sum(cluster.names.good) == 1) {
          config <- "agg.none"
        }
        else {
          stop("At least one of which.cluster or which.imp must be NA or of length 1.", call. = FALSE)
        }
      }
      else {
        stop("Make sure the arguments to which.imp are valid imputation indices.", call. = FALSE)
      }
      
      #Get B from b based on configuration
      if (config == "agg.none") {
        B <- do.call("rbind", lapply(names(b[["Imputation.Balance"]])[imp.numbers.good],
                                     function(x) do.call("rbind", lapply(names(b[["Imputation.Balance"]][[x]][["Cluster.Balance"]])[cluster.names.good],
                                                                         function(y) cbind(b[["Imputation.Balance"]][[x]][["Cluster.Balance"]][[y]][["Balance"]],
                                                                                           cluster = y,
                                                                                           imp = paste("Imputation:", x),
                                                                                           var.names = rownames(b[["Imputation.Balance"]][[x]][["Cluster.Balance"]][[y]][["Balance"]]))))))
        if (sum(imp.numbers.good) == 1) {
          facet <- "cluster"
          subtitle <- paste("Imputation:", imp.numbers[imp.numbers.good])
        }
        else {
          facet <- "imp"
          subtitle <- paste("Cluster:", cluster.names[cluster.names.good])
        }
      }
      else if (config == "agg.imp") {
        if (is.null(b[["Cluster.Balance.Across.Imputations"]])) {
          stop("Cannot aggregate across imputations without a balance summary across imputations.\nThis may be because quick was set to TRUE and imp.summary set to FALSE in the original bal.tab() call.", call. = FALSE)
        }
        Agg.Fun <- switch(tolower(match.arg(agg.fun)), mean = "Mean", median = "Median", max = "Max", range = "Range")
        if (Agg.Fun == "Median") {
          warning("The median is being deprecated. Using the mean instead.", call. = FALSE)
          Agg.Fun <- "Mean"
        }
        if (Agg.Fun == "Range") {
          subtitle <- paste0(which.stat2, " Range Across Imputations")
        }
        else {
          subtitle <- paste(ifelse(Agg.Fun == "Mean", "Average", Agg.Fun), which.stat2, "Across Imputations", sep = " ")
        }
        B <- do.call("rbind", lapply(names(b[["Cluster.Balance.Across.Imputations"]])[cluster.names.good], 
                                     function(x) cbind(b[["Cluster.Balance.Across.Imputations"]][[x]][["Cluster.Balance"]], 
                                                       cluster = x, 
                                                       var.names = rownames(b[["Cluster.Balance.Across.Imputations"]][[x]][["Cluster.Balance"]]))))
        facet <- "cluster"
      }
      else if (config == "agg.cluster") {
        if (is.null(b[["Imputation.Balance"]][[1]][["Cluster.Summary"]])) {
          stop("Cannot aggregate across clusters without a balance summary across clusters.\nThis may be because quick was set to TRUE and cluster.summary set to FALSE in the original bal.tab() call.", call. = FALSE)
        }
        Agg.Fun <- switch(tolower(match.arg(agg.fun)), mean = "Mean", median = "Median", max = "Max", range = "Range")
        if (Agg.Fun == "Median") {
          warning("agg.fun = \"median\" is being deprecated. Using \"mean\" instead.", call. = FALSE)
          Agg.Fun <- "Mean"
        }
        if (Agg.Fun == "Range") {
          subtitle <- paste0(which.stat2, " Range Across Clusters")
        }
        else {
          subtitle <- paste(ifelse(Agg.Fun == "Mean", "Average", Agg.Fun), which.stat2, "Across Clusters", sep = " ")
        }
        B <- do.call("rbind", lapply(names(b[["Imputation.Balance"]])[imp.numbers.good], 
                                     function(x) cbind(b[["Imputation.Balance"]][[x]][["Cluster.Summary"]], 
                                                       imp = paste("Imputation:", x), 
                                                       var.names = rownames(b[["Imputation.Balance"]][[x]][["Cluster.Summary"]]))))
        facet <- "imp"
      }
      else if (config == "agg.all") {
        if (is.null(b[["Balance.Across.Imputations"]])) {
          stop("Cannot aggregate across imputations without a balance summary across imputations.\nThis may be because quick was set to TRUE and cluster.summary or imp.summary were set to FALSE in the original bal.tab() call.", call. = FALSE)
        }
        #Cluster.Fun <- switch(match.arg(cluster.fun), mean = "Mean", median = "Median", max = "Max", range = "Range")
        Agg.Fun <- switch(tolower(match.arg(agg.fun)), mean = "Mean", median = "Median", max = "Max", range = "Range")
        if (Agg.Fun == "Median") {
          warning("The median is being deprecated. Using the mean instead.", call. = FALSE)
          Agg.Fun <- "Mean"
        }
        if (Agg.Fun == "Range") {
          subtitle <- paste0(which.stat2, " Range Across Clusters and Imputations")
        }
        else {
          subtitle <- paste(ifelse(Agg.Fun == "Mean", "Average", Agg.Fun), which.stat2, "Across Clusters and Imputations", sep = " ")
        }
        B <- cbind(b[["Balance.Across.Imputations"]],
                   var.names = row.names(b[["Balance.Across.Imputations"]]))
        facet <- NULL
      }
    }
    else if (any(class(b) == "bal.tab.imp")) {
      #Get imp.numbers.good
      imp.numbers <- seq_along(b[["Imputation.Balance"]])
      if (na.imp) {
        config <- "agg.imp"
        imp.numbers.good <- NULL
      }
      else if (null.imp) {
        config <- "agg.none"
        imp.numbers.good <- setNames(rep(TRUE, length(imp.numbers)), imp.numbers)
      }
      else if (is.numeric(b$print.options$which.imp)) {
        imp.numbers.good <- setNames(imp.numbers %in% b$print.options$which.imp, imp.numbers)
        if (any(imp.numbers.good)) {
          config <- "agg.none"
        }
        else {
          stop("Make sure the arguments to which.imp are valid imputation indices.", call. = FALSE)
        }
      }
      else stop("The argument to which.imp must be NULL, NA, or the indices of imputations.", call. = FALSE)
      
      #Get B from b
      if (config == "agg.none") {
        B <- do.call("rbind", lapply(names(b[["Imputation.Balance"]])[imp.numbers.good], 
                                     function(x) cbind(b[["Imputation.Balance"]][[x]][["Balance"]],
                                                       imp = paste("Imputation:", x),
                                                       var.names = rownames(b[["Imputation.Balance"]][[x]][["Balance"]]))))
        facet <- "imp"
      }
      else if (config == "agg.imp") {
        if (is.null(b[["Balance.Across.Imputations"]])) {
          stop("Cannot aggregate across imputations without a balance summary across imputations.\nThis may be because quick was set to TRUE and imp.summary set to FALSE in the original bal.tab() call.", call. = FALSE)
        }
        Agg.Fun <- switch(tolower(match.arg(agg.fun)), mean = "Mean", median = "Median", max = "Max", range = "Range")
        if (Agg.Fun == "Median") {
          warning("The median is being deprecated. Using the mean instead.", call. = FALSE)
          Agg.Fun <- "Mean"
        }
        if (Agg.Fun == "Range") {
          subtitle <- paste0(which.stat2, " Range Across Imputations")
        }
        else {
          subtitle <- paste(ifelse(Agg.Fun == "Mean", "Average", Agg.Fun), which.stat2, "Across Imputations")
        }
        B <- cbind(b[["Balance.Across.Imputations"]],
                   var.names = rownames(b[["Balance.Across.Imputations"]]))
      }
    }
    else if (any(class(b) == "bal.tab.cluster")) {
      #Get cluster.names.good
      cluster.names <- names(b[["Cluster.Balance"]])
      if (na.cluster) {
        config <- "agg.cluster"
        cluster.names.good <- NULL
      }
      else if (null.cluster) {
        config <- "agg.none"
        cluster.names.good <- setNames(rep(TRUE, length(cluster.names)), cluster.names)
      }
      else if (is.character(b$print.options$which.cluster)) {
        cluster.names.good <- sapply(cluster.names, function(x) any(sapply(b$print.options$which.cluster, function(y) identical(x, y))))
        if (any(cluster.names.good)) {
          config <- "agg.none"
        }
        else {
          stop("Make sure the arguments to which.cluster are valid cluster names or indices.", call. = FALSE)
        }
      }
      else if (is.numeric(b$print.options$which.cluster)) {
        cluster.names.good <- setNames(seq_along(b$Cluster.Balance) %in% b$print.options$which.cluster, cluster.names)
        if (any(cluster.names.good)) {
          config <- "agg.none"
        }
        else {
          stop("Make sure the arguments to which.cluster are valid cluster names or indices.", call. = FALSE)
        }
      }
      else stop("The argument to which.cluster must be NULL, NA, or the names or indices of clusters.", call. = FALSE)
      
      
      #Get B from b
      if (config == "agg.none") {
        B <- do.call("rbind", lapply(names(b[["Cluster.Balance"]])[cluster.names.good], 
                                     function(x) cbind(b[["Cluster.Balance"]][[x]][["Balance"]],
                                                       cluster = x,
                                                       var.names = rownames(b[["Cluster.Balance"]][[x]][["Balance"]]))))
        facet <- "cluster"
      }
      else if (config == "agg.cluster") {
        if (is.null(b[["Cluster.Summary"]])) {
          stop("Cannot aggregate across clusters without a balance summary across clusters.\nThis may be because quick was set to TRUE and cluster.summary set to FALSE in the original bal.tab() call.", call. = FALSE)
        }
        
        tryCatch({agg.fun <- tolower(match.arg(agg.fun))}, 
                 error = function(e) stop("agg.fun should be one of \"mean\", \"max\", or \"range\".", call. = FALSE))
        Agg.Fun <- switch(agg.fun, mean = "Mean", median = "Median", max = "Max", range = "Range")
        if (Agg.Fun == "Median") {
          warning("The median is deprecated. Using the mean instead.", call. = FALSE)
          Agg.Fun <- "Mean"
        }
        if (Agg.Fun == "Range") {
          subtitle <- paste0(which.stat2, " Range Across Clusters")
        }
        else {
          subtitle <- paste(ifelse(Agg.Fun == "Mean", "Average", Agg.Fun), which.stat2, "Across Clusters")
        }
        B <- cbind(b[["Cluster.Summary"]],
                   var.names = rownames(b[["Cluster.Summary"]]))
      }
    }
    else if (any(class(b) == "bal.tab.multi")) {
      #Get cluster.names.good
      treat.names <- b$print.options$treat.names
      if (na.treat) {
        config <- "agg.pair"
        treat.names.good <- NULL
      }
      else if (null.treat) {
        config <- "agg.none"
        treat.names.good <- rep(TRUE, length(treat.names))
      }
      else if (is.character(b$print.options$which.treat)) {
        treat.names.good <- treat.names %in% b$print.options$which.treat
        if (any(treat.names.good)) {
          config <- "agg.none"
        }
        else {
          stop("Make sure the arguments to which.treat are valid treatment names or indices.", call. = FALSE)
        }
      }
      else if (is.numeric(b$print.options$which.treat)) {
        treat.names.good <- seq_along(treat.names) %in% b$print.options$which.treat
        if (any(treat.names.good)) {
          config <- "agg.none"
        }
        else {
          stop("Make sure the arguments to which.cluster are valid cluster names or indices.", call. = FALSE)
        }
      }
      else stop("The argument to which.cluster must be NULL, NA, or the names or indices of clusters.", call. = FALSE)
      
      
      if (na.treat) {
        disp.treat.pairs <- character(0)
      }
      else {
        if (b$print.options$pairwise) {
          if (sum(treat.names.good) == 1) {
            disp.treat.pairs <- names(b[["Pair.Balance"]])[sapply(names(b[["Pair.Balance"]]), function(x) any(b[["Pair.Balance"]][[x]]$print.options$treat.names == b$print.options$treat.names[treat.names.good]))]
          }
          else {
            disp.treat.pairs <- names(b[["Pair.Balance"]])[sapply(names(b[["Pair.Balance"]]), function(x) all(b[["Pair.Balance"]][[x]]$print.options$treat.names %in% b$print.options$treat.names[treat.names.good]))]
          }
        }
        else {
          if (sum(treat.names.good) == 1) {
            disp.treat.pairs <- names(b[["Pair.Balance"]])[sapply(names(b[["Pair.Balance"]]), function(x) {
              treat.names <- b[["Pair.Balance"]][[x]]$print.options$treat.namestreat.names
              any(treat.names[treat.names != "Others"] == b$print.options$treat.names[treat.names.good])})]
          }
          else {
            disp.treat.pairs <- names(b[["Pair.Balance"]])[sapply(names(b[["Pair.Balance"]]), function(x) {
              treat.names <- b[["Pair.Balance"]][[x]]$print.options$treat.namestreat.names
              all(treat.names[treat.names != "Others"] %in% b$print.options$treat.names[treat.names.good])})]
          }
        }
        
      }
      
      #Get B from b
      if (config == "agg.none") {
        B <- do.call("rbind", lapply(disp.treat.pairs,
                                     function(x) cbind(b[["Pair.Balance"]][[x]][["Balance"]],
                                                       treat.pair = x,
                                                       var.names = rownames(b[["Pair.Balance"]][[x]][["Balance"]]))))
        facet <- "treat.pair"
      }
      else if (config == "agg.pair") {
        #Agg.Fun <- switch(match.arg(agg.fun), mean = "Mean", median = "Median", max = "Max", range = "Range")
        Agg.Fun <- "Max"
        if (Agg.Fun == "Range") {
          subtitle <- paste0(which.stat2, " Range Across Treatment", ifelse(b$print.options$pairwise, " Pairs", "s"))
        }
        else {
          subtitle <- paste0(ifelse(Agg.Fun == "Mean", "Average", Agg.Fun), " ", which.stat2, " Across Treatment", ifelse(b$print.options$pairwise, " Pairs", "s"))
        }
        B <- cbind(b[["Balance.Across.Pairs"]],
                   var.names = rownames(b[["Balance.Across.Pairs"]]))
      }
    }
    else if (any(class(b) == "bal.tab.subclass")) {
      if (which.stat=="V.Ratio") stop("Variance ratios not currently supported for subclassification.", call. = FALSE)
      if (which.stat=="KS") stop("KS statistics not currently supported for subclassification.", call. = FALSE)
      if (any(class(b) == "bal.tab.cont")) stop("Continuous treatments not currently supported for subclassification.", call. = FALSE)
      subclass.names <- names(b[["Subclass.Balance"]])
      sub.B <- do.call("cbind", lapply(subclass.names, function(x) {
        sub <- b[["Subclass.Balance"]][[x]]
        sub.B0 <- setNames(sub[endsWith(names(sub), ".Adj")],
                           gsub(".Adj", paste0(".Subclass ", x), names(sub)[endsWith(names(sub), ".Adj")]))
        return(sub.B0) }))
      B <- cbind(b[["Balance.Across.Subclass"]], sub.B, var.names = row.names(b[["Balance.Across.Subclass"]]))
      if (b$print.options$disp.subclass) b$print.options$weight.names <- c("Adj", paste("Subclass", subclass.names))
      else b$print.options$weight.names <- "Adj"
      subtitle <- "Across Subclasses"
    }
    else {
      B <- cbind(b[["Balance"]], var.names = row.names(b[["Balance"]]))
    }
    
    if (config == "agg.none") {
      if (!abs && !b$print.options[["abs"]]) {
        abs <- FALSE
      }
      else {
        if (!abs && b$print.options[["abs"]])
          warning("abs is TRUE in the bal.tab object; ignoring abs in the call to love.plot().", call. = FALSE)
        abs <- TRUE
      }
    }
    else if (config %in% c("agg.time", "agg.pair")) {
      abs <- TRUE
    }
    else if (config %in% c("agg.imp", "agg.cluster", "agg.all")) {
      abs <- b$print.options[["abs"]]
    }
    
    if (null.threshold) {
      if (which.stat=="Diff") {
        if (is_not_null(b$print.options$m.threshold)) {
          threshold <- b$print.options$m.threshold
          null.threshold <- FALSE
        }
      }
      else if (which.stat=="V.Ratio") {
        if (is_not_null(b$print.options$v.threshold)) {
          threshold <- b$print.options$v.threshold
          null.threshold <- FALSE
        }
      }
      else if (which.stat=="KS") {
        if (is_not_null(b$print.options$ks.threshold)) {
          threshold <- b$print.options$ks.threshold
          null.threshold <- FALSE
        }
      }
      else if (which.stat=="Corr") {
        if (is_not_null(b$print.options$r.threshold)) {
          threshold <- b$print.options$r.threshold
          null.threshold <- FALSE
        }
      }
    }
    
    if (is_not_null(var.names)) {
      if (is.data.frame(var.names)) {
        if (ncol(var.names)==1) {
          if (is_not_null(row.names(var.names))) {
            new.labels <- setNames(as.list(as.character(rownames(var.names))), var.names[,1])
          }
          else warning("var.names is a data.frame, but its rows are unnamed.", call. = FALSE)
          
        }
        else if (ncol(var.names)>1) {
          if (all(c("old", "new") %in% names(var.names))) {
            new.labels <- setNames(as.list(as.character(var.names[,"old"])), var.names[,"new"])
          }
          else {
            if (ncol(var.names)>2) warning("Only using first 2 columns of var.names", call. = FALSE)
            new.labels <- setNames(as.list(as.character(var.names[,1])), var.names[,2])
          }
        } 
      }
      else if (is.character(var.names) || is.factor(var.names)) {
        if (is_not_null(names(var.names))) {
          new.labels <- setNames(as.list(names(var.names)), var.names)
        }
        else warning("var.names is a vector, but its values are unnamed.", call. = FALSE)
      }
      else if (is.list(var.names)) {
        if (all(sapply(var.names, function(x) is.character(x) || is.factor(x)))) {
          if (is_not_null(names(var.names))) {
            new.labels <- setNames(names(var.names), var.names) #already a list
          }
          else warning("var.names is a list, but its values are unnamed.", call. = FALSE)
        }
        else warning("var.names is a list, but its values are not the new names of the variables.", call. = FALSE)
      }
      else warning("Argument to var.names is not one of the accepted structures and will be ignored.\n  See help(love.plot) for details.", immediate.=TRUE, call. = FALSE)
      new.labels <- new.labels[new.labels %in% B[, "var.names"]]
      B[["var.names"]] <- do.call(f.recode, c(list(B[["var.names"]]), as.list(new.labels)))
    }
    
    distance.names <- as.character(unique(B[["var.names"]][B[["Type"]] == "Distance"]))
    if (drop.distance) {
      B <- B[is.na(match(B[["var.names"]], distance.names)),]
    }
    
    if (is_not_null(var.order)) {
      if (b$print.options$nweights == 0) {
        ua <- c("Unadjusted", "Alphabetical")
        names(ua) <- c("unadjusted", "alphabetical")
      }
      else if (b$print.options$nweights == 1) {
        ua <- c("Adjusted", "Unadjusted", "Alphabetical")
        names(ua) <- c("adjusted", "unadjusted", "alphabetical")
      }
      else {
        ua <- c("Unadjusted", b$print.options$weight.names, "Alphabetical")
        names(ua) <- c("unadjusted", b$print.options$weight.names, "alphabetical")
      }
      var.order <- ua[match.arg(var.order, tolower(ua))]
    }
    
    if (is_not_null(facet)) {
      if (is_not_null(var.order) && tolower(var.order) != "alphabetical" && (sum(cluster.names.good) > 1 || sum(imp.numbers.good) > 1 || length(disp.treat.pairs) > 1 || sum(time.names.good) > 1)) {
        warning("var.order cannot be set with multiple plots (unless \"alphabetical\"). Ignoring var.order.", call. = FALSE)
        var.order <- NULL
      }
    }
    
    if (is_not_null(Agg.Fun) && Agg.Fun == "Range") {
      agg.range <- TRUE
    }
    else agg.range <- FALSE
    
    if (agg.range) {
      SS <- do.call("rbind", lapply(c("Un", b$print.options$weight.names),
                                    function(x) data.frame(var = B[["var.names"]],
                                                           min.stat = B[[paste("Min", which.stat, x, sep = ".")]],
                                                           max.stat = B[[paste("Max", which.stat, x, sep = ".")]],
                                                           mean.stat = B[[paste("Mean", which.stat, x, sep = ".")]],
                                                           Sample = ifelse(x == "Un", "Unadjusted", 
                                                                           ifelse(x == "Adj", "Adjusted", x)))))
      
      if (is_not_null(facet)) {
        if ("cluster" %in% facet) {
          SS$cluster <- rep(B[["cluster"]], 1 + b$print.options$nweights)
        }
        if ("imp" %in% facet) {
          SS$imp <- rep(B[["imp"]], 1 + b$print.options$nweights)
        }
        if ("treat.pair" %in% facet) {
          SS$treat.pair <- rep(B[["treat.pair"]], 1 + b$print.options$nweights)
        }
      }
      
      if (all(sapply(SS[c("min.stat", "max.stat", "mean.stat")], is.na))) stop("No balance statistics to display.", call. = FALSE)
      gone <- character(0)
      for (i in levels(SS$Sample)) {
        if (all(sapply(SS[SS$Sample==i, c("min.stat", "max.stat", "mean.stat")], is.na))) {
          gone <- c(gone, i)
          if (i == "Unadjusted") warning("Unadjusted values are missing. This can occur when un = FALSE and quick = TRUE in the original call to bal.tab().", call. = FALSE, immediate. = TRUE)
          SS <- SS[SS[["Sample"]]!=i,]
        }
      }
      
      if (abs) dec <- FALSE
      else dec <- FALSE
      
      if (is_not_null(var.order)) {
        if (var.order %in% ua) {
          if (var.order %in% gone) {
            warning(paste0("var.order was set to \"", tolower(var.order), "\", but no ", tolower(var.order), " ", tolower(which.stat2), "s were calculated. Ignoring var.order."), call. = FALSE, immediate. = TRUE)
            var.order <- character(0)
          }
          else {
            v <- as.character(SS[["var"]][order(SS[["mean.stat"]][SS[["Sample"]]==var.order], decreasing = dec)])
            SS[["var"]] <- factor(SS[["var"]], 
                                  levels=c(v[is.na(match(v, distance.names))], 
                                           sort(distance.names, decreasing = TRUE)))
          }
        }
        else if (var.order == "alphabetical") {
          if ("time" %in% facet) {
            covnames0 <- vector("list", length(unique(SS[["time"]])))
            for (i in seq_along(covnames0)) {
              if (i == 1) {
                covnames0[[i]] <- sort(as.character(unique(SS[["var"]][SS[["time"]] == i])))
              }
              else {
                covnames0[[i]] <- sort(setdiff(as.character(unique(SS[["var"]][SS[["time"]] == i])), unlist(covnames0[seq_along(covnames0) < i])))
              }
            }
            covnames <- unlist(covnames0)
          }
          else covnames <- sort(SS[["var"]])
          SS[["var"]] <- factor(SS[["var"]], levels = c(rev(covnames[!covnames %in% distance.names]), sort(distance.names, decreasing = TRUE)))
        }
      }
      if (is.null(var.order)) {
        covnames <- as.character(unique(SS[["var"]]))
        SS[["var"]] <- factor(SS[["var"]], levels = c(rev(covnames[!covnames %in% distance.names]), sort(distance.names, decreasing = TRUE)))
      }
      # SS[, "Sample"] <- factor(SS[, "Sample"], levels = c("Adjusted", "Unadjusted"))
      SS[["Sample"]] <- factor(SS[["Sample"]])
      if (which.stat == "Diff" && any(abs(SS[["max.stat"]]) > 5)) warning("Large mean differences detected; you may not be using standardizied mean differences for continuous variables. To do so, specify continuous=\"std\" in bal.tab().", call.=FALSE, noBreaks.=TRUE)
      if (no.missing) SS <- SS[!is.na(SS[["min.stat"]]),]
      SS[["stat"]] <- SS[["mean.stat"]]
    }
    else {
      SS <- do.call("rbind", lapply(c("Un", b$print.options$weight.names),
                                    function(x) data.frame(var = B[["var.names"]],
                                                           stat = B[[ifelse(is.null(Agg.Fun), paste(which.stat, x, sep = "."),
                                                                            paste(Agg.Fun, which.stat, x, sep = "."))]],
                                                           Sample = ifelse(x == "Un", "Unadjusted", 
                                                                           ifelse(x == "Adj", "Adjusted", x)))))
      
      if (is_not_null(facet)) {
        for (i in c("cluster", "imp", "treat.pair", "time")) {
          if (i %in% facet) {
            SS[[i]] <- rep(B[[i]], 1 + b$print.options$nweights)
          }
        }
      }
      
      if (all(is.na(SS[["stat"]]))) stop("No balance statistics to display.", call. = FALSE)
      gone <- character(0)
      for (i in levels(SS$Sample)) {
        if (all(sapply(SS[["stat"]][SS$Sample==i], is.na))) {
          gone <- c(gone, i)
          if (i == "Unadjusted") warning("Unadjusted values are missing. This can occur when un = FALSE and quick = TRUE in the original call to bal.tab().", call. = FALSE, immediate. = TRUE)
          SS <- SS[SS[["Sample"]]!=i,]
        }
      }
      
      if (abs) {
        SS[["stat"]] <- abs(SS[["stat"]])
        dec <- FALSE
      }
      else dec <- FALSE
      
      if (is_not_null(var.order)) {
        if (tolower(var.order) == "alphabetical") {
          if ("time" %in% facet) {
            covnames0 <- vector("list", length(unique(SS[["time"]])))
            for (i in seq_along(covnames0)) {
              if (i == 1) {
                covnames0[[i]] <- sort(as.character(unique(SS[["var"]][SS[["time"]] == i])))
              }
              else {
                covnames0[[i]] <- sort(setdiff(as.character(unique(SS[["var"]][SS[["time"]] == i])), unlist(covnames0[seq_along(covnames0) < i])))
              }
            }
            covnames <- unlist(covnames0)
          }
          else covnames <- sort(SS[["var"]])
          SS[["var"]] <- factor(SS[["var"]], levels = c(rev(covnames[!covnames %in% distance.names]), sort(distance.names, decreasing = TRUE)))
        }
        else if (var.order %in% ua) {
          if (var.order %in% gone) {
            warning(paste0("var.order was set to \"", tolower(var.order), "\", but no ", tolower(var.order), " ", tolower(which.stat2), "s were calculated. Ignoring var.order."), call. = FALSE, immediate. = TRUE)
            var.order <- character(0)
          }
          else {
            v <- as.character(SS[["var"]][order(SS[["stat"]][SS[["Sample"]]==var.order], decreasing = dec)])
            SS[["var"]] <- factor(SS[["var"]], 
                                  levels=c(v[is.na(match(v, distance.names))], 
                                           sort(distance.names, decreasing = TRUE)))
          }
        }
        
      }
      if (is.null(var.order)) {
        covnames <- as.character(unique(SS[["var"]]))
        SS[["var"]] <- factor(SS[["var"]], levels = c(rev(covnames[!covnames %in% distance.names]), sort(distance.names, decreasing = TRUE)))
      }
      SS[["Sample"]] <- factor(SS[["Sample"]])
      if (which.stat == "Diff" && any(abs(SS[["stat"]]) > 5)) warning("Large mean differences detected; you may not be using standardizied mean differences for continuous variables. To do so, specify continuous=\"std\" in bal.tab().", call.=FALSE, noBreaks.=TRUE)
      if (no.missing) SS <- SS[!is.na(SS[["stat"]]),]
    }
    SS <- SS[order(SS[["var"]]),]
    SS[["var"]] <- factor(SS[["var"]])
    
    #Make the plot
    #library(ggplot2)
    
    #Setting up appearance
    #Size
    if (is.null(args$size)) size <- 1
    else if (is.numeric(args$size[1])) size <- args$size[1]
    else {
      warning("The argument to size must be a number. Using 1 instead.", call. = FALSE)
      size <- 1
    }
    stroke <- .8*size
    
    #Color
    ntypes <- if (is.null(subclass.names)) nlevels(SS$Sample) else 2
    if (is_not_null(args$colours)) colors <- args$colours
    
    if (is.null(colors)) {
      if (shapes.ok(shapes, ntypes) && length(shapes) == ntypes) {
        colors <- rep("black", ntypes)
      }
      else colors <- gg_color_hue(ntypes)
    }
    else {
      if (length(colors) == 1) colors <- rep(colors, ntypes)
      else if (length(colors) > ntypes) {
        colors <- colors[seq_len(ntypes)]
        warning(paste("Only using first", ntypes, "values in colors."), call. = FALSE)
      }
      else if (length(colors) < ntypes) {
        warning("Not enough colors were specified. Using default colors instead.", call. = FALSE)
        colors <- gg_color_hue(ntypes)
      }
      
      if (!all(sapply(colors, isColor))) {
        warning("The argument to colors contains at least one value that is not a recognized color. Using default colors instead.", call. = FALSE)
        colors <- gg_color_hue(ntypes)
      }
      
    }
    fill <- colors
    
    #Shapes
    if (is.null(shapes)) {
      shapes <- assign.shapes(colors)
    }
    else {
      #check shapes
      if (!shapes.ok(shapes, ntypes)) {
        warning(paste("The argument to shape must be", ntypes, "numbers between 1 and 25. \nUsing default shapes instead."), call. = FALSE)
        shapes <- assign.shapes(colors)
      }
      else if (length(shapes) == 1) shapes <- rep(shapes, ntypes)
    }
    
    #Title
    if (is_not_null(args$title)) title <- as.character(args$title)
    if (is_not_null(args$subtitle)) subtitle <- as.character(args$subtitle)
    #else subtitle <- NULL
    
    if (which.stat == "Corr") {
      baseline.xintercept <- 0
      if (abs) {
        xlab <- "Absolute Treatment-Covariate Correlations"
        if (!null.threshold) threshold.xintercept <- abs(threshold)
      }
      else {
        xlab <- "Treatment-Covariate Correlations"
        if (!null.threshold) threshold.xintercept <- c(-threshold, threshold)
      }
    }
    else if (which.stat == "Diff") {
      baseline.xintercept <- 0
      if (abs) {
        xlab <- "Absolute Mean Differences"
        if (!null.threshold) threshold.xintercept <- abs(threshold)
      }
      else {
        xlab <- "Mean Differences"
        if (!null.threshold) threshold.xintercept <- c(-threshold, threshold)
      }
    }
    else if (which.stat == "V.Ratio") {
      baseline.xintercept <- 1
      xlab <- "Variance Ratios"
      if (!null.threshold) threshold.xintercept <- max(threshold, 1/threshold)
    }
    else if (which.stat == "KS") {
      baseline.xintercept <- 0
      xlab <- "Kolmogorov-Smirnov Statistics"
      if (!null.threshold) threshold.xintercept <- abs(threshold)
    }
    
    apply.limits <- FALSE
    if (is_not_null(args$limits)) {
      limits <- args$limits
      if (length(limits) != 2 || !is.numeric(limits)) {
        warning("limits must be a numeric vector of length 2. Ignoring limits.", call. = FALSE)
      }
      else {
        if (limits[2] < limits[1]) {
          warning("The values in limits must be in ascending order. Reversing them.", call. = FALSE)
          limits <- sort(limits)
        }
        
        if (limits[1] >= 0) limits[1] <- baseline.xintercept - .05*limits[2]
        if (limits[2] <= 0) limits[2] <- baseline.xintercept - .05*limits[1]
        
        if (agg.range) {
          if (any(SS[["min.stat"]] < limits[1]) || any(SS[["max.stat"]] > limits[2])) {
            for (i in c("min.stat", "stat", "max.stat")) {
              SS[[i]][SS[[i]] < limits[1]] <- limits[1]
              SS[[i]][SS[[i]] > limits[2]] <- limits[2]
            }
            warning("Some points will be removed from the plot by the limits.", call. = FALSE)
          }
        }
        else {
          if (any(SS[["stat"]] < limits[1]) || any(SS[["stat"]] > limits[2])) {
            warning("Some points will be removed from the plot by the limits.", call. = FALSE)
          }
        }
        apply.limits <- TRUE
      }
    }
    if (is_not_null(args$sample.names)) {
      if (!all(is.character(args$sample.names))) {
        warning("The argument to sample.names must be a character vector. Ignoring sample.names.", call. = FALSE)
      }
      else {
        if (length(args$sample.names) == ntypes - 1) {
          levels(SS$Sample)[-1] <- args$sample.names
        }
        else if (length(args$sample.names) == ntypes) {
          levels(SS$Sample) <- args$sample.names
        }
        else {
          warning("The argument to sample.names must contain as many names as there are sample types, or one fewer. Ignoring sample.names.", call. = FALSE)
        }
      }
      
    }
    
    lp <- ggplot(data = SS, aes(y = var, x = stat, group = Sample)) + 
      theme(panel.grid.major = element_line(color = "gray87"),
            panel.grid.minor = element_line(color = "gray90"),
            panel.background = element_rect(fill = "white", color = "black"),
            axis.text.x = element_text(color = "black"),
            axis.text.y = element_text(color = "black")
      ) + 
      scale_shape_manual(values = shapes) +
      scale_fill_manual(values = fill) +
      scale_color_manual(values = colors) + 
      labs(title = title, subtitle = subtitle, y = "", x = xlab) 
    
    lp <- lp + geom_vline(xintercept = baseline.xintercept, linetype = 1, color = "gray5")
    if (!null.threshold) lp <- lp + geom_vline(xintercept = threshold.xintercept, linetype=2, color = "gray8")
    
    if (agg.range) {
      position.dodge <- ggstance::position_dodgev(.5*(size))
      if (line == TRUE) { #Add line except to distance
        f <- function(x) {x[["stat"]][x$var %in% distance.names] <- NA; x}
        lp <- lp + ggplot2::layer(geom = "path", data = f, position = position.dodge, stat = "identity", 
                                  aes(color = Sample), params = list(size = size*.8, na.rm = TRUE))
      }
      lp <- lp + 
        ggstance::geom_linerangeh(aes(y = var, xmin = min.stat, xmax = max.stat, 
                                      color = Sample), position = position.dodge, size = size) + 
        geom_point(aes(y = var, x = mean.stat, shape = Sample, color = Sample), 
                   fill = "white", size = 2*size, stroke = stroke, na.rm = TRUE,
                   position = position.dodge) + 
        labs(title = title, y = "")
    }
    else {
      
      if (is.null(subclass.names) || !b$print.options$disp.subclass) {
        if (line == TRUE) { #Add line except to distance
          f <- function(x) {x[["stat"]][x$var %in% distance.names] <- NA; x}
          lp <- lp + ggplot2::layer(geom = "path", data = f(SS), position = "identity", stat = "identity", aes(color = Sample), params = list(size = size*.8, na.rm = TRUE))
        }
        lp <- lp + geom_point(data = SS, aes(shape = Sample,
                                             color = Sample), 
                              size = 2*size, stroke = stroke, fill = "white", na.rm = TRUE) 
      }
      else {
        SS.u.a <- SS[SS$Sample %in% c("Unadjusted", "Adjusted"),]
        SS.u.a$Sample <- factor(SS.u.a$Sample)
        if (line == TRUE) { #Add line except to distance
          f <- function(x) {x[["stat"]][x$var %in% distance.names] <- NA; x}
          lp <- lp + ggplot2::layer(geom = "path", data = f(SS.u.a), position = "identity", stat = "identity", aes(color = Sample), params = list(size = size*.8, na.rm = TRUE))
        }
        lp <- lp + geom_point(data = SS.u.a, 
                              aes(shape = Sample, color = Sample), 
                              size = 2*size, stroke = stroke, fill = "white", na.rm = TRUE) 
        lp <- lp + geom_text(data = SS[!SS$Sample %in% c("Unadjusted", "Adjusted"),], 
                             aes(label = gsub("Subclass ", "", Sample)), 
                             size = 2*size, na.rm = TRUE) 
      }
      
      
    }
    
    if (!drop.distance && is_not_null(distance.names)) {
      lp <- lp + geom_hline(linetype = 1, color = "black", 
                            yintercept = nunique(SS[["var"]]) - length(distance.names) + .5)
    }
    if (apply.limits) {
      lp <- lp + scale_x_continuous(limits = limits, expand = c(0, 0))
    }
    if (is_not_null(facet)) {
      lp <- lp + facet_grid(f.build(".", facet), drop = FALSE)
    }
    
    return(lp)
  }
  plot.bal.tab <- love.plot
}

## These lines set several options
options(scipen = 999) # Do not print scientific notation
options(stringsAsFactors = FALSE) ## Do not load strings as factors

memory.limit(10000000000000)


NPL<-readRDS(paste(path,'NPLfullny.rds', sep=""), refhook = NULL)

sample<-readRDS(paste(path,'baj.rds', sep=""),refhook = NULL)

sample1<-sample
sitesg<-names(table(sample1$closestsite)[table(sample1$closestsite)>100])
sitest<-names(table(sample1$closesttsite)[table(sample1$closesttsite)>100])

sample1<-sample1[sample1$closestsite %in% sitesg, ]
sample1<-sample1[sample1$closestsite==1|#sample1$closestsite==4|sample1$closestsite==11|
                   sample1$closestsite==6|sample1$closestsite==9|
                   sample1$closestsite==18|sample1$closestsite==21|
                   sample1$cdel==1,]
sample2<-sample1[sample1$tgdel==1,]
sample2$timetodel<-sample2$timetodelclose
sample2$postdel<-sample2$postdel
sampletemp<-sample1[sample1$cdel==1,]
for(i in sitest){
  sampletemp$timetodel<-as.numeric(sampletemp$date - NPL$deleteDate[as.numeric(i)])
  sampletemp$postdel<-ifelse(sampletemp$timetodel>0,1,0)
  sample2<-rbind(sample2,sampletemp)
}
#samplefull<-samplefull[abs(timetotreat)-10<0,]

sample1<-sample2[abs(timetodel)-3650<0,]
sample1$tttyear<-as.factor(ceiling(as.numeric(sample1$timetodel)/365))
sample1<-subset(sample1,tttyear!=1)
sample1<-subset(sample1,tttyear!=0)
sample1<-subset(sample1,tttyear!=-1)
sample1<-subset(sample1,tttyear!=-2)
sample1$timetotreat<-sample1$timetodel
#sample1<-sample1[sample1$closestsite!=22,]
ptlag<-model.matrix(~tgdel:as.factor(tttyear),sample1)
#as.factor(cut2(prediffdate, g=quant))+


if(TRUE){
  dist<-c('10k','8k','6k','4k','2k')#,'1k','500m')
  
  #dist<-c('4k','2k')#,'1k','500m')
  
  laglead<-c("")
  llc<-laglead[1]
  treatl<-c('TATE','MUATE','WLATE')
  sitelist<-names(table(sample$closestsite))
  psite<-sitelist[1]
  samplefull<-sample1
  samplefull<-samplefull[preprice>0,]
  samplefull$treatst<-ifelse(samplefull$postdel*samplefull$tgdel>0,1,0)
  buf<-1
  #samplefull$buffer<-ifelse(samplefull$date-odNPL$date[psite]+(buf*365)>0&samplefull$date-odNPL$date[psite]<0,1,0)
  samplefull$buffer<-ifelse(abs(samplefull$timetodel)-(buf*365)<0,1,0)
  samplefull$buffer2<-ifelse(samplefull$timetodel+(2*365)>0&samplefull$timetodel<0,1,0)
  samplefull<-samplefull[buffer<1,]
  samplefull<-samplefull[buffer2<1,]
  samplefull$delprocess<-ifelse(samplefull$timetodel<0 &samplefull$postcc>0,1,0)
  samplefull<-samplefull[delprocess<1,]
  samplefull$timetotreat<-samplefull$timetodel
  samplefull$lsite<-samplefull$closestsite
  samplefull$demlogprice<-demeanlist(samplefull$logprice,
                                     list(as.factor(samplefull$PropertyAddressCensusTractAndBlock)))
  # sample$logprice<-sample$logprice.x
  #Total Average Treatment Effect
  
  samplefull$aftpropnpl<-ifelse(samplefull$time_to_prop>01,0)
  
  #sample$aftfinalnpl<-sample[[paste0('aftfinalnpl',fnplsite)]]
  #sample$timefinalnplfe<-sample[[paste0('timefinalnplfe',fnplsite)]]
  samplefull$treatControlsComplete<-ifelse(samplefull$time_to_cc>0,1,0)
  
  #Municipal ATE
  samplefull$treatdgwMU<- samplefull$treatst* samplefull$WaterStndCode.fMU
  samplefull$treatgroupMU<-samplefull$tgdel * samplefull$WaterStndCode.fMU
  samplefull$controlMU<-samplefull$control*samplefull$WaterStndCode.fMU
  
  samplefull$sample.MUATE<-samplefull$control+samplefull$treatgroupMU
  
  #Municipal ATE
  samplefull$treatdgwWL<- samplefull$treatst* samplefull$WaterStndCode.fWL
  samplefull$treatgroupWL<-samplefull$tgdel * samplefull$WaterStndCode.fWL
  samplefull$controlWL<-samplefull$control*samplefull$WaterStndCode.fWL
  
  samplefull$sample.WLATE<-samplefull$control+samplefull$treatgroupWL
  
  #psite<-2
  samplefull$timetotreat<-samplefull$timetotreat/365
  #samplefull<-samplefull[abs(timetotreat)-10<0,]
  
}

#sample1<-sample[sample$WaterStndCode=="WL",]

#table(sample$closesttsite)
#table(sample$closestsite)
#15,20,22,8
sample1<-samplefull
sitesg<-names(table(sample1$closestsite)[table(sample1$closestsite)>100])
sitest<-names(table(sample1$closesttsite)[table(sample1$closesttsite)>100])

sample1<-sample1[sample1$closestsite %in% sitesg, ]
sample1<-sample1[sample1$closestsite==1|#sample1$closestsite==4|sample1$closestsite==11|
                   sample1$closestsite==6|sample1$closestsite==9|
                   sample1$closestsite==18|sample1$closestsite==21|
                   sample1$cdel==1,]
sample2<-sample1[sample1$tgdel==1,]
sample2$timetodel<-sample2$timetodelclose
sample2$postdel<-sample2$postdel
sampletemp<-sample1[sample1$cdel==1,]
for(i in sitest){
  sampletemp$timetodel<-as.numeric(sampletemp$date - NPL$deleteDate[as.numeric(i)])
  sampletemp$postdel<-ifelse(sampletemp$timetodel>0,1,0)
  sample2<-rbind(sample2,sampletemp)
}
#samplefull<-samplefull[abs(timetotreat)-10<0,]

sample1<-sample2[abs(timetodel)-3650<0,]
sample1$tttyear<-as.factor(ceiling(as.numeric(sample1$timetodel)/365))
sample1<-subset(sample1,tttyear!=1)
sample1<-subset(sample1,tttyear!=0)
sample1<-subset(sample1,tttyear!=-1)
sample1<-subset(sample1,tttyear!=-2)
sample1$timetotreat<-sample1$timetodel
#sample1<-sample1[sample1$closestsite!=22,]
ptlag<-model.matrix(~tgdel:as.factor(tttyear),sample1)
#as.factor(cut2(prediffdate, g=quant))+


dist<-c('10k','8k','6k','4k','2k')#,'1k','500m')

#dist<-c('4k','2k')#,'1k','500m')

laglead<-c("")
treatl<-c('TATE','MUATE','WLATE')
#sample<-readRDS(paste0(path,"pretreatlag.rds"), refhook = NULL)
#sample<-readRDS(paste0(path,"fullcen.rds"), refhook = NULL)
sample1$age<-year(sample1$date)-sample1$YearBuilt

#summary stats
if(TRUE){
sample<-sample1[age>=0]
sample$treatmentgroup<-sample$tgdel
#samplefull<-sample
quant<-10
qcut<-cut2(samplefull$preprice, g=quant, onlycuts = TRUE)

sumvar<-c("price","sqfeet","TotalRooms","YearBuilt","FullBath")
ts<-sample[treatmentgroup==1,c("price","sqfeet","YearBuilt","RecordingDate","FullBath","LotSizeSquareFeet")]
ts$year <- as.numeric(as.character(factor(format(as.Date(ts$RecordingDate),'%Y'))))
cs<-sample[treatmentgroup==0,c("price","sqfeet","YearBuilt","RecordingDate","FullBath","LotSizeSquareFeet")]
cs$year <- as.numeric(as.character(factor(format(as.Date(cs$RecordingDate),'%Y'))))

sum25<-rbind("25th percentile",quantile(ts$price)[2],quantile(ts$sqfeet)[2],quantile(ts$YearBuilt)[2],quantile(ts$year)[2],quantile(ts$FullBath)[2],quantile(ts$LotSizeSquareFeet)[2],
             quantile(cs$price)[2],quantile(cs$sqfeet)[2],quantile(cs$YearBuilt)[2],quantile(cs$year)[2],quantile(cs$FullBath)[2],quantile(cs$LotSizeSquareFeet)[2])
summed<-rbind("Median",median(ts$price),median(ts$sqfeet),median(ts$YearBuilt),median(ts$year),median(ts$FullBath),median(ts$LotSizeSquareFeet),
              median(cs$price),median(cs$sqfeet),median(cs$YearBuilt),median(cs$year),median(cs$FullBath),median(cs$LotSizeSquareFeet))
summean<-rbind("Mean",floor(mean(ts$price)),floor(mean(ts$sqfeet)),floor(mean(ts$YearBuilt)),floor(mean(ts$year)),floor(mean(ts$FullBath)),floor(mean(ts$LotSizeSquareFeet)),
               floor(mean(cs$price)),floor(mean(cs$sqfeet)),floor(mean(cs$YearBuilt)),floor(mean(cs$year)),floor(mean(cs$FullBath)),floor(mean(cs$LotSizeSquareFeet)))
sum75<-rbind("75th percentile",quantile(ts$price)[4],quantile(ts$sqfeet)[4],quantile(ts$YearBuilt)[4],quantile(ts$year)[4],quantile(ts$FullBath)[4],quantile(ts$LotSizeSquareFeet)[4],
             quantile(cs$price)[4],quantile(cs$sqfeet)[4],quantile(cs$YearBuilt)[4],quantile(cs$year)[4],quantile(cs$FullBath)[4],quantile(cs$LotSizeSquareFeet)[4])
tdiff<-rbind("T-Test",base::round(as.numeric(t.test(ts$price,cs$price)["statistic"]),digits=2),
             base::round(as.numeric(t.test(ts$sqfeet,cs$sqfeet)["statistic"]),digits=2),
             base::round(as.numeric(t.test(ts$year,cs$year)["statistic"]),digits=2),
             base::round(as.numeric(t.test(ts$YearBuilt,cs$YearBuilt)["statistic"]),digits=2),
             base::round(as.numeric(t.test(ts$FullBath,cs$FullBath)["statistic"]),digits=2),
             base::round(as.numeric(t.test(ts$LotSizeSquareFeet,cs$LotSizeSquareFeet)["statistic"]),digits=2),
             base::round(as.numeric(t.test(cs$price,ts$price)["statistic"]),digits=2),
             base::round(as.numeric(t.test(cs$sqfeet,ts$sqfeet)["statistic"]),digits=2),
             base::round(as.numeric(t.test(cs$year,ts$year)["statistic"]),digits=2),
             base::round(as.numeric(t.test(cs$YearBuilt,ts$YearBuilt)["statistic"]),digits=2),
             base::round(as.numeric(t.test(cs$FullBath,ts$FullBath)["statistic"]),digits=2),
             base::round(as.numeric(t.test(cs$LotSizeSquareFeet,ts$LotSizeSquareFeet)["statistic"]),digits=2))

rlab<-rbind("     ","Price","Square Feet","Year Built","Year","Full Bathroom","Lot Size","Price","Square Feet","Year Built","Year","Full Bathroom","Lot Size")
rlab2<-rbind("     ","Treatment","Group","  ","   ","  ","   ","Control","Group","  ","   ","  ","   ")
sumtab<-cbind(rlab2,rlab,sum25,summed,summean,sum75,tdiff)
rownames(sumtab)<-NULL
colnames(sumtab)<-NULL
sumtab

xtab<-xtable(sumtab)
align(xtab) <- "rl|l|rrrr|r"
caption(xtab)<-"Summary Statistics"
print.xtable(xtab,include.rownames=FALSE,  hline.after = c(0,1,7,dim(sumtab)[1]),
             include.colnames=FALSE, sanitize.text.function = identity,
             #caption = "Summary Statistics", 
             label = "tab:summary",
             type="latex", file=paste0(path,'latex/sumtab.tex'))

#LotSizeSquareFeet + YearBuilt + FullBath + HalfBath + sqfeet+day+prediffdate+predate
samplem<-sample[,c("date","tgdel","LotSizeSquareFeet", "sqfeet","age","YearBuilt", "FullBath","predate","preprice","TransId","WaterStndCode.fWL")]
mdm<- matchit(tgdel~year(date)+sqfeet+LotSizeSquareFeet+YearBuilt +FullBath+WaterStndCode.fWL,data=samplem,
              method = "nearest", distance = "mahalanobis", replace = TRUE,#discard=2,
              nearest=TRUE,
              ratio=2, caliper= .1, 
              mahvars = c("date", "sqfeet","LotSizeSquareFeet"),
              discard = "both")
plot(mdm)
print(mdm)
summary(mdm)
ps<-glm(tgdel~year(date)+sqfeet+LotSizeSquareFeet+YearBuilt +FullBath+WaterStndCode.fWL,data=samplem, family = "binomial")
mdm$distance<-ps$fitted.values
#old<-c("year.date.","sqfeet","LotSizeSquareFeet","YearBuilt", "FullBath","distance"),
newnames <-c("Propensity Score","Year","Square Feet","Lot Size","Year Built", "Bathrooms","Wells")

if(TRUE){
  loveplot <-
    function (X_mat, t_id, c_id, v_line, legend_position = "topright") {
      #X_mat<-cbind(X_mat,mdm)
      colnames(X_mat)<-newnames
      X_mat_t = X_mat[t_id, ]
      X_mat_c_before = X_mat[-t_id, ]
      X_mat_c_before_mean = apply(X_mat_c_before, 2, mean)
      X_mat_t_mean = apply(X_mat_t, 2, mean)
      X_mat_t_var = apply(X_mat_t, 2, var)
      X_mat_c_before_var = apply(X_mat_c_before, 2, var)
      std_dif_before = (X_mat_t_mean - X_mat_c_before_mean)/sqrt((X_mat_t_var + X_mat_c_before_var)/2)
      X_mat_c_after = X_mat[c_id, ]
      X_mat_c_after_mean = apply(X_mat_c_after, 2, mean)
      std_dif_after = (X_mat_t_mean - X_mat_c_after_mean)/sqrt((X_mat_t_var + X_mat_c_before_var)/2)
      #library("lattice")
      abs_std_dif_before = std_dif_before
      n_aux = length(abs_std_dif_before)
      abs_std_dif_after = std_dif_after
      dotchart(abs_std_dif_before[n_aux:1], labels = colnames(X_mat)[n_aux:1], cex = .9, 
               pch = "", color = , main = "", 
               xlim = c(min(std_dif_before), max(std_dif_before)), xlab = "Standardized differences in means")
      points(abs_std_dif_before[n_aux:1], y = 1:ncol(X_mat), cex = 0.9, pch = 0)
      points(abs_std_dif_after[n_aux:1], y = 1:ncol(X_mat), cex = 0.8, pch = 8, col = "blue")
      legend(legend_position, c("Before matching", "After matching"), cex = .9, bty = "n", pch = c(0, 8), col = c("black", "blue"))
      abline(v = v_line, lty = 2)
      abline(v = -v_line, lty = 2)
      abline(h=(dim(X_mat)[2]-.5), col="black")
    }
}

jpeg(file =paste0(path, "latex/loveplot.jpeg"),width = 480, height = 480)

loveplot(cbind(mdm$distance,mdm$X), mdm$treat, ifelse(mdm$treat,0,1),
         .1, legend_position = "topleft")
dev.off()

love.plot(bal.tab(mdm), threshold = .1,abs = FALSE,var.names= v)
#bal.plot(mdm,var.name = "sqfeet")

mdm.treat <- match.data(mdm, group = "treat")
mdm.control <- match.data(mdm, group = "control")
mdm<-rbind(mdm.treat,mdm.control)
mdm<-mdm[,c("TransId","date")]
mdm<-data.table(mdm)
sample1$treatmentgroup<-sample1$tgdel
samplemerge<-data.table(sample1)
mdmf<-samplemerge[samplemerge$TransId %in% names(table(mdm$TransId)),]

#mdm.full<-merge(mdm,samplemerge,all = FALSE, by = c("TransId","date"))
sample<-data.frame(mdmf)
sample<-data.table(sample)

sumvar<-c("price","sqfeet","TotalRooms","YearBuilt","FullBath")
pts<-sample[treatmentgroup==1&timetotreat<0,c("price","sqfeet","YearBuilt","RecordingDate","FullBath","LotSizeSquareFeet")]
pts$year <- as.numeric(as.character(factor(format(as.Date(pts$RecordingDate),'%Y'))))
pcs<-sample[treatmentgroup==0&timetotreat<0,c("price","sqfeet","YearBuilt","RecordingDate","FullBath","LotSizeSquareFeet")]
pcs$year <- as.numeric(as.character(factor(format(as.Date(pcs$RecordingDate),'%Y'))))
ats<-sample[treatmentgroup==1&timetotreat>0,c("price","sqfeet","YearBuilt","RecordingDate","FullBath","LotSizeSquareFeet")]
ats$year <- as.numeric(as.character(factor(format(as.Date(ats$RecordingDate),'%Y'))))
acs<-sample[treatmentgroup==0&timetotreat>0,c("price","sqfeet","YearBuilt","RecordingDate","FullBath","LotSizeSquareFeet")]
acs$year <- as.numeric(as.character(factor(format(as.Date(acs$RecordingDate),'%Y'))))

sumvar<-c("price","sqfeet","TotalRooms","YearBuilt","FullBath")
ts<-sample[treatmentgroup==1,c("price","sqfeet","YearBuilt","RecordingDate","FullBath","LotSizeSquareFeet")]
ts$year <- as.numeric(as.character(factor(format(as.Date(ts$RecordingDate),'%Y'))))
cs<-sample[treatmentgroup==0,c("price","sqfeet","YearBuilt","RecordingDate","FullBath","LotSizeSquareFeet")]
cs$year <- as.numeric(as.character(factor(format(as.Date(cs$RecordingDate),'%Y'))))

sum25<-rbind("25th percentile",quantile(ts$price)[2],quantile(ts$sqfeet)[2],quantile(ts$YearBuilt)[2],quantile(ts$year)[2],quantile(ts$FullBath)[2],quantile(ts$LotSizeSquareFeet)[2],
             quantile(cs$price)[2],quantile(cs$sqfeet)[2],quantile(cs$YearBuilt)[2],quantile(cs$year)[2],quantile(cs$FullBath)[2],quantile(cs$LotSizeSquareFeet)[2])
summed<-rbind("Median",median(ts$price),median(ts$sqfeet),median(ts$YearBuilt),median(ts$year),median(ts$FullBath),median(ts$LotSizeSquareFeet),
              median(cs$price),median(cs$sqfeet),median(cs$YearBuilt),median(cs$year),median(cs$FullBath),median(cs$LotSizeSquareFeet))
summean<-rbind("Mean",floor(mean(ts$price)),floor(mean(ts$sqfeet)),floor(mean(ts$YearBuilt)),floor(mean(ts$year)),floor(mean(ts$FullBath)),floor(mean(ts$LotSizeSquareFeet)),
               floor(mean(cs$price)),floor(mean(cs$sqfeet)),floor(mean(cs$YearBuilt)),floor(mean(cs$year)),floor(mean(cs$FullBath)),floor(mean(cs$LotSizeSquareFeet)))
sum75<-rbind("75th percentile",quantile(ts$price)[4],quantile(ts$sqfeet)[4],quantile(ts$YearBuilt)[4],quantile(ts$year)[4],quantile(ts$FullBath)[4],quantile(ts$LotSizeSquareFeet)[4],
             quantile(cs$price)[4],quantile(cs$sqfeet)[4],quantile(cs$YearBuilt)[4],quantile(cs$year)[4],quantile(cs$FullBath)[4],quantile(cs$LotSizeSquareFeet)[4])
tdiff<-rbind("T-Test",base::round(as.numeric(t.test(ts$price,cs$price)["statistic"]),digits=2),
             base::round(as.numeric(t.test(ts$sqfeet,cs$sqfeet)["statistic"]),digits=2),
             base::round(as.numeric(t.test(ts$year,cs$year)["statistic"]),digits=2),
             base::round(as.numeric(t.test(ts$YearBuilt,cs$YearBuilt)["statistic"]),digits=2),
             base::round(as.numeric(t.test(ts$FullBath,cs$FullBath)["statistic"]),digits=2),
             base::round(as.numeric(t.test(ts$LotSizeSquareFeet,cs$LotSizeSquareFeet)["statistic"]),digits=2),
             base::round(as.numeric(t.test(cs$price,ts$price)["statistic"]),digits=2),
             base::round(as.numeric(t.test(cs$sqfeet,ts$sqfeet)["statistic"]),digits=2),
             base::round(as.numeric(t.test(cs$year,ts$year)["statistic"]),digits=2),
             base::round(as.numeric(t.test(cs$YearBuilt,ts$YearBuilt)["statistic"]),digits=2),
             base::round(as.numeric(t.test(cs$FullBath,ts$FullBath)["statistic"]),digits=2),
             base::round(as.numeric(t.test(cs$LotSizeSquareFeet,ts$LotSizeSquareFeet)["statistic"]),digits=2))

rlab<-rbind("     ","Price","Square Feet","Year Built","Year","Full Bathroom","Lot Size","Price","Square Feet","Year Built","Year","Full Bathroom","Lot Size")
rlab2<-rbind("     ","Treatment","Group","  ","   ","  ","   ","Control","Group","  ","   ","  ","   ")
sumtab<-cbind(rlab2,rlab,sum25,summed,summean,sum75,tdiff)
rownames(sumtab)<-NULL
colnames(sumtab)<-NULL
sumtab

xtab<-xtable(sumtab)
align(xtab) <- "rl|l|rrrr|r"
caption(xtab)<-"Summary Statistics"
print.xtable(xtab,include.rownames=FALSE,  hline.after = c(0,1,7,dim(sumtab)[1]),
             include.colnames=FALSE, sanitize.text.function = identity,
             #caption = "Summary Statistics", 
             label = "tab:summary",
             type="latex", file=paste0(path,'latex/sumtabmatch.tex'))
#sample$date<-sample$date.x
}
#dist<-c('10k','8k','6k','5k','4k','3k','2k')#,'1k','500m')
dist<-c('8k','6k','4k','2k')#,'1k','500m')
dist<-c('10k','8k','6k','4k','2k')#,'1k','500m')

#dist<-c('4k','2k')#,'1k','500m')

laglead<-c("")
treatl<-c('TATE','MUATE','WLATE')
#di<-5
#ll<-1

#for(buf in 1:2){


specl<-c("i","a","s","y","")
#matrices

for(i in c("lm","gam","sp","match")){
  for(j in c("t","wl","mu")){
    for(k in c("did")){
      for(treat in treatl){
        for(spec in specl){
          assign(paste0('betas.',i,'.',j,'.',k,'.',treat,'.',spec),matrix(ncol = length(dist),nrow=quant))
          assign(paste0('ses.',i,'.',j,'.',k,'.',treat,'.',spec),matrix(ncol = length(dist),nrow=quant))
          assign(paste0('ps.',i,'.',j,'.',k,'.',treat,'.',spec),matrix(ncol = length(dist),nrow=quant))
          
          assign(paste0('betas.',i,'.',k),matrix(ncol = length(dist),nrow=length(treatl)))
          assign(paste0('ses.',i,'.',k),matrix(ncol = length(dist),nrow=length(treatl)))
          assign(paste0('ps.',i,'.',k),matrix(ncol = length(dist),nrow=length(treatl)))
          
        }
      }
    }
  }
}
di<-1
treat<-1
#psite<-21
match<-""

for(treat in  1:length(treatl)){
  
  treatc<-treatl[[treat]]
  #for(ll in 1:length(laglead)){
  for(di in 1:length(dist)){
    for(match in c("","match")){
      #match<-""
      
      dic<-dist[[di]]
      ll<-1
      llc<-laglead[[ll]]
      sample<-samplefull[samplefull[[paste0('dist',dic)]]>0,]
      #sample<-sample[presstatusd==0,]
      
      if(match=="match"){
        #LotSizeSquareFeet + YearBuilt + FullBath + HalfBath + sqfeet+day+prediffdate+predate
        samplem<-sample[,c("TransId","date","tgdel","LotSizeSquareFeet", "sqfeet","YearBuilt", "FullBath","predate")]
        mdm<- matchit(tgdel~date +sqfeet+predate,data=samplem, method = "nearest", distance = "mahalanobis")
        
        mdm.treat <- match.data(mdm, group = "treat")
        mdm.control <- match.data(mdm, group = "control")
        mdm<-rbind(mdm.treat,mdm.control)
        mdm<-mdm[,c("TransId","date")]
        
        mdm.full<-merge(mdm,sample,all.x = TRUE, by = "TransId")
        sample<-mdm.full
      }
      
      #sample$treatst<-sample$treatst-sample$presstatusd
      #sample<-sample[treatst>0,]
      
      # sample$logprice<-sample$logprice.x
      if(treatc=='TATE'){
        #Total Average Treatment Effect
        
      }
      if(treatc=='MUATE'){
        #Municipal ATE
        
        sample<-subset(sample, sample.MUATE==1)
      }
      if(treatc=='WLATE'){
        #Municipal ATE
        
        sample<-subset(sample, sample.WLATE==1)
      }
      
      if(mean(sample$treatst)>0){
        
        #TATE<-as.formula(logprice ~ treatdgw+ treatmentgroup+data.matrix(treatgroupm)+ data.matrix(timefe)+ data.matrix(year[,3:25])+ as.factor(HHID))
        
        sdf<-20
        lat<-sample$PropertyAddressLatitude
        long<-sample$PropertyAddressLongitude
        splat<-bs(lat, df = sdf)
        splong<-bs(long, df = sdf)
        spint<-model.matrix(~splat:splong)
        
        spTATE<-cbind(splat,splong,spint,lat,long)
        
        #Wst<-readRDS(paste0(path,"Wmat",treatc,dic,".rds"), refhook = NULL)
        #sample$wlp<-Wst%*%sample$prelogprice
        #sample$wp<-Wst%*%sample$preprice
        
        sample$preyear<-as.numeric(format(as.Date(sample$predate),"%Y"))
        sample$premonth<-as.numeric(format(as.Date(sample$predate),"%m"))
        sample$year<-as.numeric(format(as.Date(sample$RecordingDate),"%Y"))
        sample$month<-as.numeric(format(as.Date(sample$RecordingDate),"%m"))
        
        sample$quarter<-ifelse(sample$month==1|sample$month==2|sample$month==3,1,0)
        sample$quarter<-ifelse(sample$month==4|sample$month==5|sample$month==6,2,sample$quarter)
        sample$quarter<-ifelse(sample$month==7|sample$month==8|sample$month==9,3,sample$quarter)
        sample$quarter<-ifelse(sample$month==10|sample$month==11|sample$month==12,4,sample$quarter)
        
        sample$prequarter<-ifelse(sample$premonth==1|sample$premonth==2|sample$premonth==3,1,0)
        sample$prequarter<-ifelse(sample$premonth==4|sample$premonth==5|sample$premonth==6,2,sample$prequarter)
        sample$prequarter<-ifelse(sample$premonth==7|sample$premonth==8|sample$premonth==9,3,sample$prequarter)
        sample$prequarter<-ifelse(sample$premonth==10|sample$premonth==11|sample$premonth==12,4,sample$prequarter)
        
        
        sample$prelogpricewlag<-sample$lnlagu20l0sp10c30tp10
        
        sample$tprelprice<-sample$prelogprice*ifelse(sample$treatst==1 & sample$presstatusd==0,1,0)
        sample$treatfin<-ifelse(sample$treatst==1 & sample$presstatusd==0,1,0)
        indx<- factor(as.numeric(cut2(sample$preprice,cuts=qcut,minmax=TRUE)))
        indx2<- factor(as.numeric(cut2(exp(sample$prelogpricewlag),cuts=qcut,minmax=TRUE)))
        #indx<-ifelse(as.numeric(indx)!=as.numeric(levels(indx)[1])&
        #             as.numeric(indx)!=as.numeric(levels(indx)[length(levels(indx))]),"med",indx)
        #indx<-ifelse(indx==1,"bottom",indx)
        #indx<-ifelse(indx==quant,"top",indx)
        
        treatind<-model.matrix(~(postdel*tgdel):indx-1,sample)
        treatind<-treatind[,1:(length(unique(indx)))]
        
        X<-model.matrix(~ tgdel+indx:tgdel+indx:postdel+#:indx+#bs(timetotreat,5)+bs(day,5)+#as.factor(round(timetotreat,1))+
                          #treatmentgroup:as.factor(lsite)+indx:treatmentgroup:as.factor(lsite)+#:indx+#bs(timetotreat,5)+bs(day,5)+#as.factor(round(timetotreat,1))+
                          #poly(timetotreat,3)+poly(day,3)+
                          #treatmentgroup*timetotreat+#treatmentgroup*day+
                          LotSizeSquareFeet + YearBuilt + FullBath + HalfBath + 
                          sqfeet+ prediffdate+predate+prelogprice+indx+#presstatusd+
                          #as.factor(floor(timetotreat))+
                          -1,sample)
        
        qr.X <- qr(X, tol=1e-2, LAPACK = FALSE)
        (rnkX <- qr.X$rank)  ## 4 (number of non-collinear columns)
        (keep <- qr.X$pivot[seq_len(rnkX)])
        ## 1 2 4 5 
        X <- X[,keep]
        
        
        Xlag<-model.matrix(~ treatmentgroup+indx:treatmentgroup+#:indx+#bs(timetotreat,5)+bs(day,5)+#as.factor(round(timetotreat,1))+
                             #treatmentgroup:as.factor(lsite)+indx:treatmentgroup:as.factor(lsite)+#:indx+#bs(timetotreat,5)+bs(day,5)+#as.factor(round(timetotreat,1))+
                             #poly(timetotreat,3)+poly(day,3)+
                             #treatmentgroup*timetotreat+#treatmentgroup*day+
                             timetotreat+
                             LotSizeSquareFeet + YearBuilt + FullBath + HalfBath + 
                             sqfeet+ prediffdate+predate+prelogprice+indx+
                             prelogpricewlag+indx2+#as.factor(floor(timetotreat))+
                             -1,sample)
        
        
        qr.Xlag <- qr(Xlag, tol=1e-2, LAPACK = FALSE)
        (rnkXlag <- qr.Xlag$rank)  ## 4 (number of non-collinear columns)
        (keeplag <- qr.Xlag$pivot[seq_len(rnkXlag)])
        ## 1 2 4 5 
        Xlag <- Xlag[,keeplag]
        #sample<-samplefull
        #sample<-mdm.full
        results.lm.t.did.i<-felm(logprice ~treatind+
                                   X|as.factor(cbl)+
                                   as.factor(year):as.factor(quarter)+
                                   as.factor(preyear):as.factor(prequarter)| 0 | lsite:year,sample) #as.factor(HHID)+
        summary(results.lm.t.did.i)
        
        results.lm.t.did.a<-felm(logprice ~treatind+
                                   X|as.factor(cbg)+
                                   as.factor(year):as.factor(quarter)+
                                   as.factor(preyear):as.factor(prequarter)| 0 | lsite:year,sample) #as.factor(HHID)+
        summary(results.lm.t.did.a)
        
        results.lm.t.did.s<-felm(logprice ~treatind+X|as.factor(ctr)+
                                   as.factor(year):as.factor(quarter)+
                                   as.factor(preyear):as.factor(prequarter)| 0 | lsite:year,sample) #as.factor(HHID)+
        summary(results.lm.t.did.s)
        
        results.lm.t.did.y<-felm(logprice ~treatind+X|as.factor(lsite)+
                                   as.factor(year):as.factor(quarter)+
                                   as.factor(preyear):as.factor(prequarter)| 0 | lsite:year,sample) #as.factor(HHID)+
        summary(results.lm.t.did.y)
        
        
        #################################
        #Spatial
        
        results.sp.t.did.i<-felm(logprice ~treatind+
                                   Xlag|as.factor(cbl)+
                                   as.factor(year):as.factor(quarter)+
                                   as.factor(preyear):as.factor(prequarter)| 0 | lsite:year,sample) #as.factor(HHID)+
        summary(results.sp.t.did.i)
        
        results.sp.t.did.a<-felm(logprice ~treatind+
                                   Xlag|as.factor(cbg)+
                                   as.factor(year):as.factor(quarter)+
                                   as.factor(preyear):as.factor(prequarter)| 0 | lsite:year,sample) #as.factor(HHID)+
        summary(results.sp.t.did.a)
        
        results.sp.t.did.s<-felm(logprice ~treatind+Xlag|as.factor(ctr)+
                                   as.factor(year):as.factor(quarter)+
                                   as.factor(preyear):as.factor(prequarter)| 0 | lsite:year,sample) #as.factor(HHID)+
        summary(results.sp.t.did.s)
        
        results.sp.t.did.y<-felm(logprice ~treatind+Xlag|as.factor(lsite)+
                                   as.factor(year):as.factor(quarter)+
                                   as.factor(preyear):as.factor(prequarter)| 0 | lsite:year,sample) #as.factor(HHID)+
        summary(results.sp.t.did.y)
        
        #results.lm.t.did.z<-felm(logprice ~treatind+X|as.factor(PropertyZip)+as.factor(year):as.factor(quarter)+
        #                           as.factor(preyear):as.factor(prequarter)| 0 | lsite:year,sample) #as.factor(HHID)+
        #summary(results.lm.t.did.z)
        
        #results.lm.t.did.c<-felm(logprice ~treatind+X|as.factor(PropertyCity)| 0 | lsite:year,sample) #as.factor(HHID)+
        #summary(results.lm.t.did.c)
        
        
        
        Xg<-model.matrix(~ #treatmentgroup+#:indx+#bs(timetotreat,5)+bs(day,5)+#as.factor(round(timetotreat,1))+
                           #poly(timetotreat,3)+poly(day,3)+
                           #treatmentgroup*timetotreat+#treatmentgroup*day+
                           LotSizeSquareFeet + YearBuilt + FullBath + HalfBath + 
                           sqfeet+ prediffdate+predate+prelogprice+ indx+#indx+#presstatusd+
                           #as.factor(floor(timetotreat))+
                           as.factor(year):as.factor(quarter)+
                           as.factor(preyear):as.factor(prequarter)-1,sample)
        
        Xglag<-model.matrix(~ #treatmentgroup+#:indx+#bs(timetotreat,5)+bs(day,5)+#as.factor(round(timetotreat,1))+
                              #poly(timetotreat,3)+poly(day,3)+
                              #treatmentgroup*timetotreat+#treatmentgroup*day+
                              LotSizeSquareFeet + YearBuilt + FullBath + HalfBath + 
                              sqfeet+ prediffdate+predate+prelogprice+ indx+
                              prelogpricewlag+indx2+#indx+#presstatusd+
                              #as.factor(floor(timetotreat))+
                              as.factor(year):as.factor(quarter)+
                              as.factor(preyear):as.factor(prequarter)-1,sample)
        
        
        resid.ptlag<-felm(logprice~ptlag[,c(-8)]+ #tgdel+#treatmentgroup+
                            LotSizeSquareFeet + YearBuilt + FullBath + HalfBath + 
                            sqfeet+ timetodel+bs(timetodel,20)+
                            #as.numeric(prediffdate)+#bs(prediffdate,20)+
                            #prelogprice:as.factor(ceiling(as.numeric(predate)/730)):as.factor(ceiling(as.numeric(prediffdate)/730))|
                            prelogprice|
                            as.factor(year):as.factor(quarter)+
                            as.factor(year):as.factor(preyear)+
                            #as.factor(ceiling(as.numeric(prediffdate)/90))+
                            #as.factor(ceiling(as.numeric(timetodel)/365))+
                            as.factor(preyear):as.factor(prequarter)+
                            as.factor(cbg)|0|closestsite:year,sample1)
        
        #summary(resid.ptlag)
        
        if(TRUE){
          qu<-c("Bottom","Middle","Top")
          yearsbefore<-7
          yearsafter<-9
          qun<-c(-9:-4,2:10)
          allModelFrame <- data.frame(Variable = qun,
                                      Coefficient = as.numeric(coef(summary(resid.ptlag))[,"Estimate"][c(2:7,12:20)]),
                                      SE = as.numeric(coef(summary(resid.ptlag))[,"Cluster s.e."][c(2:7,12:20)]),
                                      modelName = "ptlag")
          
          
          interval2 <- -qnorm((1-0.95)/2)  # 95% multiplier
          leg<-c('10k','8k','6k','4k','2k')
          allModelFrame<-allModelFrame[allModelFrame$modelName!="2k",]
          allModelFrame$modelName<-as.factor( allModelFrame$modelName)
          allModelFrame$modelName<-factor(allModelFrame$modelName,levels(allModelFrame$modelName)[c(2:5,1)])
          
          # Plot
          zp1 <- ggplot(allModelFrame, aes(colour = modelName ))
          zp1 <- zp1 + geom_hline(yintercept = 0, colour = gray(1/2), lty = 2)
          zp1 <- zp1 + geom_pointrange(aes(x = Variable, y = Coefficient, ymin = Coefficient - SE*interval2,
                                           ymax = Coefficient + SE*interval2,color =modelName),
                                       lwd = 1/2, position = position_dodge(width = 1/2),
                                       shape = 21, fill = "WHITE")
          #zp1 <- zp1 + coord_flip() + theme_bw()
          
          #zp1 <- zp1 + geom_line(data = allModelFrame, aes(linetype =modelName ), size = 1) +
          zp1 <- zp1 +theme(legend.position="none")+ ggtitle("Test of Difference in Treatment and Control Groups")+xlab('Year From Treatment')  
          #zp1 <- zp1 + scale_x_continuous(labels=c("1"="B","2"="M","3"="T"))
          zp1 <- zp1 + scale_x_continuous(breaks=qun)
          print(zp1)  # The trick to these is position_dodge().
        }
        samplen<-data.frame(sample1)
        
        if(TRUE){
          resid.ptlag<-felm(logprice~#ptlag[,c(-8)]+ #tgdel+#treatmentgroup+
                              LotSizeSquareFeet + YearBuilt + FullBath + HalfBath + 
                              sqfeet+ #timetodel+bs(timetodel,20)+
                              #as.numeric(prediffdate)+#bs(prediffdate,20)+
                              prelogprice:as.factor(ceiling(as.numeric(predate)/730)):as.factor(ceiling(as.numeric(prediffdate)/730))|
                              as.factor(year):as.factor(quarter)+
                              as.factor(year):as.factor(preyear)+
                              #as.factor(ceiling(as.numeric(prediffdate)/90))+
                              #as.factor(ceiling(as.numeric(timetodel)/365))+
                              as.factor(preyear):as.factor(prequarter)+
                              as.factor(cbg)|0|closestsite:year,sample1)
          samplen$crdid<-resid.ptlag$residuals
          #sample$crdid<-sample$demlogprice-Xg[,-1]%*%coefdid
          #sample$crdid<-sample$crdid-mean(sample$crdid)
          samplen$post<-ifelse(samplen$timetotreat>0,1,0)
          treatment <- aggregate(crdid ~ tgdel+as.factor(round(as.numeric(timetodel)/365,2)), data=samplen, FUN=mean, na.rm=TRUE)
          names(treatment)[2]<-"timetotreat"
          names(treatment)[3]<-"crdid"
          treatment$timetotreat<-as.numeric(as.character(treatment$timetotreat))
          #treatment<-treatment[as.numeric(treatment$timetotreat)!=0.5,]
          samplen$timetotreat<-as.numeric(samplen$timetodel)/365
          ggplot() +
            geom_point(data=subset(treatment,tgdel==1), aes(x=timetotreat, y=crdid, color= "Treatment Group")) +
            geom_point(data=subset(treatment,tgdel==0), aes(x=timetotreat, y=crdid, color= "Control Group")) +
            stat_smooth(method = 'loess', formula = y ~ x  ,data=subset(samplen,tgdel==1&postdel==1),se= FALSE, 
                        aes(x=timetotreat, y=crdid),color= "blue") +
            stat_smooth(method = 'loess', formula = y ~ x  ,data=subset(samplen,tgdel==1&postdel==0),se= FALSE,  
                        aes(x=timetotreat, y=crdid),color= "blue") +
            
            stat_smooth(method = 'loess', formula = y ~ x  ,data=subset(samplen,tgdel==0&postdel==1),se= FALSE, 
                        aes(x=timetotreat, y=crdid),color= "red") +
            stat_smooth(method = 'loess', formula = y ~ x  ,data=subset(samplen,tgdel==0&postdel==0),se= FALSE, 
                        aes(x=timetotreat, y=crdid),color= "red") +
            ggtitle("Common Trends Assumption")+
            xlab('Years from Deletion') + labs(color="Legend") +  geom_vline(xintercept=0)+
            ylab('Monthly Average Residuals')
        }
        
        
        #sample<-subset(sample, sample.WLATE==1)
        sample$tttyear<-as.factor(ceiling(as.numeric(sample$timetodel)/365))
        sample1<-subset(sample,tttyear!=1)
        ptlag<-model.matrix(~tgdel:as.factor(ceiling(as.numeric(timetodel)/365)),sample1)
        #as.factor(cut2(prediffdate, g=quant))+
        
        resid.ptlag<-felm(logprice~ptlag[,c(-10)]+#cdel+#treatmentgroup+
                            LotSizeSquareFeet + YearBuilt + FullBath + HalfBath + 
                            sqfeet+timetodel+bs(timetodel,20)+
                            as.numeric(prediffdate)+bs(prediffdate,20)+
                            prelogprice|
                            #as.factor(ceiling(as.numeric(prediffdate)/90))+
                            #as.factor(ceiling(as.numeric(timetodel)/90))+
                            as.factor(year):as.factor(quarter)+
                            as.factor(preyear):as.factor(prequarter)+
                            as.factor(cbl)|0|closestsite:year,sample1)
        
        summary(resid.ptlag)
        
        if(TRUE){
          qu<-c("Bottom","Middle","Top")
          yearstest<-9
          qun<-c(-yearstest:-2,2:yearstest)
          allModelFrame <- data.frame(Variable = qun,
                                      Coefficient = as.numeric(coef(summary(resid.ptlag))[,"Estimate"][(11-yearstest):(8+yearstest)]),
                                      SE = as.numeric(coef(summary(resid.ptlag))[,"Cluster s.e."][(11-yearstest):(8+yearstest)]),
                                      modelName = "ptlag")
          
          
          interval2 <- -qnorm((1-0.95)/2)  # 95% multiplier
          leg<-c('10k','8k','6k','4k','2k')
          allModelFrame<-allModelFrame[allModelFrame$modelName!="2k",]
          allModelFrame$modelName<-as.factor( allModelFrame$modelName)
          allModelFrame$modelName<-factor(allModelFrame$modelName,levels(allModelFrame$modelName)[c(2:5,1)])
          
          # Plot
          zp1 <- ggplot(allModelFrame, aes(colour = modelName ))
          zp1 <- zp1 + geom_hline(yintercept = 0, colour = gray(1/2), lty = 2)
          zp1 <- zp1 + geom_pointrange(aes(x = Variable, y = Coefficient, ymin = Coefficient - SE*interval2,
                                           ymax = Coefficient + SE*interval2,color =modelName),
                                       lwd = 1/2, position = position_dodge(width = 1/2),
                                       shape = 21, fill = "WHITE")
          #zp1 <- zp1 + coord_flip() + theme_bw()
          
          #zp1 <- zp1 + geom_line(data = allModelFrame, aes(linetype =modelName ), size = 1) +
          zp1 <- zp1 +theme(legend.position="none")+ ggtitle("Test of Difference in Treatment and Control Groups")+xlab('Year From Treatment')  
          #zp1 <- zp1 + scale_x_continuous(labels=c("1"="B","2"="M","3"="T"))
          zp1 <- zp1 + scale_x_continuous(breaks=qun)
          print(zp1)  # The trick to these is position_dodge().
        }
        
        if(match==""){
          ggsave(file=paste(path,'latex/','pretrends',treatc,dic, 'h5.png', sep=""),height = 5,width =9)
        }
        
        resid.lm.t.did<-felm(logprice ~Xg[,-1]|as.factor(cbl),sample) #as.factor(HHID)+
        summary(resid.lm.t.did)
        
        sample$crdid<-resid.ptlag$residuals
        #sample$crdid<-sample$demlogprice-Xg[,-1]%*%coefdid
        #sample$crdid<-sample$crdid-mean(sample$crdid)
        sample$post<-ifelse(sample$timetotreat>0,1,0)
        treatment <- aggregate(crdid ~ tgdel+as.factor(round(timetotreat,2)), data=sample, FUN=mean, na.rm=TRUE)
        names(treatment)[2]<-"timetotreat"
        names(treatment)[3]<-"crdid"
        treatment$timetotreat<-as.numeric(as.character(treatment$timetotreat))
        #treatment<-treatment[as.numeric(treatment$timetotreat)!=0.5,]
        
        ggplot() +
          geom_point(data=subset(treatment,tgdel==1), aes(x=timetotreat, y=crdid, color= "Treatment Group")) +
          geom_point(data=subset(treatment,tgdel==0), aes(x=timetotreat, y=crdid, color= "Control Group")) +
          stat_smooth(method = 'loess', formula = y ~ x  ,data=subset(sample,tgdel=1&post==1),se= TRUE,  aes(x=timetotreat, y=crdid),color= "blue") +
          stat_smooth(method = 'loess', formula = y ~ x  ,data=subset(sample,tgdel==1&post==0),se= TRUE,  aes(x=timetotreat, y=crdid),color= "blue") +
          
          stat_smooth(method = 'loess', formula = y ~ x  ,data=subset(sample,tgdel==0&post==1),se= TRUE,  aes(x=timetotreat, y=crdid),color= "red") +
          stat_smooth(method = 'loess', formula = y ~ x  ,data=subset(sample,tgdel==0&post==0),se= TRUE,  aes(x=timetotreat, y=crdid),color= "red") +
          ggtitle("Common Trends Assumption")+
          xlab('Years from Deletion') + labs(color="Legend") +  geom_vline(xintercept=0)+
          ylab('Monthly Average Residuals')
        
        if(match==""){
          ggsave(file=paste(path,'latex/','lmdidavg',treatc,dic, '.png', sep=""),height = 6,width =10)
        }
        results.lm.t.did.agg<-felm(logprice ~treatst+Xg|
                                     as.factor(PropertyAddressCensusTractAndBlock),sample) #as.factor(HHID)+
        summary(results.lm.t.did.agg)
        
        
        if(match==""){
          betas.lm.did[treat,di]<-as.numeric(coef(summary(results.lm.t.did.agg))[,"Estimate"][1])
          ses.lm.did[treat,di]<-as.numeric(coef(summary(results.lm.t.did.agg))[,"Std. Error"][1])
          ps.lm.did[treat,di]<-as.numeric(coef(summary(results.lm.t.did.agg))[,"Pr(>|t|)"][1])
          
          results.sp.t.did.agg<-felm(logprice ~treatst+Xglag|
                                       as.factor(PropertyAddressCensusTractAndBlock),sample) #as.factor(HHID)+
          summary(results.sp.t.did.agg)
          
          betas.sp.did[treat,di]<-as.numeric(coef(summary(results.sp.t.did.agg))[,"Estimate"][1])
          ses.sp.did[treat,di]<-as.numeric(coef(summary(results.sp.t.did.agg))[,"Std. Error"][1])
          ps.sp.did[treat,di]<-as.numeric(coef(summary(results.sp.t.did.agg))[,"Pr(>|t|)"][1])
          
          
        }
        if(match=="match"){
          betas.match.did[treat,di]<-as.numeric(coef(summary(results.lm.t.did.agg))[,"Estimate"][1])
          ses.match.did[treat,di]<-as.numeric(coef(summary(results.lm.t.did.agg))[,"Std. Error"][1])
          ps.match.did[treat,di]<-as.numeric(coef(summary(results.lm.t.did.agg))[,"Pr(>|t|)"][1])
        }
        if(match==""){
          results.gam<-mgcv::gam(logprice~treatst+Xg+#s(prelogprice,bs="cr")+
                                   #as.factor(year):as.factor(quarter)+
                                   #as.factor(preyear):as.factor(prequarter)+
                                   as.factor(lsite)+s(lat,long,bs="tp",m=3,k=300),data=sample)
          gam.model.t<-mgcv::summary.gam(results.gam)   
          
          betas.gam.did[treat,di]<-as.numeric(gam.model.t$p.table[,"Estimate"])[2]
          ses.gam.did[treat,di]<-as.numeric(gam.model.t$p.table[,"Std. Error"])[2]
          ps.gam.did[treat,di]<-as.numeric(gam.model.t$p.table[,"Pr(>|t|)"])[2]
        }
        
        
        
        #results.spline<-lm(logprice~treatind+X+spTATE,sample)
        #summary(results.spline)
        
        #results.semip<-semip(logprice~treatind+X[,1:8]+preprice,nonpar=~lat+long,window1 = .5, window2 = .5,
        #               kern="tcub",distance="Mahal",targetfull=NULL, print.summary=TRUE, data=sample)
        #summary(results.semip)
        #library(gam)
        library(mgcv)
        if(match==""){
          s=mgcv:::s
          intsp<-model.matrix(~as.factor(sample$lsite):lat+as.factor(sample$lsite):long-1)
          #s1<-sample[lsite!=19,]
          #X1<-X[sample$lsite!=19,]
          #treatind1<-treatind[sample$lsite!=19,]
          results.gam<-mgcv::gam(logprice~treatind+X+#s(prelogprice,bs="cr")+as.factor(lsite):
                                   #s(day,bs="cr")+s(predate,bs="cr")+
                                   as.factor(year):as.factor(quarter)+
                                   as.factor(preyear):as.factor(prequarter)+
                                   as.factor(lsite)+
                                   s(PropertyAddressLatitude,PropertyAddressLongitude,bs="tp",m=3,k=300),data=sample)
          gam.model<-mgcv::summary.gam(results.gam)  
          mgcv::summary.gam(results.gam)  
          #results.gam<-mgcv::gam(logprice~treatind+X+#s(prelogprice,bs="cr")+
          #s(predate,bs="gp")+
          #s(day,bs="gp")+
          #s(lat,long,bs="ts",m=3,k=500),data=sample)
          #mgcv::summary.gam(results.gam) 
          
        }
        if(FALSE){
          
          
          vcov_both_formula <- cluster.vcov(results.lm.t.did.t, ~ lsite + year)
          dim(results.gam$R)
          model.matrix(results.gam$R)
          vcov.HC = solve(t(X)%*%X) %*% t(X)%*%diag(ehat^2)%*%X %*% solve(t(X)%*%X)
          mg$Vp <- vcov.HC
          summary(mg)
          all.equal(as.numeric(predict(mg,se.fit=TRUE)$se.fit),se.yhat.HC)
          
          results.gam<-mgcv::gam(logprice~treatind+X+#s(prelogprice,bs="cr")+
                                   #s(day,bs="gp")+
                                   s(lsite,bs="re")+s(year,bs="re")+
                                   s(lat,long,bs="tp",m=3,k=300),data=sample)
          mgcv::summary.gam(results.gam) 
          
          
          results.gam<-mgcv::gamm(logprice~treatind+X+#s(prelogprice,bs="cr")+
                                    #s(day,bs="gp")+
                                    s(lat,long,bs="tp",m=3,k=200),
                                  correlation=corSymm(form=~1|PropertyAddressCensusTractAndBlock),data=sample)
          mgcv::summary.gam(results.gam) 
          
          qgam.fit<-qgam(logprice~treatst+nX+#s(prelogprice,bs="cr")+
                           #s(day,bs="gp")+
                           s(lat,long,bs="tp",m=3,k=300), lsig = -1,
                         data=sample,qu=.5, err = 0.05,control = list("tol" = 0.01))
          summary.gam(qgam.fit)
          
          
          
          neX<-model.matrix(~ treatmentgroup+#indx:treatmentgroup:as.factor(lsite)+#:indx+#bs(timetotreat,5)+bs(day,5)+#as.factor(round(timetotreat,1))+
                              #poly(timetotreat,3)+poly(day,3)+
                              #treatmentgroup*timetotreat+#treatmentgroup*day+
                              LotSizeSquareFeet + YearBuilt + FullBath + HalfBath + 
                              sqfeet+as.factor(year)+as.factor(preyear)+
                              as.factor(quarter)+as.factor(prequarter)-1,sample)
          
          nX<-neX
          qr.nX <- qr(nX, tol=1e-2, LAPACK = FALSE)
          (rnknX <- qr.nX$rank)  ## 4 (number of non-collinear columns)
          (keepnX <- qr.nX$pivot[seq_len(rnknX)])
          ## 1 2 4 5 
          nX <- nX[,keepnX]
          
          rq.o<-rq.fit.sfn(as.matrix.csr(nX),y,
                           tmpmax=floor(10000+exp(-12.1)*(dim(nX)[1]*20-1)^2.35))
          
          fit.qr<-rq(logprice~nX,tau=.5, data=sample,method="sfn",na.action = na.omit)
          fit.qr
          summary(fit.qr,se = "boot")
          
          plot(indx,sample$logprice,xlab="Treatind", ylab="Log Price")
          taus <- c(.1,.9)
          abline(rq(logprice~X2,tau=.5,data=sample),col="blue")
          abline(lm(logprice~X2,data=sample),lty = 3,col="red")
          for( i in 1:length(taus)){
            abline(rq(logprice~X2,tau=taus[i],data=sample),col="gray")
          }
          
          
          
          
          #PropertyAddressLatitude PropertyAddressLongitude
          
          
          
          Wst<-readRDS(paste0(path,"Wmat",treatc,dic,".rds"), refhook = NULL)
          summary(rowSums(Wst))
          
          if(mean(rowSums(Wst))==1){
            Wst<-mat2listw(Wst, style="W")
            
            
            #finalb.lag.2sls.robust2 <- gstslshet(logprice~treatind+X,Wst, data = sample,
            #                                    initial.value = 0.2, eps =1e-2, inverse=FALSE,sarar=FALSE)
            #summary(finalb.lag.2sls.robust2)
            #effects.finalb.lag.2sls.robust2<- impacts(finalb.lag.2sls.robust2, listw= Wst, R=100)
            #summary(effects.finalb.lag.2sls.robust2, zstats=TRUE, short=TRUE)
            
            results.stsls<-sacsarlm(logprice~treatind+X, data = sample, listw=Wst, zero.policy = NULL,
                                    na.action = na.fail)
            summary(results.stsls)
          }
          # effects.finalb.lag.2sls.robust2<- impacts(results.stsls, listw= Wst, R=100)
          #summary(effects.finalb.lag.2sls.robust2, zstats=TRUE, short=TRUE)
        }
        if(match==""){
          if(treatc=="TATE"){
            betas.lm.t.did.TATE.i[,di]<-as.numeric(coef(summary(results.lm.t.did.i))[,"Estimate"][1:quant])
            betas.lm.t.did.TATE.a[,di]<-as.numeric(coef(summary(results.lm.t.did.a))[,"Estimate"][1:quant])
            betas.lm.t.did.TATE.s[,di]<-as.numeric(coef(summary(results.lm.t.did.s))[,"Estimate"][1:quant])
            betas.lm.t.did.TATE.y[,di]<-as.numeric(coef(summary(results.lm.t.did.y))[,"Estimate"][1:quant])
            
            betas.sp.t.did.TATE.i[,di]<-as.numeric(coef(summary(results.sp.t.did.i))[,"Estimate"][1:quant])
            betas.sp.t.did.TATE.a[,di]<-as.numeric(coef(summary(results.sp.t.did.a))[,"Estimate"][1:quant])
            betas.sp.t.did.TATE.s[,di]<-as.numeric(coef(summary(results.sp.t.did.s))[,"Estimate"][1:quant])
            betas.sp.t.did.TATE.y[,di]<-as.numeric(coef(summary(results.sp.t.did.y))[,"Estimate"][1:quant])
            
            betas.gam.t.did.TATE.[,di]<-as.numeric(gam.model$p.table[,"Estimate"])[2:(quant+1)]
            #betas.lm.t.es.TATE[,di]<-as.numeric(coef(summary(results.lm.t.es))[,"Estimate"][1:quant])
            ses.lm.t.did.TATE.i[,di]<-as.numeric(coef(summary(results.lm.t.did.i))[,"Cluster s.e."][1:quant])
            ses.lm.t.did.TATE.a[,di]<-as.numeric(coef(summary(results.lm.t.did.a))[,"Cluster s.e."][1:quant])
            ses.lm.t.did.TATE.s[,di]<-as.numeric(coef(summary(results.lm.t.did.s))[,"Cluster s.e."][1:quant])
            ses.lm.t.did.TATE.y[,di]<-as.numeric(coef(summary(results.lm.t.did.y))[,"Cluster s.e."][1:quant])
            
            ses.sp.t.did.TATE.i[,di]<-as.numeric(coef(summary(results.sp.t.did.i))[,"Cluster s.e."][1:quant])
            ses.sp.t.did.TATE.a[,di]<-as.numeric(coef(summary(results.sp.t.did.a))[,"Cluster s.e."][1:quant])
            ses.sp.t.did.TATE.s[,di]<-as.numeric(coef(summary(results.sp.t.did.s))[,"Cluster s.e."][1:quant])
            ses.sp.t.did.TATE.y[,di]<-as.numeric(coef(summary(results.sp.t.did.y))[,"Cluster s.e."][1:quant])
            
            ses.gam.t.did.TATE.[,di]<-as.numeric(gam.model$p.table[,"Std. Error"])[2:(quant+1)]
            #ses.lm.t.es.TATE[,di]<-as.numeric(coef(summary(results.lm.t.es))[,"Std. Error"][1:quant])
            ps.lm.t.did.TATE.i[,di]<-as.numeric(coef(summary(results.lm.t.did.i))[,"Pr(>|t|)"][1:quant])
            ps.lm.t.did.TATE.a[,di]<-as.numeric(coef(summary(results.lm.t.did.a))[,"Pr(>|t|)"][1:quant])
            ps.lm.t.did.TATE.s[,di]<-as.numeric(coef(summary(results.lm.t.did.s))[,"Pr(>|t|)"][1:quant])
            ps.lm.t.did.TATE.y[,di]<-as.numeric(coef(summary(results.lm.t.did.y))[,"Pr(>|t|)"][1:quant])
            
            ps.sp.t.did.TATE.i[,di]<-as.numeric(coef(summary(results.sp.t.did.i))[,"Pr(>|t|)"][1:quant])
            ps.sp.t.did.TATE.a[,di]<-as.numeric(coef(summary(results.sp.t.did.a))[,"Pr(>|t|)"][1:quant])
            ps.sp.t.did.TATE.s[,di]<-as.numeric(coef(summary(results.sp.t.did.s))[,"Pr(>|t|)"][1:quant])
            ps.sp.t.did.TATE.y[,di]<-as.numeric(coef(summary(results.sp.t.did.y))[,"Pr(>|t|)"][1:quant])
            
            ps.gam.t.did.TATE.[,di]<-as.numeric(gam.model$p.table[,"Pr(>|t|)"])[2:(quant+1)]
            #ps.lm.t.es.TATE[,di]<-as.numeric(coef(summary(results.lm.t.es))[,"Pr(>|t|)"][1:quant])
          }
          
          if(treatc=="MUATE"){
            betas.lm.t.did.MUATE.i[,di]<-as.numeric(coef(summary(results.lm.t.did.i))[,"Estimate"][1:quant])
            betas.lm.t.did.MUATE.a[,di]<-as.numeric(coef(summary(results.lm.t.did.a))[,"Estimate"][1:quant])
            betas.lm.t.did.MUATE.s[,di]<-as.numeric(coef(summary(results.lm.t.did.s))[,"Estimate"][1:quant])
            betas.lm.t.did.MUATE.y[,di]<-as.numeric(coef(summary(results.lm.t.did.y))[,"Estimate"][1:quant])
            
            betas.sp.t.did.MUATE.i[,di]<-as.numeric(coef(summary(results.sp.t.did.i))[,"Estimate"][1:quant])
            betas.sp.t.did.MUATE.a[,di]<-as.numeric(coef(summary(results.sp.t.did.a))[,"Estimate"][1:quant])
            betas.sp.t.did.MUATE.s[,di]<-as.numeric(coef(summary(results.sp.t.did.s))[,"Estimate"][1:quant])
            betas.sp.t.did.MUATE.y[,di]<-as.numeric(coef(summary(results.sp.t.did.y))[,"Estimate"][1:quant])
            
            betas.gam.t.did.MUATE.[,di]<-as.numeric(gam.model$p.table[,"Estimate"])[2:(quant+1)]
            #betas.lm.t.es.TATE[,di]<-as.numeric(coef(summary(results.lm.t.es))[,"Estimate"][1:quant])
            ses.lm.t.did.MUATE.i[,di]<-as.numeric(coef(summary(results.lm.t.did.i))[,"Cluster s.e."][1:quant])
            ses.lm.t.did.MUATE.a[,di]<-as.numeric(coef(summary(results.lm.t.did.a))[,"Cluster s.e."][1:quant])
            ses.lm.t.did.MUATE.s[,di]<-as.numeric(coef(summary(results.lm.t.did.s))[,"Cluster s.e."][1:quant])
            ses.lm.t.did.MUATE.y[,di]<-as.numeric(coef(summary(results.lm.t.did.y))[,"Cluster s.e."][1:quant])
            
            ses.sp.t.did.MUATE.i[,di]<-as.numeric(coef(summary(results.sp.t.did.i))[,"Cluster s.e."][1:quant])
            ses.sp.t.did.MUATE.a[,di]<-as.numeric(coef(summary(results.sp.t.did.a))[,"Cluster s.e."][1:quant])
            ses.sp.t.did.MUATE.s[,di]<-as.numeric(coef(summary(results.sp.t.did.s))[,"Cluster s.e."][1:quant])
            ses.sp.t.did.MUATE.y[,di]<-as.numeric(coef(summary(results.sp.t.did.y))[,"Cluster s.e."][1:quant])
            
            
            ses.gam.t.did.MUATE.[,di]<-as.numeric(gam.model$p.table[,"Std. Error"])[2:(quant+1)]
            #ses.lm.t.es.TATE[,di]<-as.numeric(coef(summary(results.lm.t.es))[,"Std. Error"][1:quant])
            ps.lm.t.did.MUATE.i[,di]<-as.numeric(coef(summary(results.lm.t.did.i))[,"Pr(>|t|)"][1:quant])
            ps.lm.t.did.MUATE.a[,di]<-as.numeric(coef(summary(results.lm.t.did.a))[,"Pr(>|t|)"][1:quant])
            ps.lm.t.did.MUATE.s[,di]<-as.numeric(coef(summary(results.lm.t.did.s))[,"Pr(>|t|)"][1:quant])
            ps.lm.t.did.MUATE.y[,di]<-as.numeric(coef(summary(results.lm.t.did.y))[,"Pr(>|t|)"][1:quant])
            
            ps.sp.t.did.MUATE.i[,di]<-as.numeric(coef(summary(results.sp.t.did.i))[,"Pr(>|t|)"][1:quant])
            ps.sp.t.did.MUATE.a[,di]<-as.numeric(coef(summary(results.sp.t.did.a))[,"Pr(>|t|)"][1:quant])
            ps.sp.t.did.MUATE.s[,di]<-as.numeric(coef(summary(results.sp.t.did.s))[,"Pr(>|t|)"][1:quant])
            ps.sp.t.did.MUATE.y[,di]<-as.numeric(coef(summary(results.sp.t.did.y))[,"Pr(>|t|)"][1:quant])
            
            ps.gam.t.did.MUATE.[,di]<-as.numeric(gam.model$p.table[,"Pr(>|t|)"])[2:(quant+1)]
            #ps.lm.t.es.TATE[,di]<-as.numeric(coef(summary(results.lm.t.es))[,"Pr(>|t|)"][1:quant])
          }
          
          if(treatc=="WLATE"){
            betas.lm.t.did.WLATE.i[,di]<-as.numeric(coef(summary(results.lm.t.did.i))[,"Estimate"][1:quant])
            betas.lm.t.did.WLATE.a[,di]<-as.numeric(coef(summary(results.lm.t.did.a))[,"Estimate"][1:quant])
            betas.lm.t.did.WLATE.s[,di]<-as.numeric(coef(summary(results.lm.t.did.s))[,"Estimate"][1:quant])
            betas.lm.t.did.WLATE.y[,di]<-as.numeric(coef(summary(results.lm.t.did.y))[,"Estimate"][1:quant])
            
            betas.sp.t.did.WLATE.i[,di]<-as.numeric(coef(summary(results.sp.t.did.i))[,"Estimate"][1:quant])
            betas.sp.t.did.WLATE.a[,di]<-as.numeric(coef(summary(results.sp.t.did.a))[,"Estimate"][1:quant])
            betas.sp.t.did.WLATE.s[,di]<-as.numeric(coef(summary(results.sp.t.did.s))[,"Estimate"][1:quant])
            betas.sp.t.did.WLATE.y[,di]<-as.numeric(coef(summary(results.sp.t.did.y))[,"Estimate"][1:quant])
            
            betas.gam.t.did.WLATE.[,di]<-as.numeric(gam.model$p.table[,"Estimate"])[2:(quant+1)]
            #betas.lm.t.es.TATE[,di]<-as.numeric(coef(summary(results.lm.t.es))[,"Estimate"][1:quant])
            ses.lm.t.did.WLATE.i[,di]<-as.numeric(coef(summary(results.lm.t.did.i))[,"Cluster s.e."][1:quant])
            ses.lm.t.did.WLATE.a[,di]<-as.numeric(coef(summary(results.lm.t.did.a))[,"Cluster s.e."][1:quant])
            ses.lm.t.did.WLATE.s[,di]<-as.numeric(coef(summary(results.lm.t.did.s))[,"Cluster s.e."][1:quant])
            ses.lm.t.did.WLATE.y[,di]<-as.numeric(coef(summary(results.lm.t.did.y))[,"Cluster s.e."][1:quant])
            
            ses.sp.t.did.WLATE.i[,di]<-as.numeric(coef(summary(results.sp.t.did.i))[,"Cluster s.e."][1:quant])
            ses.sp.t.did.WLATE.a[,di]<-as.numeric(coef(summary(results.sp.t.did.a))[,"Cluster s.e."][1:quant])
            ses.sp.t.did.WLATE.s[,di]<-as.numeric(coef(summary(results.sp.t.did.s))[,"Cluster s.e."][1:quant])
            ses.sp.t.did.WLATE.y[,di]<-as.numeric(coef(summary(results.sp.t.did.y))[,"Cluster s.e."][1:quant])
            
            ses.gam.t.did.WLATE.[,di]<-as.numeric(gam.model$p.table[,"Std. Error"])[2:(quant+1)]
            #ses.lm.t.es.TATE[,di]<-as.numeric(coef(summary(results.lm.t.es))[,"Std. Error"][1:quant])
            ps.lm.t.did.WLATE.i[,di]<-as.numeric(coef(summary(results.lm.t.did.i))[,"Pr(>|t|)"][1:quant])
            ps.lm.t.did.WLATE.a[,di]<-as.numeric(coef(summary(results.lm.t.did.a))[,"Pr(>|t|)"][1:quant])
            ps.lm.t.did.WLATE.s[,di]<-as.numeric(coef(summary(results.lm.t.did.s))[,"Pr(>|t|)"][1:quant])
            ps.lm.t.did.WLATE.y[,di]<-as.numeric(coef(summary(results.lm.t.did.y))[,"Pr(>|t|)"][1:quant])
            
            ps.sp.t.did.WLATE.i[,di]<-as.numeric(coef(summary(results.sp.t.did.i))[,"Pr(>|t|)"][1:quant])
            ps.sp.t.did.WLATE.a[,di]<-as.numeric(coef(summary(results.sp.t.did.a))[,"Pr(>|t|)"][1:quant])
            ps.sp.t.did.WLATE.s[,di]<-as.numeric(coef(summary(results.sp.t.did.s))[,"Pr(>|t|)"][1:quant])
            ps.sp.t.did.WLATE.y[,di]<-as.numeric(coef(summary(results.sp.t.did.y))[,"Pr(>|t|)"][1:quant])
            
            ps.gam.t.did.WLATE.[,di]<-as.numeric(gam.model$p.table[,"Pr(>|t|)"])[2:(quant+1)]
            #ps.lm.t.es.TATE[,di]<-as.numeric(coef(summary(results.lm.t.es))[,"Pr(>|t|)"][1:quant])
          }
        }
        if(match=="match"){
          if(treatc=="TATE"){
            betas.match.t.did.TATE.i[,di]<-as.numeric(coef(summary(results.lm.t.did.i))[,"Estimate"][1:quant])
            betas.match.t.did.TATE.a[,di]<-as.numeric(coef(summary(results.lm.t.did.a))[,"Estimate"][1:quant])
            betas.match.t.did.TATE.s[,di]<-as.numeric(coef(summary(results.lm.t.did.s))[,"Estimate"][1:quant])
            betas.match.t.did.TATE.y[,di]<-as.numeric(coef(summary(results.lm.t.did.y))[,"Estimate"][1:quant])
            
            #betas.gam.t.did.TATE.[,di]<-as.numeric(gam.model$p.table[,"Estimate"])[2:(quant+1)]
            #betas.lm.t.es.TATE[,di]<-as.numeric(coef(summary(results.lm.t.es))[,"Estimate"][1:quant])
            ses.match.t.did.TATE.i[,di]<-as.numeric(coef(summary(results.lm.t.did.i))[,"Cluster s.e."][1:quant])
            ses.match.t.did.TATE.a[,di]<-as.numeric(coef(summary(results.lm.t.did.a))[,"Cluster s.e."][1:quant])
            ses.match.t.did.TATE.s[,di]<-as.numeric(coef(summary(results.lm.t.did.s))[,"Cluster s.e."][1:quant])
            ses.match.t.did.TATE.y[,di]<-as.numeric(coef(summary(results.lm.t.did.y))[,"Cluster s.e."][1:quant])
            
            #ses.gam.t.did.TATE.[,di]<-as.numeric(gam.model$p.table[,"Std. Error"])[2:(quant+1)]
            #ses.lm.t.es.TATE[,di]<-as.numeric(coef(summary(results.lm.t.es))[,"Std. Error"][1:quant])
            ps.match.t.did.TATE.i[,di]<-as.numeric(coef(summary(results.lm.t.did.i))[,"Pr(>|t|)"][1:quant])
            ps.match.t.did.TATE.a[,di]<-as.numeric(coef(summary(results.lm.t.did.a))[,"Pr(>|t|)"][1:quant])
            ps.match.t.did.TATE.s[,di]<-as.numeric(coef(summary(results.lm.t.did.s))[,"Pr(>|t|)"][1:quant])
            ps.match.t.did.TATE.y[,di]<-as.numeric(coef(summary(results.lm.t.did.y))[,"Pr(>|t|)"][1:quant])
            
            #ps.gam.t.did.TATE.[,di]<-as.numeric(gam.model$p.table[,"Pr(>|t|)"])[2:(quant+1)]
            #ps.lm.t.es.TATE[,di]<-as.numeric(coef(summary(results.lm.t.es))[,"Pr(>|t|)"][1:quant])
          }
          
          if(treatc=="MUATE"){
            betas.match.t.did.MUATE.i[,di]<-as.numeric(coef(summary(results.lm.t.did.i))[,"Estimate"][1:quant])
            betas.match.t.did.MUATE.a[,di]<-as.numeric(coef(summary(results.lm.t.did.a))[,"Estimate"][1:quant])
            betas.match.t.did.MUATE.s[,di]<-as.numeric(coef(summary(results.lm.t.did.s))[,"Estimate"][1:quant])
            betas.match.t.did.MUATE.y[,di]<-as.numeric(coef(summary(results.lm.t.did.y))[,"Estimate"][1:quant])
            
            #betas.gam.t.did.MUATE.[,di]<-as.numeric(gam.model$p.table[,"Estimate"])[2:(quant+1)]
            #betas.lm.t.es.TATE[,di]<-as.numeric(coef(summary(results.lm.t.es))[,"Estimate"][1:quant])
            ses.match.t.did.MUATE.i[,di]<-as.numeric(coef(summary(results.lm.t.did.i))[,"Cluster s.e."][1:quant])
            ses.match.t.did.MUATE.a[,di]<-as.numeric(coef(summary(results.lm.t.did.a))[,"Cluster s.e."][1:quant])
            ses.match.t.did.MUATE.s[,di]<-as.numeric(coef(summary(results.lm.t.did.s))[,"Cluster s.e."][1:quant])
            ses.match.t.did.MUATE.y[,di]<-as.numeric(coef(summary(results.lm.t.did.y))[,"Cluster s.e."][1:quant])
            
            #ses.gam.t.did.MUATE.[,di]<-as.numeric(gam.model$p.table[,"Std. Error"])[2:(quant+1)]
            #ses.lm.t.es.TATE[,di]<-as.numeric(coef(summary(results.lm.t.es))[,"Std. Error"][1:quant])
            ps.match.t.did.MUATE.i[,di]<-as.numeric(coef(summary(results.lm.t.did.i))[,"Pr(>|t|)"][1:quant])
            ps.match.t.did.MUATE.a[,di]<-as.numeric(coef(summary(results.lm.t.did.a))[,"Pr(>|t|)"][1:quant])
            ps.match.t.did.MUATE.s[,di]<-as.numeric(coef(summary(results.lm.t.did.s))[,"Pr(>|t|)"][1:quant])
            ps.match.t.did.MUATE.y[,di]<-as.numeric(coef(summary(results.lm.t.did.y))[,"Pr(>|t|)"][1:quant])
            
            #ps.gam.t.did.MUATE.[,di]<-as.numeric(gam.model$p.table[,"Pr(>|t|)"])[2:(quant+1)]
            #ps.lm.t.es.TATE[,di]<-as.numeric(coef(summary(results.lm.t.es))[,"Pr(>|t|)"][1:quant])
          }
          
          if(treatc=="WLATE"){
            betas.match.t.did.WLATE.i[,di]<-as.numeric(coef(summary(results.lm.t.did.i))[,"Estimate"][1:quant])
            betas.match.t.did.WLATE.a[,di]<-as.numeric(coef(summary(results.lm.t.did.a))[,"Estimate"][1:quant])
            betas.match.t.did.WLATE.s[,di]<-as.numeric(coef(summary(results.lm.t.did.s))[,"Estimate"][1:quant])
            betas.match.t.did.WLATE.y[,di]<-as.numeric(coef(summary(results.lm.t.did.y))[,"Estimate"][1:quant])
            
            #betas.gam.t.did.WLATE.[,di]<-as.numeric(gam.model$p.table[,"Estimate"])[2:(quant+1)]
            #betas.lm.t.es.TATE[,di]<-as.numeric(coef(summary(results.lm.t.es))[,"Estimate"][1:quant])
            ses.match.t.did.WLATE.i[,di]<-as.numeric(coef(summary(results.lm.t.did.i))[,"Cluster s.e."][1:quant])
            ses.match.t.did.WLATE.a[,di]<-as.numeric(coef(summary(results.lm.t.did.a))[,"Cluster s.e."][1:quant])
            ses.match.t.did.WLATE.s[,di]<-as.numeric(coef(summary(results.lm.t.did.s))[,"Cluster s.e."][1:quant])
            ses.match.t.did.WLATE.y[,di]<-as.numeric(coef(summary(results.lm.t.did.y))[,"Cluster s.e."][1:quant])
            
            #ses.gam.t.did.WLATE.[,di]<-as.numeric(gam.model$p.table[,"Std. Error"])[2:(quant+1)]
            #ses.lm.t.es.TATE[,di]<-as.numeric(coef(summary(results.lm.t.es))[,"Std. Error"][1:quant])
            ps.match.t.did.WLATE.i[,di]<-as.numeric(coef(summary(results.lm.t.did.i))[,"Pr(>|t|)"][1:quant])
            ps.match.t.did.WLATE.a[,di]<-as.numeric(coef(summary(results.lm.t.did.a))[,"Pr(>|t|)"][1:quant])
            ps.match.t.did.WLATE.s[,di]<-as.numeric(coef(summary(results.lm.t.did.s))[,"Pr(>|t|)"][1:quant])
            ps.match.t.did.WLATE.y[,di]<-as.numeric(coef(summary(results.lm.t.did.y))[,"Pr(>|t|)"][1:quant])
            
            #ps.gam.t.did.WLATE.[,di]<-as.numeric(gam.model$p.table[,"Pr(>|t|)"])[2:(quant+1)]
            #ps.lm.t.es.TATE[,di]<-as.numeric(coef(summary(results.lm.t.es))[,"Pr(>|t|)"][1:quant])
          }
        }
        if(FALSE){
          sdf<-10
          lat<-sample$PropertyAddressLatitude
          long<-sample$PropertyAddressLongitude
          splat<-bs(lat, df = sdf)
          splong<-bs(long, df = sdf)
          spint<-model.matrix(~splat:splong)
          
          xcTATE<-cbind(splat,splong,spint,lat,long,poly(sample$day,5),bs(sample$day, df = 10))
          year<-dplyr::select(sample, starts_with('year'))
          
          feTATE<-model.matrix(~ treatind+indx+
                                 #prelogprice+prediffdate+predate+
                                 data.matrix(year[,4:25]),sample)#+#timefedControlsComplete+timefed +
          #aftfinalnpl+timefinalnplfe+
          #data.matrix(exdum)+
          #data.matrix(year[,25]),sample)
          feTATE<-as.matrix(feTATE[,SD(feTATE)>0])
          feTATE<-as.matrix(feTATE[,!duplicated(cor(feTATE))])
          qr.X <- qr(feTATE, tol=1e-3, LAPACK = FALSE)
          (rnkX <- qr.X$rank)  ## 4 (number of non-collinear columns)
          (keep <- qr.X$pivot[seq_len(rnkX)])
          ## 1 2 4 5 
          feTATE <- feTATE[,keep]
          
          W<-cbind(sample$day,lat,long,X)
          colnames(W)[1]<-"day"
          colnames(W)[2]<-"lat"
          colnames(W)[3]<-"long"
          A<-sample$treatmentgroup
          V<-X
          Time<-sample$day
          
          results.tmle.t.did <- tmleMSM(Y = sample$logprice, A = A, W = W, V = V, #T= Time,
                                        MSM = "A + V",family="gaussian", 
                                        Q.SL.library = SL.library2$as.list(),
                                        g.SL.library = SL.library2$as.list(),
                                        #Qform = Y ~ A+V+W,
                                        #gform = A~1,
                                        #hAVform = A~ 1,
                                        ub = 20,
                                        V_SL =5,
                                        alpha = 0.90,
                                        inference = TRUE,
                                        verbose=TRUE)
          print(results.tmle.t.did)
          summary(results.tmle.t.did)
          
          
          sdf<-5
          lat<-sample$PropertyAddressLatitude
          long<-sample$PropertyAddressLongitude
          splat<-bs(lat, df = sdf)
          splong<-bs(long, df = sdf)
          spint<-model.matrix(~splat:splong)
          
          xcTATE<-cbind(splat,splong,spint,lat,long,poly(sample$day,5),bs(sample$day, df = 10))
          feTATEes<-model.matrix(~ treatexCC+#aftfinalnpl+
                                   #as.matrix(exdum)
                                   -1,tsample)
          feTATEes<-as.matrix(feTATEes[,SD(feTATEes)>0])
          if(dim(feTATEes)[2]>1){
            feTATEes<-feTATEes[,!duplicated(cor(feTATEes))]
          }
          qr.X <- qr(feTATEes, tol=1e-3, LAPACK = FALSE)
          (rnkX <- qr.X$rank)  ## 4 (number of non-collinear columns)
          (keep <- qr.X$pivot[seq_len(rnkX)])
          ## 1 2 4 5 
          feTATEes <- feTATEes[,keep]
          if(nocc==0&dim(as.matrix(feTATEes))[2]>0){
            if(dim(data.matrix(tsample))[1]>40){
              W<-cbind(xcTATE[sample$control==0,],xTATE[sample$control==0,],feTATEes)
              
              A<-sample[control==0,treatst]
              V<-feTATEes
              Time<-sample[control==0,day]
              
              results.tmle.t.es <- tmleMSM(Y = tsample$logprice, A = A, W = W, V = V, #T= Time,
                                           MSM = "A + V",family="gaussian", 
                                           Q.SL.library = SL.library2$as.list(),
                                           g.SL.library = PS.library2$as.list(),
                                           #Qform = Y ~ A+V+W,
                                           #gform = A~1,
                                           #hAVform = A~ 1,
                                           ub = 20,
                                           V_SL =5,
                                           alpha = 0.90,
                                           inference = TRUE,
                                           verbose=TRUE)
              print(results.tmle.t.es)
              
              betas.tmle.t.es[di,treat]<-results.tmle.t.es$psi["A"]
              ses.tmle.t.es[di,treat]<-results.tmle.t.es$se["A"]
              ps.tmle.t.es[di,treat]<-results.tmle.t.es$pvalue["A"]
              
              cc.betas.tmle.t.es[di,treat]<-results.tmle.t.es$psi["V"]
              cc.ses.tmle.t.es[di,treat]<-results.tmle.t.es$se["V"]
              cc.ps.tmle.t.es[di,treat]<-results.tmle.t.es$pvalue["V"]
              
              
            }}
          
          
          
          betas.tmle.t.did[di,treat]<-results.tmle.t.did$psi["A"]
          ses.tmle.t.did[di,treat]<-results.tmle.t.did$se["A"]
          ps.tmle.t.did[di,treat]<-results.tmle.t.did$pvalue["A"]
          
          if(nocc==0 &notg==0){
            cc.betas.tmle.t.did[di,treat]<-results.tmle.t.did$psi["VtreatexCC"]
            cc.ses.tmle.t.did[di,treat]<-results.tmle.t.did$se["VtreatexCC"]
            cc.ps.tmle.t.did[di,treat]<-results.tmle.t.did$pvalue["VtreatexCC"]
          }
        }
        
        print(paste0('distance = ',dic))
        print(paste0('treat = ',treatc))
        
      }
    }
  }
}

for(statchange in c('')){
  for(meth in c('lm','gam','match','sp')){
    for(inf in c('did')){
      for(treat in  treatl){
        for(spec in specl){
          #treat<-"TATE"
          
          p<-get(paste0(statchange,'ps.',meth,'.t.',inf,'.',treat,'.',spec))
          mystars <- ifelse(p < .001, "***", ifelse(p < .01, "** ", ifelse(p < .05, "* ", ifelse(p < .1, "^\\bullet  ", " "))))
          if(!is.na(p[1,1])){
            #pb<-exp(get(paste0(statchange,'betas.',meth,'.t.',inf,'.',treat)))-1
            #rpb<-round(pb,3)
            #se<-round(exp(get(paste0(statchange,'ses.',meth,'.t.',inf,'.',treat)))-1,3)
            
            pb<-get(paste0(statchange,'betas.',meth,'.t.',inf,'.',treat,'.',spec))
            rpb<-round(pb,3)
            se<-round(get(paste0(statchange,'ses.',meth,'.t.',inf,'.',treat,'.',spec)),3)
            
            srpb <- matrix(paste(rpb, mystars, sep=""), ncol=dim(pb)[2] )
            nsrpb<-rbind(c("",laglead),cbind(dist,srpb))
            
            #colnames(srpb)<-laglead
            #rownames(srpb)<-dist
            
            results.mat<-matrix(nrow= 2*dim(srpb)[1],ncol= dim(srpb)[2])
            
            for(i in 1:dim(results.mat)[1]){
              if(i %% 2 != 0){
                results.mat[i,]<-srpb[ceiling(i/2),]
                #    rownames(ols.mat)[i]<-rownames(srpb)[ceiling(i/2)]
              }
              if(i %% 2 == 0){
                results.mat[i,]<-paste0('(',se[ceiling(i/2),],')')
              }
            }
            
            results.mat<-rbind(c('10k','8k','6k','4k','2k'),results.mat)
            if(meth=='lm'){
              results.mat<-rbind(c('OLS','','','',''),results.mat)
            }
            if(meth=='gam'){
              results.mat<-rbind(c('GAM','','','',''),results.mat)
            }
            if(meth=='match'){
              results.mat<-rbind(c('Matching','','','',''),results.mat)
            }
            if(meth=='sp'){
              results.mat<-rbind(c('Spatial Lag','','','',''),results.mat)
            }
            # rn<-c(paste0("(",qcut[1],","),paste0(qcut[2],"]"),paste0("(",qcut[2],","),paste0(qcut[3],"]"),
            #      paste0("(",qcut[3],","),paste0(qcut[4],"]"),
            #     paste0("(",qcut[4],","),paste0(qcut[5],"]"),paste0("(",qcut[5],","),
            #    paste0(qcut[6],"]"),paste0("(",qcut[6],","),paste0(qcut[7],"]"),paste0("(",qcut[7],","),
            #   paste0(qcut[8],"]"),paste0("(",qcut[8],","),paste0(qcut[9],"]"),paste0("(",qcut[9],","),
            #  paste0(qcut[10],"]"),
            # paste0("(",qcut[10],","),paste0(qcut[11],"]"))
            rn<-c(paste0("(",qcut[1],",",qcut[2],"]"),"Bottom Ten Percentile" ,
                  paste0("(",qcut[2],",",qcut[quant],"]"),"Middle 80 Percentile" ,
                  paste0("(",qcut[quant],",",qcut[quant+1],"]"), "Top Ten Percentile")
            rn2<-c("                                      ","                      ",paste0("(",qcut[1],", ",qcut[2],"]")," ",paste0("(",qcut[2],",  ",qcut[3],"]"),"  ",
                   paste0("(",qcut[3],", ",qcut[4],"]"),"   ",
                   paste0("(",qcut[4],",",qcut[5],"]"),"     ",paste0("(",qcut[5],",",qcut[6],"]"),"      ",
                   paste0("(",qcut[6],",",qcut[7],"]"),"       ",paste0("(",qcut[7],",",qcut[8],"]"),"        ",
                   paste0("(",qcut[8],",",qcut[9],"]"),"           ", paste0("(",qcut[9],",",qcut[10],"]"),"           ",
                   paste0("(",qcut[10],",",qcut[11],"]"),"                       ")
            #rownames(results.mat)<-rn2
            results.mat<-cbind(rn2,results.mat)
            xtab<-xtable(results.mat)
            align(xtab) <- "rl|rrrrr"
            print.xtable(xtab,include.rownames=FALSE, hline.after = c(0,1,2,dim(results.mat)[1]),
                         include.colnames=FALSE, sanitize.text.function = identity,
                         #caption = "example", 
                         label = paste0("tab:",meth,inf,statchange,treat,spec),
                         type="latex", file=paste0(path,'latex/',meth,inf,statchange,treat,spec,".tex"))
            
            
            
            
            qu<-c("Bottom","Middle","Top")
            qun<-c(1:10)
            allModelFrame <- data.frame(Variable = qun,
                                        Coefficient = pb[,1],
                                        SE = se[, 1],
                                        modelName = "10k")
            for(i in 2:length(dist)){
              di<-dist[i]
              modelFrame <- data.frame(Variable =  qun,
                                       Coefficient = pb[,i],
                                       SE = se[, i],
                                       modelName = di)
              allModelFrame <- data.frame(rbind(allModelFrame,modelFrame))
              
            }
            
            interval2 <- -qnorm((1-0.90)/2)  # 95% multiplier
            leg<-c('10k','8k','6k','4k','2k')
            allModelFrame<-allModelFrame[allModelFrame$modelName!="2k",]
            allModelFrame$modelName<-as.factor( allModelFrame$modelName)
            allModelFrame$modelName<-factor(allModelFrame$modelName,levels(allModelFrame$modelName)[c(2:5,1)])
            
            # Plot
            zp1 <- ggplot(allModelFrame, aes(colour = modelName ))
            zp1 <- zp1 + geom_hline(yintercept = 0, colour = gray(1/2), lty = 2)
            zp1 <- zp1 + geom_pointrange(aes(x = Variable, y = Coefficient, ymin = Coefficient - SE*interval2,
                                             ymax = Coefficient + SE*interval2,color =modelName),
                                         lwd = 1/2, position = position_dodge(width = 1/2),
                                         shape = 21, fill = "WHITE")
            #zp1 <- zp1 + coord_flip() + theme_bw()
            
            #zp1 <- zp1 + geom_line(data = allModelFrame, aes(linetype =modelName ), size = 1) +
            zp1 <- zp1 + ggtitle("Comparing distance cut-offs")+xlab('Quantile')  
            #zp1 <- zp1 + scale_x_continuous(labels=c("1"="B","2"="M","3"="T"))
            zp1 <- zp1 + scale_x_continuous(breaks=qun)
            print(zp1)  # The trick to these is position_dodge().
            
            ggsave(file=paste(path,'latex/','coeff',meth,treat,spec, '.png', sep=""),height = 7,width =9)
          }
        }
        
      }
    }
  }
}

for(meth in c("lm","gam","match",'sp')){
  p<-get(paste0('ps.',meth,'.did'))
  mystars <- ifelse(p < .001, "***", ifelse(p < .01, "** ", ifelse(p < .05, "* ", ifelse(p < .1, "^\\bullet  ", " "))))
  
  #pb<-exp(get(paste0(statchange,'betas.',meth,'.t.',inf,'.',treat)))-1
  #rpb<-round(pb,3)
  #se<-round(exp(get(paste0(statchange,'ses.',meth,'.t.',inf,'.',treat)))-1,3)
  
  pb<-get(paste0('betas.',meth,'.did'))
  rpb<-round(pb,3)
  se<-round(get(paste0('ses.',meth,'.did')),3)
  
  srpb <- matrix(paste(rpb, mystars, sep=""), ncol=dim(pb)[2] )
  nsrpb<-rbind(c("",laglead),cbind(dist,srpb))
  
  #colnames(srpb)<-laglead
  #rownames(srpb)<-dist
  
  results.mat<-matrix(nrow= 2*dim(srpb)[1],ncol= dim(srpb)[2])
  
  for(i in 1:dim(results.mat)[1]){
    if(i %% 2 != 0){
      results.mat[i,]<-srpb[ceiling(i/2),]
      #    rownames(ols.mat)[i]<-rownames(srpb)[ceiling(i/2)]
    }
    if(i %% 2 == 0){
      results.mat[i,]<-paste0('(',se[ceiling(i/2),],')')
    }
  }
  
  results.mat<-rbind(c('10k','8k','6k','4k','2k'),results.mat)
  if(meth=='lm'){
    results.mat<-rbind(c('OLS','','','',''),results.mat)
  }
  if(meth=='gam'){
    results.mat<-rbind(c('GAM','','','',''),results.mat)
  }
  if(meth=='match'){
    results.mat<-rbind(c('Matching','','','',''),results.mat)
  }
  if(meth=='sp'){
    results.mat<-rbind(c('Spatial Lag','','','',''),results.mat)
  }
  # rn<-c(paste0("(",qcut[1],","),paste0(qcut[2],"]"),paste0("(",qcut[2],","),paste0(qcut[3],"]"),
  #      paste0("(",qcut[3],","),paste0(qcut[4],"]"),
  #     paste0("(",qcut[4],","),paste0(qcut[5],"]"),paste0("(",qcut[5],","),
  #    paste0(qcut[6],"]"),paste0("(",qcut[6],","),paste0(qcut[7],"]"),paste0("(",qcut[7],","),
  #   paste0(qcut[8],"]"),paste0("(",qcut[8],","),paste0(qcut[9],"]"),paste0("(",qcut[9],","),
  #  paste0(qcut[10],"]"),
  # paste0("(",qcut[10],","),paste0(qcut[11],"]"))
  rn<-c(" ","  ", "Total","  ","Municipal Water","   ","Well Water","    ")
  
  #rownames(results.mat)<-rn
  results.mat<-cbind(rn,results.mat)
  xtab<-xtable(results.mat)
  align(xtab) <- "rl|rrrrr"
  print.xtable(xtab,include.rownames=FALSE, hline.after = c(0,1,2,dim(results.mat)[1]),
               include.colnames=FALSE, sanitize.text.function = identity,
               #caption = "example", 
               label = paste0("tab:",meth,"water"),
               type="latex", file=paste0(path,'latex/ATEcomp',meth,'.tex'))
  
  qu<-c("Bottom","Middle","Top")
  if(FALSE){
    allModelFrame <- data.frame(Variable = qu,
                                Coefficient = pb[,1],
                                SE = se[, 1],
                                modelName = "10k")
    for(i in 2:length(dist)){
      di<-dist[i]
      modelFrame <- data.frame(Variable =  qu,
                               Coefficient = pb[,i],
                               SE = se[, i],
                               modelName = di)
      allModelFrame <- data.frame(rbind(allModelFrame,modelFrame))
      
    }
    
    
    interval2 <- -qnorm((1-0.90)/2)  # 95% multiplier
    leg<-c('10k','8k','6k','4k','2k')
    allModelFrame<-allModelFrame[allModelFrame$modelName!="2k",]
    allModelFrame$modelName<-as.factor( allModelFrame$modelName)
    allModelFrame$modelName<-factor(allModelFrame$modelName,levels(allModelFrame$modelName)[c(2:5,1)])
    
    # Plot
    zp1 <- ggplot(allModelFrame, aes(colour = modelName ))
    zp1 <- zp1 + geom_hline(yintercept = 0, colour = gray(1/2), lty = 2)
    zp1 <- zp1 + geom_pointrange(aes(x = Variable, y = Coefficient, ymin = Coefficient - SE*interval2,
                                     ymax = Coefficient + SE*interval2,color =modelName),
                                 lwd = 1/2, position = position_dodge(width = 1/2),
                                 shape = 21, fill = "WHITE")
    #zp1 <- zp1 + coord_flip() + theme_bw()
    
    #zp1 <- zp1 + geom_line(data = allModelFrame, aes(linetype =modelName ), size = 1) +
    zp1 <- zp1 + ggtitle("Comparing distance cut-offs")+xlab('Quantile')  
    #zp1 <- zp1 + scale_x_discrete(breaks=qu)
    print(zp1)  # The trick to these is position_dodge().
    
    ggsave(file=paste(path,'latex/','coeff',meth,treat, '.png', sep=""),height = 7,width =9)
  }
}

for(statchange in c('')){
  for(meth in c('lm',"match",'sp')){
    for(inf in c('did')){
      for(treat in  treatl){
        for(di in dist){
          #treat<-"TATE"
          #di<-1
          #meth<-'lm'
          
          p1<-get(paste0(statchange,'ps.',meth,'.t.',inf,'.',treat,'.',specl[1]))
          p2<-get(paste0(statchange,'ps.',meth,'.t.',inf,'.',treat,'.',specl[2]))
          p3<-get(paste0(statchange,'ps.',meth,'.t.',inf,'.',treat,'.',specl[3]))
          p4<-get(paste0(statchange,'ps.',meth,'.t.',inf,'.',treat,'.',specl[4]))
          p<-rbind(p1,p2,p3,p4)
          mystars <- ifelse(p < .001, "***", ifelse(p < .01, "** ", ifelse(p < .05, "* ", ifelse(p < .1, "^\\bullet  ", " "))))
          if(!is.na(p[1,1])){
            #pb<-exp(get(paste0(statchange,'betas.',meth,'.t.',inf,'.',treat)))-1
            #rpb<-round(pb,3)
            #se<-round(exp(get(paste0(statchange,'ses.',meth,'.t.',inf,'.',treat)))-1,3)
            
            pb1<-get(paste0(statchange,'betas.',meth,'.t.',inf,'.',treat,'.',specl[1]))
            pb2<-get(paste0(statchange,'betas.',meth,'.t.',inf,'.',treat,'.',specl[2]))
            pb3<-get(paste0(statchange,'betas.',meth,'.t.',inf,'.',treat,'.',specl[3]))
            pb4<-get(paste0(statchange,'betas.',meth,'.t.',inf,'.',treat,'.',specl[4]))
            pb<-rbind(pb1,pb2,pb3,pb4)
            
            pb10k<-cbind(pb[1:10,1],pb[11:20,1],pb[21:30,1],pb[31:40,1])
            pb8k<-cbind(pb[1:10,2],pb[11:20,2],pb[21:30,2],pb[31:40,2])
            pb6k<-cbind(pb[1:10,3],pb[11:20,3],pb[21:30,3],pb[31:40,3])
            pb4k<-cbind(pb[1:10,4],pb[11:20,4],pb[21:30,4],pb[31:40,4])
            
            rpb<-round(pb,3)
            se1<-round(get(paste0(statchange,'ses.',meth,'.t.',inf,'.',treat,'.',specl[1])),3)
            se2<-round(get(paste0(statchange,'ses.',meth,'.t.',inf,'.',treat,'.',specl[2])),3)
            se3<-round(get(paste0(statchange,'ses.',meth,'.t.',inf,'.',treat,'.',specl[3])),3)
            se4<-round(get(paste0(statchange,'ses.',meth,'.t.',inf,'.',treat,'.',specl[4])),3)
            se<-rbind(se1,se2,se3,se4)
            
            se10k<-cbind(se[1:10,1],se[11:20,1],se[21:30,1],se[31:40,1])
            se8k<-cbind(se[1:10,2],se[11:20,2],se[21:30,2],se[31:40,2])
            se6k<-cbind(se[1:10,3],se[11:20,3],se[21:30,3],se[31:40,3])
            se4k<-cbind(se[1:10,4],se[11:20,4],se[21:30,4],se[31:40,4])
            
            srpb <- matrix(paste(rpb, mystars, sep=""), ncol=dim(pb)[2] )
            nsrpb<-rbind(c("",laglead),cbind(dist,srpb))
            
            #colnames(srpb)<-laglead
            #rownames(srpb)<-dist
            #10k
            
            
            results.mat<-matrix(nrow= 2*dim(srpb)[1],ncol= dim(srpb)[2])
            
            for(i in 1:dim(results.mat)[1]){
              if(i %% 2 != 0){
                results.mat[i,]<-srpb[ceiling(i/2),]
                #    rownames(ols.mat)[i]<-rownames(srpb)[ceiling(i/2)]
              }
              if(i %% 2 == 0){
                results.mat[i,]<-paste0('(',se[ceiling(i/2),],')')
              }
            }
            
            colnames(results.mat)<-c('10k','8k','6k','4k','2k')
            # rn<-c(paste0("(",qcut[1],","),paste0(qcut[2],"]"),paste0("(",qcut[2],","),paste0(qcut[3],"]"),
            #      paste0("(",qcut[3],","),paste0(qcut[4],"]"),
            #     paste0("(",qcut[4],","),paste0(qcut[5],"]"),paste0("(",qcut[5],","),
            #    paste0(qcut[6],"]"),paste0("(",qcut[6],","),paste0(qcut[7],"]"),paste0("(",qcut[7],","),
            #   paste0(qcut[8],"]"),paste0("(",qcut[8],","),paste0(qcut[9],"]"),paste0("(",qcut[9],","),
            #  paste0(qcut[10],"]"),
            # paste0("(",qcut[10],","),paste0(qcut[11],"]"))
            
            results10k<-cbind(results.mat[1:20,1],results.mat[21:40,1],results.mat[41:60,1],results.mat[61:80,1])
            results8k<-cbind(results.mat[1:20,2],results.mat[21:40,2],results.mat[41:60,2],results.mat[61:80,2])
            results6k<-cbind(results.mat[1:20,3],results.mat[21:40,3],results.mat[41:60,3],results.mat[61:80,3])
            results4k<-cbind(results.mat[1:20,4],results.mat[21:40,4],results.mat[41:60,4],results.mat[61:80,4])
            FEmatrix<- c("Census Tract","Census Tract","Superfund Site","Superfund Site")
            Cluster<-c("Tract by Year","Site by Year","Tract by Year","Site by Year")
            rn2<-c(paste0("(",qcut[1],",",qcut[2],"]"),"  ",paste0("(",qcut[2],",",qcut[3],"]"),"    ",
                   paste0("(",qcut[3],",",qcut[4],"]"),"      ",
                   paste0("(",qcut[4],",",qcut[5],"]"),"       ",paste0("(",qcut[5],",",qcut[6],"]"),"        ",
                   paste0("(",qcut[6],",",qcut[7],"]"),"           ",paste0("(",qcut[7],",",qcut[8],"]"),"            ",
                   paste0("(",qcut[8],",",qcut[9],"]"),"             ", paste0("(",qcut[9],",",qcut[10],"]"),"          ",
                   paste0("(",qcut[10],",",qcut[11],"]"),"                  ", "Fixed Effects", "Cluster")
            
            
            results10k<-rbind(results10k,FEmatrix,Cluster)
            results8k<-rbind(results8k,FEmatrix,Cluster)
            results6k<-rbind(results6k,FEmatrix,Cluster)
            results4k<-rbind(results4k,FEmatrix,Cluster)
            
            rownames(results10k)<-rn2
            rownames(results8k)<-rn2
            rownames(results6k)<-rn2
            rownames(results4k)<-rn2
            
            rn<-c(paste0("(",qcut[1],",",qcut[2],"]"),"Bottom Ten Percentile" ,
                  paste0("(",qcut[2],",",qcut[quant],"]"),"Middle 80 Percentile" ,
                  paste0("(",qcut[quant],",",qcut[quant+1],"]"), "Top Ten Percentile")
            
            xtable(results10k)
            print.xtable(xtable(results10k),include.rownames=TRUE, 
                         include.colnames=FALSE, sanitize.text.function = identity,
                         type="latex", file=paste0(path,'latex/',meth,inf,statchange,treat,"10k.tex"))
            xtable(results8k)
            print.xtable(xtable(results8k),include.rownames=TRUE, 
                         include.colnames=FALSE, sanitize.text.function = identity,
                         type="latex", file=paste0(path,'latex/',meth,inf,statchange,treat,"8k.tex"))
            xtable(results6k)
            print.xtable(xtable(results6k),include.rownames=TRUE, 
                         include.colnames=FALSE, sanitize.text.function = identity,
                         type="latex", file=paste0(path,'latex/',meth,inf,statchange,treat,"6k.tex"))
            xtable(results4k)
            print.xtable(xtable(results4k),include.rownames=TRUE, 
                         include.colnames=FALSE, sanitize.text.function = identity,
                         type="latex", file=paste0(path,'latex/',meth,inf,statchange,treat,"4k.tex"))
            
            
            
            qu<-c("Bottom","Middle","Top")
            leg<-c('Block','Block Group','Tract','Site')
            qun<-c(1:10)
            for(j in c("4k","6k","8k","10k")){
              pb<-get(paste0("pb",j))
              se<-get(paste0("se",j))
              allModelFrame <- data.frame(Variable = qun,
                                          Coefficient = pb[,1],
                                          SE = se[, 1],
                                          modelName = 'Block')
              for(i in 2:length(leg)){
                le<-leg[i]
                modelFrame <- data.frame(Variable =  qun,
                                         Coefficient = pb[,i],
                                         SE = se[, i],
                                         modelName = le)
                allModelFrame <- data.frame(rbind(allModelFrame,modelFrame))
                
              }
              
              interval2 <- -qnorm((1-0.95)/2)  # 95% multiplier
              allModelFrame<-allModelFrame[allModelFrame$modelName!="2k",]
              allModelFrame$modelName<-factor( allModelFrame$modelName,ordered = TRUE)
              allModelFrame$modelName<-factor(allModelFrame$modelName,levels(allModelFrame$modelName)[c(1,2,4,3)],ordered = TRUE)
              
              
              # Plot
              zp1 <- ggplot(allModelFrame, aes(colour = modelName ))
              
              zp1 <- zp1 + geom_hline(yintercept = 0, colour = gray(1/2), lty = 2)
              zp1 <- zp1 + geom_pointrange(aes(x = Variable, y = Coefficient, ymin = Coefficient - SE*interval2,
                                               ymax = Coefficient + SE*interval2,color =modelName),
                                           lwd = 1/2, position = position_dodge(width = 1/2),
                                           shape = 21, fill = "WHITE")
              #zp1 <- zp1 + coord_flip() + theme_bw()
              
              #zp1 <- zp1 + geom_line(data = allModelFrame, aes(linetype =modelName ), size = 1) +
              zp1 <- zp1 + ggtitle("Comparing distance cut-offs")+xlab('Quantile')  
              #zp1 <- zp1 + scale_x_continuous(labels=c("1"="B","2"="M","3"="T"))
              #scale_color_discrete(breaks=c("1","3","10")
              
              zp1 <- zp1 + scale_x_continuous(breaks=qun)
              zp1 <- zp1  +  labs(color="Fixed Effects")
              print(zp1)  # The trick to these is position_dodge().
              
              ggsave(file=paste(path,'latex/','coeff',meth,treat,j, 'ols.png', sep=""),height = 7,width =9)
            }
          }
        }
        
      }
    }
  }
}
